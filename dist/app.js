(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  function dedupe(deps) {
    var newDeps = [];
    for (var i = 0, l = deps.length; i < l; i++)
      if (indexOf.call(newDeps, deps[i]) == -1)
        newDeps.push(deps[i])
    return newDeps;
  }

  function register(name, deps, declare, execute) {
    if (typeof name != 'string')
      throw "System.register provided no module name";

    var entry;

    // dynamic
    if (typeof declare == 'boolean') {
      entry = {
        declarative: false,
        deps: deps,
        execute: execute,
        executingRequire: declare
      };
    }
    else {
      // ES6 declarative
      entry = {
        declarative: true,
        deps: deps,
        declare: declare
      };
    }

    entry.name = name;

    // we never overwrite an existing define
    if (!(name in defined))
      defined[name] = entry; 

    entry.deps = dedupe(entry.deps);

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }

  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;
      exports[name] = value;

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          var importerIndex = indexOf.call(importerModule.dependencies, module);
          importerModule.setters[importerIndex](exports);
        }
      }

      module.locked = false;
      return value;
    });

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    if (!module.setters || !module.execute)
      throw new TypeError("Invalid System.register form for " + entry.name);

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        if (depEntry.module.exports && depEntry.module.exports.__esModule)
          depExports = depEntry.module.exports;
        else
          depExports = { 'default': depEntry.module.exports, __useDefault: true };
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);

      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);

    if (output)
      module.exports = output;
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    var module = entry.module.exports;

    if (!module || !entry.declarative && module.__esModule !== true)
      module = { 'default': module, __useDefault: true };

    // return the defined module object
    return modules[name] = module;
  };

  return function(mains, declare) {

    var System;
    var System = {
      register: register, 
      get: load, 
      set: function(name, module) {
        modules[name] = module; 
      },
      newModule: function(module) {
        return module;
      },
      global: global 
    };
    System.set('@empty', {});

    declare(System);

    for (var i = 0; i < mains.length; i++)
      load(mains[i]);
  }

})(typeof window != 'undefined' ? window : global)
/* (['mainModule'], function(System) {
  System.register(...);
}); */

(['js/main'], function(System) {

System.register("npm:react@0.14.0-beta3/lib/ReactCurrentOwner", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactCurrentOwner = {current: null};
  module.exports = ReactCurrentOwner;
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return ;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ESCAPE_LOOKUP = {
    '&': '&amp;',
    '>': '&gt;',
    '<': '&lt;',
    '"': '&quot;',
    '\'': '&#x27;'
  };
  var ESCAPE_REGEX = /[&><"']/g;
  function escaper(match) {
    return ESCAPE_LOOKUP[match];
  }
  function escapeTextContentForBrowser(text) {
    return ('' + text).replace(ESCAPE_REGEX, escaper);
  }
  module.exports = escapeTextContentForBrowser;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  function emptyFunction() {}
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module.exports = emptyFunction;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/CSSProperty", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var isUnitlessNumber = {
    animationIterationCount: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeDashoffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundImage: true,
      backgroundPosition: true,
      backgroundRepeat: true,
      backgroundColor: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };
  module.exports = CSSProperty;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  module.exports = ExecutionEnvironment;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/camelize", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module.exports = camelize;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/dangerousStyleValue", ["npm:react@0.14.0-beta3/lib/CSSProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var CSSProperty = require("npm:react@0.14.0-beta3/lib/CSSProperty");
  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  function dangerousStyleValue(name, value) {
    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value;
    }
    if (typeof value === 'string') {
      value = value.trim();
    }
    return value + 'px';
  }
  module.exports = dangerousStyleValue;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/hyphenate", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }
  module.exports = hyphenate;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/memoizeStringOnly", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function memoizeStringOnly(callback) {
    var cache = {};
    return function(string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }
  module.exports = memoizeStringOnly;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/toArray", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    function toArray(obj) {
      var length = obj.length;
      !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
      !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
      !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    module.exports = toArray;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/getMarkupWrap", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {};
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap
    };
    var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
    svgElements.forEach(function(nodeName) {
      markupWrap[nodeName] = svgWrap;
      shouldWrap[nodeName] = true;
    });
    function getMarkupWrap(nodeName) {
      !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/keyMirror", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var keyMirror = function(obj) {
      var ret = {};
      var key;
      !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        ret[key] = key;
      }
      return ret;
    };
    module.exports = keyMirror;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/setInnerHTML", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var setInnerHTML = function(node, html) {
      node.innerHTML = html;
    };
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      setInnerHTML = function(node, html) {
        MSApp.execUnsafeLocalFunction(function() {
          node.innerHTML = html;
        });
      };
    }
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function(node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = String.fromCharCode(0xFEFF) + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
    }
    module.exports = setInnerHTML;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/setTextContent", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser", "npm:react@0.14.0-beta3/lib/setInnerHTML"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
  var escapeTextContentForBrowser = require("npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser");
  var setInnerHTML = require("npm:react@0.14.0-beta3/lib/setInnerHTML");
  var setTextContent = function(node, text) {
    node.textContent = text;
  };
  if (ExecutionEnvironment.canUseDOM) {
    if (!('textContent' in document.documentElement)) {
      setTextContent = function(node, text) {
        setInnerHTML(node, escapeTextContentForBrowser(text));
      };
    }
  }
  module.exports = setTextContent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/EventConstants", ["npm:fbjs@0.1.0-alpha.4/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyMirror = require("npm:fbjs@0.1.0-alpha.4/lib/keyMirror");
  var PropagationPhases = keyMirror({
    bubbled: null,
    captured: null
  });
  var topLevelTypes = keyMirror({
    topAbort: null,
    topBlur: null,
    topCanPlay: null,
    topCanPlayThrough: null,
    topChange: null,
    topClick: null,
    topCompositionEnd: null,
    topCompositionStart: null,
    topCompositionUpdate: null,
    topContextMenu: null,
    topCopy: null,
    topCut: null,
    topDoubleClick: null,
    topDrag: null,
    topDragEnd: null,
    topDragEnter: null,
    topDragExit: null,
    topDragLeave: null,
    topDragOver: null,
    topDragStart: null,
    topDrop: null,
    topDurationChange: null,
    topEmptied: null,
    topEncrypted: null,
    topEnded: null,
    topError: null,
    topFocus: null,
    topInput: null,
    topKeyDown: null,
    topKeyPress: null,
    topKeyUp: null,
    topLoad: null,
    topLoadedData: null,
    topLoadedMetadata: null,
    topLoadStart: null,
    topMouseDown: null,
    topMouseMove: null,
    topMouseOut: null,
    topMouseOver: null,
    topMouseUp: null,
    topPaste: null,
    topPause: null,
    topPlay: null,
    topPlaying: null,
    topProgress: null,
    topRateChange: null,
    topReset: null,
    topScroll: null,
    topSeeked: null,
    topSeeking: null,
    topSelectionChange: null,
    topStalled: null,
    topSuspend: null,
    topSubmit: null,
    topTextInput: null,
    topTimeUpdate: null,
    topTouchCancel: null,
    topTouchEnd: null,
    topTouchMove: null,
    topTouchStart: null,
    topVolumeChange: null,
    topWaiting: null,
    topWheel: null
  });
  var EventConstants = {
    topLevelTypes: topLevelTypes,
    PropagationPhases: PropagationPhases
  };
  module.exports = EventConstants;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/EventPluginRegistry", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var EventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!EventPluginOrder) {
        return ;
      }
      for (var pluginName in namesToPlugins) {
        var PluginModule = namesToPlugins[pluginName];
        var pluginIndex = EventPluginOrder.indexOf(pluginName);
        !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
        EventPluginRegistry.plugins[pluginIndex] = PluginModule;
        var publishedEvents = PluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
      !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, PluginModule, eventName) {
      !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
      EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      injectEventPluginOrder: function(InjectedEventPluginOrder) {
        !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
        EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function(injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var PluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
            !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
            namesToPlugins[pluginName] = PluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function(event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        for (var phase in dispatchConfig.phasedRegistrationNames) {
          if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
          if (PluginModule) {
            return PluginModule;
          }
        }
        return null;
      },
      _resetEventPlugins: function() {
        EventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/EventPluginUtils", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var injection = {
      Mount: null,
      injectMount: function(InjectedMount) {
        injection.Mount = InjectedMount;
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
        }
      }
    };
    var topLevelTypes = EventConstants.topLevelTypes;
    function isEndish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
    }
    function isMoveish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
    }
    function isStartish(topLevelType) {
      return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
    }
    var validateEventDispatches;
    if (process.env.NODE_ENV !== 'production') {
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchIDs = event._dispatchIDs;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var idsIsArr = Array.isArray(dispatchIDs);
        var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
      };
    }
    function forEachEventDispatch(event, cb) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if (process.env.NODE_ENV !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          cb(event, dispatchListeners[i], dispatchIDs[i]);
        }
      } else if (dispatchListeners) {
        cb(event, dispatchListeners, dispatchIDs);
      }
    }
    function executeDispatch(event, listener, domID) {
      event.currentTarget = injection.Mount.getNode(domID);
      var returnValue = listener(event, domID);
      event.currentTarget = null;
      return returnValue;
    }
    function executeDispatchesInOrder(event, cb) {
      forEachEventDispatch(event, cb);
      event._dispatchListeners = null;
      event._dispatchIDs = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchIDs = event._dispatchIDs;
      if (process.env.NODE_ENV !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchIDs[i])) {
            return dispatchIDs[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchIDs)) {
          return dispatchIDs;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchIDs = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if (process.env.NODE_ENV !== 'production') {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchID = event._dispatchIDs;
      !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
      var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
      event._dispatchListeners = null;
      event._dispatchIDs = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatch: executeDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      getNode: function(id) {
        return injection.Mount.getNode(id);
      },
      getID: function(node) {
        return injection.Mount.getID(node);
      },
      injection: injection
    };
    module.exports = EventPluginUtils;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/accumulateInto", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    function accumulateInto(current, next) {
      !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
      if (current == null) {
        return next;
      }
      var currentIsArray = Array.isArray(current);
      var nextIsArray = Array.isArray(next);
      if (currentIsArray && nextIsArray) {
        current.push.apply(current, next);
        return current;
      }
      if (currentIsArray) {
        current.push(next);
        return current;
      }
      if (nextIsArray) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/forEachAccumulated", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var forEachAccumulated = function(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  };
  module.exports = forEachAccumulated;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactEventEmitterMixin", ["npm:react@0.14.0-beta3/lib/EventPluginHub"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventPluginHub = require("npm:react@0.14.0-beta3/lib/EventPluginHub");
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue();
  }
  var ReactEventEmitterMixin = {handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
      runEventQueueInBatch(events);
    }};
  module.exports = ReactEventEmitterMixin;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ViewportMetrics", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ViewportMetrics = {
    currentScrollLeft: 0,
    currentScrollTop: 0,
    refreshScrollValues: function(scrollPosition) {
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };
  module.exports = ViewportMetrics;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/Object.assign", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function assign(target, sources) {
    if (target == null) {
      throw new TypeError('Object.assign target cannot be null or undefined');
    }
    var to = Object(target);
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
      var nextSource = arguments[nextIndex];
      if (nextSource == null) {
        continue;
      }
      var from = Object(nextSource);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
    }
    return to;
  }
  module.exports = assign;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/isEventSupported", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = (eventName in document);
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  module.exports = isEventSupported;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactElement", ["npm:react@0.14.0-beta3/lib/ReactCurrentOwner", "npm:react@0.14.0-beta3/lib/Object.assign", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = require("npm:react@0.14.0-beta3/lib/ReactCurrentOwner");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var RESERVED_PROPS = {
      key: true,
      ref: true
    };
    var ReactElement = function(type, key, ref, owner, props) {
      this.type = type;
      this.key = key;
      this.ref = ref;
      this._owner = owner;
      this.props = props;
      if (process.env.NODE_ENV !== 'production') {
        this._store = {};
        try {
          Object.defineProperty(this._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
        } catch (x) {
          this._store.validated = false;
        }
        Object.freeze(this.props);
        Object.freeze(this);
      }
    };
    ReactElement.prototype = {_isReactElement: true};
    ReactElement.createElement = function(type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      if (config != null) {
        ref = config.ref === undefined ? null : config.ref;
        key = config.key === undefined ? null : '' + config.key;
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (typeof props[propName] === 'undefined') {
            props[propName] = defaultProps[propName];
          }
        }
      }
      return new ReactElement(type, key, ref, ReactCurrentOwner.current, props);
    };
    ReactElement.createFactory = function(type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
      var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, newProps);
      if (process.env.NODE_ENV !== 'production') {
        newElement._store.validated = oldElement._store.validated;
      }
      return newElement;
    };
    ReactElement.cloneElement = function(element, config, children) {
      var propName;
      var props = assign({}, element.props);
      var key = element.key;
      var ref = element.ref;
      var owner = element._owner;
      if (config != null) {
        if (config.ref !== undefined) {
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (config.key !== undefined) {
          key = '' + config.key;
        }
        for (propName in config) {
          if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      return new ReactElement(element.type, key, ref, owner, props);
    };
    ReactElement.isValidElement = function(object) {
      var isElement = !!(object && object._isReactElement);
      return isElement;
    };
    module.exports = ReactElement;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactInstanceMap", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactInstanceMap = {
    remove: function(key) {
      key._reactInternalInstance = undefined;
    },
    get: function(key) {
      return key._reactInternalInstance;
    },
    has: function(key) {
      return key._reactInternalInstance !== undefined;
    },
    set: function(key, value) {
      key._reactInternalInstance = value;
    }
  };
  module.exports = ReactInstanceMap;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactRootIndexInjection = {injectCreateReactRootIndex: function(_createReactRootIndex) {
      ReactRootIndex.createReactRootIndex = _createReactRootIndex;
    }};
  var ReactRootIndex = {
    createReactRootIndex: null,
    injection: ReactRootIndexInjection
  };
  module.exports = ReactRootIndex;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/adler32", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var MOD = 65521;
  function adler32(data) {
    var a = 1;
    var b = 0;
    var i = 0;
    var l = data.length;
    var m = l & ~0x3;
    while (i < m) {
      for (; i < Math.min(i + 4096, m); i += 4) {
        b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
      }
      a %= MOD;
      b %= MOD;
    }
    for (; i < l; i++) {
      b += a += data.charCodeAt(i);
    }
    a %= MOD;
    b %= MOD;
    return a | b << 16;
  }
  module.exports = adler32;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactPerf", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPerf = {
      enableMeasure: false,
      storedMeasure: _noMeasure,
      measureMethods: function(object, objectName, methodNames) {
        if (process.env.NODE_ENV !== 'production') {
          for (var key in methodNames) {
            if (!methodNames.hasOwnProperty(key)) {
              continue;
            }
            object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
          }
        }
      },
      measure: function(objName, fnName, func) {
        if (process.env.NODE_ENV !== 'production') {
          var measuredFunc = null;
          var wrapper = function() {
            if (ReactPerf.enableMeasure) {
              if (!measuredFunc) {
                measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
              }
              return measuredFunc.apply(this, arguments);
            }
            return func.apply(this, arguments);
          };
          wrapper.displayName = objName + '_' + fnName;
          return wrapper;
        }
        return func;
      },
      injection: {injectMeasure: function(measure) {
          ReactPerf.storedMeasure = measure;
        }}
    };
    function _noMeasure(objName, fnName, func) {
      return func;
    }
    module.exports = ReactPerf;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactOwner", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var ReactOwner = {
      isValidOwner: function(object) {
        return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
      },
      addComponentAsRefTo: function(component, ref, owner) {
        !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to add a ref to a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(false) : undefined;
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function(component, ref, owner) {
        !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' + 'usually means that you\'re trying to remove a ref from a component that ' + 'doesn\'t have an owner (that is, was not created inside of another ' + 'component\'s `render` method). Try rendering this component inside of ' + 'a new top-level component which will hold the ref.') : invariant(false) : undefined;
        if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
          owner.detachRef(ref);
        }
      }
    };
    module.exports = ReactOwner;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/PooledClass", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var oneArgumentPooler = function(copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function(a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function(a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function(a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function(instance) {
      var Klass = this;
      !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
      if (instance.destructor) {
        instance.destructor();
      }
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function(CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/Transaction", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var Mixin = {
      reinitializeTransaction: function() {
        this.transactionWrappers = this.getTransactionWrappers();
        if (this.wrapperInitData) {
          this.wrapperInitData.length = 0;
        } else {
          this.wrapperInitData = [];
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function() {
        return !!this._isInTransaction;
      },
      perform: function(method, scope, a, b, c, d, e, f) {
        !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function(startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function(startIndex) {
        !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
              wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    var Transaction = {
      Mixin: Mixin,
      OBSERVED_ERROR: {}
    };
    module.exports = Transaction;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/emptyObject", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var emptyObject = {};
    if (process.env.NODE_ENV !== 'production') {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/isNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }
  module.exports = isNode;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactComponentEnvironment", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var injected = false;
    var ReactComponentEnvironment = {
      unmountIDFromEnvironment: null,
      replaceNodeWithMarkupByID: null,
      processChildrenUpdates: null,
      injection: {injectEnvironment: function(environment) {
          !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
          ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
          ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
          ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
          injected = true;
        }}
    };
    module.exports = ReactComponentEnvironment;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactPropTypeLocations", ["npm:fbjs@0.1.0-alpha.4/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyMirror = require("npm:fbjs@0.1.0-alpha.4/lib/keyMirror");
  var ReactPropTypeLocations = keyMirror({
    prop: null,
    context: null,
    childContext: null
  });
  module.exports = ReactPropTypeLocations;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPropTypeLocationNames = {};
    if (process.env.NODE_ENV !== 'production') {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/shouldUpdateReactComponent", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function shouldUpdateReactComponent(prevElement, nextElement) {
    if (prevElement != null && nextElement != null) {
      var prevType = typeof prevElement;
      var nextType = typeof nextElement;
      if (prevType === 'string' || prevType === 'number') {
        return nextType === 'string' || nextType === 'number';
      } else {
        return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
      }
    }
    return false;
  }
  module.exports = shouldUpdateReactComponent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactNativeComponent", ["npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var autoGenerateWrapperClass = null;
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var textComponentClass = null;
    var ReactNativeComponentInjection = {
      injectGenericComponentClass: function(componentClass) {
        genericComponentClass = componentClass;
      },
      injectTextComponentClass: function(componentClass) {
        textComponentClass = componentClass;
      },
      injectComponentClasses: function(componentClasses) {
        assign(tagToComponentClass, componentClasses);
      }
    };
    function getComponentClassForElement(element) {
      if (typeof element.type === 'function') {
        return element.type;
      }
      var tag = element.type;
      var componentClass = tagToComponentClass[tag];
      if (componentClass == null) {
        tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
      }
      return componentClass;
    }
    function createInternalComponent(element) {
      !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
      return new genericComponentClass(element.type, element.props);
    }
    function createInstanceForText(text) {
      return new textComponentClass(text);
    }
    function isTextComponent(component) {
      return component instanceof textComponentClass;
    }
    var ReactNativeComponent = {
      getComponentClassForElement: getComponentClassForElement,
      createInternalComponent: createInternalComponent,
      createInstanceForText: createInstanceForText,
      isTextComponent: isTextComponent,
      injection: ReactNativeComponentInjection
    };
    module.exports = ReactNativeComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/validateDOMNesting", ["npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/emptyFunction", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var validateDOMNesting = emptyFunction;
    if (process.env.NODE_ENV !== 'production') {
      var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
      var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', 'foreignObject', 'desc', 'title'];
      var buttonScopeTags = inScopeTags.concat(['button']);
      var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
      var emptyAncestorInfo = {
        parentTag: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      var updatedAncestorInfo = function(oldInfo, tag, instance) {
        var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
        var info = {
          tag: tag,
          instance: instance
        };
        if (inScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.aTagInScope = null;
          ancestorInfo.buttonTagInScope = null;
          ancestorInfo.nobrTagInScope = null;
        }
        if (buttonScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.pTagInButtonScope = null;
        }
        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
          ancestorInfo.listItemTagAutoclosing = null;
          ancestorInfo.dlItemTagAutoclosing = null;
        }
        ancestorInfo.parentTag = info;
        if (tag === 'form') {
          ancestorInfo.formTag = info;
        }
        if (tag === 'a') {
          ancestorInfo.aTagInScope = info;
        }
        if (tag === 'button') {
          ancestorInfo.buttonTagInScope = info;
        }
        if (tag === 'nobr') {
          ancestorInfo.nobrTagInScope = info;
        }
        if (tag === 'p') {
          ancestorInfo.pTagInButtonScope = info;
        }
        if (tag === 'li') {
          ancestorInfo.listItemTagAutoclosing = info;
        }
        if (tag === 'dd' || tag === 'dt') {
          ancestorInfo.dlItemTagAutoclosing = info;
        }
        return ancestorInfo;
      };
      var isTagValidWithParent = function(tag, parentTag) {
        switch (parentTag) {
          case 'select':
            return tag === 'option' || tag === 'optgroup' || tag === '#text';
          case 'optgroup':
            return tag === 'option' || tag === '#text';
          case 'option':
            return tag === '#text';
          case 'tr':
            return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'tbody':
          case 'thead':
          case 'tfoot':
            return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'colgroup':
            return tag === 'col' || tag === 'template';
          case 'table':
            return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'head':
            return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'html':
            return tag === 'head' || tag === 'body';
        }
        switch (tag) {
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
          case 'rp':
          case 'rt':
            return impliedEndTags.indexOf(parentTag) === -1;
          case 'caption':
          case 'col':
          case 'colgroup':
          case 'frame':
          case 'head':
          case 'tbody':
          case 'td':
          case 'tfoot':
          case 'th':
          case 'thead':
          case 'tr':
            return parentTag == null;
        }
        return true;
      };
      var findInvalidAncestorForTag = function(tag, ancestorInfo) {
        switch (tag) {
          case 'address':
          case 'article':
          case 'aside':
          case 'blockquote':
          case 'center':
          case 'details':
          case 'dialog':
          case 'dir':
          case 'div':
          case 'dl':
          case 'fieldset':
          case 'figcaption':
          case 'figure':
          case 'footer':
          case 'header':
          case 'hgroup':
          case 'main':
          case 'menu':
          case 'nav':
          case 'ol':
          case 'p':
          case 'section':
          case 'summary':
          case 'ul':
          case 'pre':
          case 'listing':
          case 'table':
          case 'hr':
          case 'xmp':
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return ancestorInfo.pTagInButtonScope;
          case 'form':
            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
          case 'li':
            return ancestorInfo.listItemTagAutoclosing;
          case 'dd':
          case 'dt':
            return ancestorInfo.dlItemTagAutoclosing;
          case 'button':
            return ancestorInfo.buttonTagInScope;
          case 'a':
            return ancestorInfo.aTagInScope;
          case 'nobr':
            return ancestorInfo.nobrTagInScope;
        }
        return null;
      };
      var findOwnerStack = function(instance) {
        if (!instance) {
          return [];
        }
        var stack = [];
        do {
          stack.push(instance);
        } while (instance = instance._currentElement._owner);
        stack.reverse();
        return stack;
      };
      var didWarn = {};
      validateDOMNesting = function(childTag, childInstance, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.parentTag;
        var parentTag = parentInfo && parentInfo.tag;
        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        var problematic = invalidParent || invalidAncestor;
        if (problematic) {
          var ancestorTag = problematic.tag;
          var ancestorInstance = problematic.instance;
          var childOwner = childInstance && childInstance._currentElement._owner;
          var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
          var childOwners = findOwnerStack(childOwner);
          var ancestorOwners = findOwnerStack(ancestorOwner);
          var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
          var i;
          var deepestCommon = -1;
          for (i = 0; i < minStackLen; i++) {
            if (childOwners[i] === ancestorOwners[i]) {
              deepestCommon = i;
            } else {
              break;
            }
          }
          var UNKNOWN = '(unknown)';
          var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function(inst) {
            return inst.getName() || UNKNOWN;
          });
          var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function(inst) {
            return inst.getName() || UNKNOWN;
          });
          var ownerInfo = [].concat(deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag, invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
          var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
          if (didWarn[warnKey]) {
            return ;
          }
          didWarn[warnKey] = true;
          if (invalidParent) {
            var info = '';
            if (ancestorTag === 'table' && childTag === 'tr') {
              info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
            }
            process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
          }
        }
      };
      validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
      validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
      validateDOMNesting.isTagValidInContext = function(tag, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.parentTag;
        var parentTag = parentInfo && parentInfo.tag;
        return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
      };
    }
    module.exports = validateDOMNesting;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/findDOMNode", ["npm:react@0.14.0-beta3/lib/ReactCurrentOwner", "npm:react@0.14.0-beta3/lib/ReactInstanceMap", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = require("npm:react@0.14.0-beta3/lib/ReactCurrentOwner");
    var ReactInstanceMap = require("npm:react@0.14.0-beta3/lib/ReactInstanceMap");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function findDOMNode(componentOrElement) {
      if (process.env.NODE_ENV !== 'production') {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
          owner._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrElement == null) {
        return null;
      }
      if (componentOrElement.nodeType === 1) {
        return componentOrElement;
      }
      if (ReactInstanceMap.has(componentOrElement)) {
        return ReactMount.getNodeFromInstance(componentOrElement);
      }
      !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Component (with keys: %s) contains `render` method ' + 'but is not mounted in the DOM', Object.keys(componentOrElement)) : invariant(false) : undefined;
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
    }
    module.exports = findDOMNode;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/focusNode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function focusNode(node) {
    try {
      node.focus();
    } catch (e) {}
  }
  module.exports = focusNode;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMButton", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var mouseListenerNames = {
    onClick: true,
    onDoubleClick: true,
    onMouseDown: true,
    onMouseMove: true,
    onMouseUp: true,
    onClickCapture: true,
    onDoubleClickCapture: true,
    onMouseDownCapture: true,
    onMouseMoveCapture: true,
    onMouseUpCapture: true
  };
  var ReactDOMButton = {getNativeProps: function(inst, props, context) {
      if (!props.disabled) {
        return props;
      }
      var nativeProps = {};
      for (var key in props) {
        if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
          nativeProps[key] = props[key];
        }
      }
      return nativeProps;
    }};
  module.exports = ReactDOMButton;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactFragment", ["npm:react@0.14.0-beta3/lib/ReactElement", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var fragmentKey;
    var didWarnKey;
    var canWarnForReactFragment;
    if (process.env.NODE_ENV !== 'production') {
      fragmentKey = '_reactFragment';
      didWarnKey = '_reactDidWarn';
      try {
        var dummy = function() {
          return 1;
        };
        Object.defineProperty({}, fragmentKey, {
          enumerable: false,
          value: true
        });
        Object.defineProperty({}, 'key', {
          enumerable: true,
          get: dummy
        });
        canWarnForReactFragment = true;
      } catch (x) {
        canWarnForReactFragment = false;
      }
      var proxyPropertyAccessWithWarning = function(obj, key) {
        Object.defineProperty(obj, key, {
          enumerable: true,
          get: function() {
            process.env.NODE_ENV !== 'production' ? warning(this[didWarnKey], 'A ReactFragment is an opaque type. Accessing any of its ' + 'properties is deprecated. Pass it to one of the React.Children ' + 'helpers.') : undefined;
            this[didWarnKey] = true;
            return this[fragmentKey][key];
          },
          set: function(value) {
            process.env.NODE_ENV !== 'production' ? warning(this[didWarnKey], 'A ReactFragment is an immutable opaque type. Mutating its ' + 'properties is deprecated.') : undefined;
            this[didWarnKey] = true;
            this[fragmentKey][key] = value;
          }
        });
      };
      var issuedWarnings = {};
      var didWarnForFragment = function(fragment) {
        var fragmentCacheKey = '';
        for (var key in fragment) {
          fragmentCacheKey += key + ':' + typeof fragment[key] + ',';
        }
        var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];
        issuedWarnings[fragmentCacheKey] = true;
        return alreadyWarnedOnce;
      };
    }
    var ReactFragment = {
      create: function(object) {
        if (process.env.NODE_ENV !== 'production') {
          if (typeof object !== 'object' || !object || Array.isArray(object)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment only accepts a single object. Got: %s', object) : undefined;
            return object;
          }
          if (ReactElement.isValidElement(object)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : undefined;
            return object;
          }
          if (canWarnForReactFragment) {
            var proxy = {};
            Object.defineProperty(proxy, fragmentKey, {
              enumerable: false,
              value: object
            });
            Object.defineProperty(proxy, didWarnKey, {
              writable: true,
              enumerable: false,
              value: false
            });
            for (var key in object) {
              proxyPropertyAccessWithWarning(proxy, key);
            }
            Object.preventExtensions(proxy);
            return proxy;
          }
        }
        return object;
      },
      extract: function(fragment) {
        if (process.env.NODE_ENV !== 'production') {
          if (canWarnForReactFragment) {
            if (!fragment[fragmentKey]) {
              process.env.NODE_ENV !== 'production' ? warning(didWarnForFragment(fragment), 'Any use of a keyed object should be wrapped in ' + 'React.addons.createFragment(object) before being passed as a ' + 'child.') : undefined;
              return fragment;
            }
            return fragment[fragmentKey];
          }
        }
        return fragment;
      },
      extractIfFragment: function(fragment) {
        if (process.env.NODE_ENV !== 'production') {
          if (canWarnForReactFragment) {
            if (fragment[fragmentKey]) {
              return fragment[fragmentKey];
            }
            for (var key in fragment) {
              if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key])) {
                return ReactFragment.extract(fragment);
              }
            }
          }
        }
        return fragment;
      }
    };
    module.exports = ReactFragment;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/getIteratorFn", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }
  module.exports = getIteratorFn;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/traverseAllChildren", ["npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactFragment", "npm:react@0.14.0-beta3/lib/ReactInstanceHandles", "npm:react@0.14.0-beta3/lib/getIteratorFn", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactFragment = require("npm:react@0.14.0-beta3/lib/ReactFragment");
    var ReactInstanceHandles = require("npm:react@0.14.0-beta3/lib/ReactInstanceHandles");
    var getIteratorFn = require("npm:react@0.14.0-beta3/lib/getIteratorFn");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var SUBSEPARATOR = ':';
    var userProvidedKeyEscaperLookup = {
      '=': '=0',
      '.': '=1',
      ':': '=2'
    };
    var userProvidedKeyEscapeRegex = /[=.:]/g;
    var didWarnAboutMaps = false;
    function userProvidedKeyEscaper(match) {
      return userProvidedKeyEscaperLookup[match];
    }
    function getComponentKey(component, index) {
      if (component && component.key != null) {
        return wrapUserProvidedKey(component.key);
      }
      return index.toString(36);
    }
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
    }
    function wrapUserProvidedKey(key) {
      return '$' + escapeUserProvidedKey(key);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;
      if (type === 'undefined' || type === 'boolean') {
        children = null;
      }
      if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
        callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix = nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            if (process.env.NODE_ENV !== 'production') {
              process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            }
          }
        } else if (type === 'object') {
          !(children.nodeType !== 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(false) : undefined;
          var fragment = ReactFragment.extract(children);
          for (var key in fragment) {
            if (fragment.hasOwnProperty(key)) {
              child = fragment[key];
              nextName = nextNamePrefix + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(child, 0);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          }
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMSelect", ["npm:react@0.14.0-beta3/lib/LinkedValueUtils", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var LinkedValueUtils = require("npm:react@0.14.0-beta3/lib/LinkedValueUtils");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
    function updateOptionsIfPendingUpdateAndMounted() {
      if (this._wrapperState.pendingUpdate && this._rootNodeID) {
        this._wrapperState.pendingUpdate = false;
        var props = this._currentElement.props;
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          updateOptions(this, props, value);
        }
      }
    }
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var valuePropNames = ['value', 'defaultValue'];
    function checkSelectPropTypes(inst, props) {
      var owner = inst._currentElement._owner;
      LinkedValueUtils.checkPropTypes('select', props, owner);
      for (var i = 0; i < valuePropNames.length; i++) {
        var propName = valuePropNames[i];
        if (props[propName] == null) {
          continue;
        }
        if (props.multiple) {
          process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
        } else {
          process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
        }
      }
    }
    function updateOptions(inst, multiple, propValue) {
      var selectedValue,
          i;
      var options = ReactMount.getNode(inst._rootNodeID).options;
      if (multiple) {
        selectedValue = {};
        for (i = 0; i < propValue.length; i++) {
          selectedValue['' + propValue[i]] = true;
        }
        for (i = 0; i < options.length; i++) {
          var selected = selectedValue.hasOwnProperty(options[i].value);
          if (options[i].selected !== selected) {
            options[i].selected = selected;
          }
        }
      } else {
        selectedValue = '' + propValue;
        for (i = 0; i < options.length; i++) {
          if (options[i].value === selectedValue) {
            options[i].selected = true;
            return ;
          }
        }
        if (options.length) {
          options[0].selected = true;
        }
      }
    }
    var ReactDOMSelect = {
      valueContextKey: valueContextKey,
      getNativeProps: function(inst, props, context) {
        return assign({}, props, {
          onChange: inst._wrapperState.onChange,
          value: undefined
        });
      },
      mountWrapper: function(inst, props) {
        if (process.env.NODE_ENV !== 'production') {
          checkSelectPropTypes(inst, props);
        }
        var value = LinkedValueUtils.getValue(props);
        inst._wrapperState = {
          pendingUpdate: false,
          initialValue: value != null ? value : props.defaultValue,
          onChange: _handleChange.bind(inst),
          wasMultiple: Boolean(props.multiple)
        };
      },
      processChildContext: function(inst, props, context) {
        var childContext = assign({}, context);
        childContext[valueContextKey] = inst._wrapperState.initialValue;
        return childContext;
      },
      postUpdateWrapper: function(inst) {
        var props = inst._currentElement.props;
        inst._wrapperState.initialValue = undefined;
        var wasMultiple = inst._wrapperState.wasMultiple;
        inst._wrapperState.wasMultiple = Boolean(props.multiple);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          inst._wrapperState.pendingUpdate = false;
          updateOptions(inst, Boolean(props.multiple), value);
        } else if (wasMultiple !== Boolean(props.multiple)) {
          if (props.defaultValue != null) {
            updateOptions(inst, Boolean(props.multiple), props.defaultValue);
          } else {
            updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
          }
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      this._wrapperState.pendingUpdate = true;
      ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMSelect;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMTextarea", ["npm:react@0.14.0-beta3/lib/LinkedValueUtils", "npm:react@0.14.0-beta3/lib/ReactDOMIDOperations", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var LinkedValueUtils = require("npm:react@0.14.0-beta3/lib/LinkedValueUtils");
    var ReactDOMIDOperations = require("npm:react@0.14.0-beta3/lib/ReactDOMIDOperations");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMTextarea.updateWrapper(this);
      }
    }
    var ReactDOMTextarea = {
      getNativeProps: function(inst, props, context) {
        !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
        var nativeProps = assign({}, props, {
          defaultValue: undefined,
          value: undefined,
          children: inst._wrapperState.initialValue,
          onChange: inst._wrapperState.onChange
        });
        return nativeProps;
      },
      mountWrapper: function(inst, props) {
        LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
        var defaultValue = props.defaultValue;
        var children = props.children;
        if (children != null) {
          if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
          }
          !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
          if (Array.isArray(children)) {
            !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
            children = children[0];
          }
          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        var value = LinkedValueUtils.getValue(props);
        inst._wrapperState = {
          initialValue: '' + (value != null ? value : defaultValue),
          onChange: _handleChange.bind(inst)
        };
      },
      updateWrapper: function(inst) {
        var props = inst._currentElement.props;
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMTextarea;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/flattenChildren", ["npm:react@0.14.0-beta3/lib/traverseAllChildren", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var traverseAllChildren = require("npm:react@0.14.0-beta3/lib/traverseAllChildren");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function flattenSingleChildIntoContext(traverseContext, child, name) {
      var result = traverseContext;
      var keyUnique = result[name] === undefined;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
      }
      if (keyUnique && child != null) {
        result[name] = child;
      }
    }
    function flattenChildren(children) {
      if (children == null) {
        return children;
      }
      var result = {};
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
      return result;
    }
    module.exports = flattenChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/keyOf", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var keyOf = function(oneKeyObj) {
    var key;
    for (key in oneKeyObj) {
      if (!oneKeyObj.hasOwnProperty(key)) {
        continue;
      }
      return key;
    }
    return null;
  };
  module.exports = keyOf;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/shallowEqual", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var bHasOwnProperty = hasOwnProperty.bind(objB);
    for (var i = 0; i < keysA.length; i++) {
      if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
        return false;
      }
    }
    return true;
  }
  module.exports = shallowEqual;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/EventPropagators", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:react@0.14.0-beta3/lib/EventPluginHub", "npm:fbjs@0.1.0-alpha.4/lib/warning", "npm:react@0.14.0-beta3/lib/accumulateInto", "npm:react@0.14.0-beta3/lib/forEachAccumulated", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.14.0-beta3/lib/EventPluginHub");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var accumulateInto = require("npm:react@0.14.0-beta3/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.14.0-beta3/lib/forEachAccumulated");
    var PropagationPhases = EventConstants.PropagationPhases;
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(id, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(id, registrationName);
    }
    function accumulateDirectionalDispatches(domID, upwards, event) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
      }
      var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
      var listener = listenerAtPhase(domID, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(id, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(id, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event.dispatchMarker, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateTwoPhaseDispatchesSkipTarget(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }
    function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
      EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/getTextContentAccessor", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
  var contentKey = null;
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }
  module.exports = getTextContentAccessor;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticEvent", ["npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
  var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
  var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
  var EventInterface = {
    path: null,
    type: null,
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    this.dispatchConfig = dispatchConfig;
    this.dispatchMarker = dispatchMarker;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = nativeEventTarget;
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  }
  assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      if (event.preventDefault) {
        event.preventDefault();
      } else {
        event.returnValue = false;
      }
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      if (event.stopPropagation) {
        event.stopPropagation();
      } else {
        event.cancelBubble = true;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },
    persist: function() {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },
    isPersistent: emptyFunction.thatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        this[propName] = null;
      }
      this.dispatchConfig = null;
      this.dispatchMarker = null;
      this.nativeEvent = null;
    }
  });
  SyntheticEvent.Interface = EventInterface;
  SyntheticEvent.augmentClass = function(Class, Interface) {
    var Super = this;
    var prototype = Object.create(Super.prototype);
    assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;
    PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
  };
  PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
  module.exports = SyntheticEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticInputEvent", ["npm:react@0.14.0-beta3/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("npm:react@0.14.0-beta3/lib/SyntheticEvent");
  var InputEventInterface = {data: null};
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/isTextInputElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
  }
  module.exports = isTextInputElement;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ClientReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var nextReactRootIndex = 0;
  var ClientReactRootIndex = {createReactRootIndex: function() {
      return nextReactRootIndex++;
    }};
  module.exports = ClientReactRootIndex;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/DefaultEventPluginOrder", ["npm:fbjs@0.1.0-alpha.4/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
  var DefaultEventPluginOrder = [keyOf({ResponderEventPlugin: null}), keyOf({SimpleEventPlugin: null}), keyOf({TapEventPlugin: null}), keyOf({EnterLeaveEventPlugin: null}), keyOf({ChangeEventPlugin: null}), keyOf({SelectEventPlugin: null}), keyOf({BeforeInputEventPlugin: null})];
  module.exports = DefaultEventPluginOrder;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/getEventTarget", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;
    return target.nodeType === 3 ? target.parentNode : target;
  }
  module.exports = getEventTarget;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/getEventModifierState", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }
  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }
  module.exports = getEventModifierState;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/HTMLDOMPropertyConfig", ["npm:react@0.14.0-beta3/lib/DOMProperty", "npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("npm:react@0.14.0-beta3/lib/DOMProperty");
  var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var hasSVG;
  if (ExecutionEnvironment.canUseDOM) {
    var implementation = document.implementation;
    hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
  }
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
    Properties: {
      accept: null,
      acceptCharset: null,
      accessKey: null,
      action: null,
      allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      allowTransparency: MUST_USE_ATTRIBUTE,
      alt: null,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: null,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      cellPadding: null,
      cellSpacing: null,
      charSet: MUST_USE_ATTRIBUTE,
      challenge: MUST_USE_ATTRIBUTE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      classID: MUST_USE_ATTRIBUTE,
      className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
      cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: null,
      content: null,
      contentEditable: null,
      contextMenu: MUST_USE_ATTRIBUTE,
      controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      coords: null,
      crossOrigin: null,
      data: null,
      dateTime: MUST_USE_ATTRIBUTE,
      defer: HAS_BOOLEAN_VALUE,
      dir: null,
      disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: null,
      encType: null,
      form: MUST_USE_ATTRIBUTE,
      formAction: MUST_USE_ATTRIBUTE,
      formEncType: MUST_USE_ATTRIBUTE,
      formMethod: MUST_USE_ATTRIBUTE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: MUST_USE_ATTRIBUTE,
      frameBorder: MUST_USE_ATTRIBUTE,
      headers: null,
      height: MUST_USE_ATTRIBUTE,
      hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      high: null,
      href: null,
      hrefLang: null,
      htmlFor: null,
      httpEquiv: null,
      icon: null,
      id: MUST_USE_PROPERTY,
      inputMode: MUST_USE_ATTRIBUTE,
      is: MUST_USE_ATTRIBUTE,
      keyParams: MUST_USE_ATTRIBUTE,
      keyType: MUST_USE_ATTRIBUTE,
      label: null,
      lang: null,
      list: MUST_USE_ATTRIBUTE,
      loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      low: null,
      manifest: MUST_USE_ATTRIBUTE,
      marginHeight: null,
      marginWidth: null,
      max: null,
      maxLength: MUST_USE_ATTRIBUTE,
      media: MUST_USE_ATTRIBUTE,
      mediaGroup: null,
      method: null,
      min: null,
      minLength: MUST_USE_ATTRIBUTE,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: null,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: null,
      pattern: null,
      placeholder: null,
      poster: null,
      preload: null,
      radioGroup: null,
      readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      rel: null,
      required: HAS_BOOLEAN_VALUE,
      role: MUST_USE_ATTRIBUTE,
      rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: null,
      sandbox: null,
      scope: null,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: null,
      seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: null,
      size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
      sizes: MUST_USE_ATTRIBUTE,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: null,
      src: null,
      srcDoc: MUST_USE_PROPERTY,
      srcSet: MUST_USE_ATTRIBUTE,
      start: HAS_NUMERIC_VALUE,
      step: null,
      style: null,
      tabIndex: null,
      target: null,
      title: null,
      type: null,
      useMap: null,
      value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
      width: MUST_USE_ATTRIBUTE,
      wmode: MUST_USE_ATTRIBUTE,
      wrap: null,
      autoCapitalize: null,
      autoCorrect: null,
      itemProp: MUST_USE_ATTRIBUTE,
      itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
      itemType: MUST_USE_ATTRIBUTE,
      itemID: MUST_USE_ATTRIBUTE,
      itemRef: MUST_USE_ATTRIBUTE,
      property: null,
      security: MUST_USE_ATTRIBUTE,
      unselectable: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {
      autoCapitalize: 'autocapitalize',
      autoComplete: 'autocomplete',
      autoCorrect: 'autocorrect',
      autoFocus: 'autofocus',
      autoPlay: 'autoplay',
      encType: 'encoding',
      hrefLang: 'hreflang',
      radioGroup: 'radiogroup',
      spellCheck: 'spellcheck',
      srcDoc: 'srcdoc',
      srcSet: 'srcset'
    }
  };
  module.exports = HTMLDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactBrowserComponentMixin", ["npm:react@0.14.0-beta3/lib/ReactInstanceMap", "npm:react@0.14.0-beta3/lib/findDOMNode", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactInstanceMap = require("npm:react@0.14.0-beta3/lib/ReactInstanceMap");
    var findDOMNode = require("npm:react@0.14.0-beta3/lib/findDOMNode");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var didWarnKey = '_getDOMNodeDidWarn';
    var ReactBrowserComponentMixin = {getDOMNode: function() {
        process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'React.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
        this.constructor[didWarnKey] = true;
        return findDOMNode(this);
      }};
    module.exports = ReactBrowserComponentMixin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDefaultBatchingStrategy", ["npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/Transaction", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
  var Transaction = require("npm:react@0.14.0-beta3/lib/Transaction");
  var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
  var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function() {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }});
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback, a, b, c, d, e) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        callback(a, b, c, d, e);
      } else {
        transaction.perform(callback, null, a, b, c, d, e);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/EventListener", ["npm:fbjs@0.1.0-alpha.4/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
    var EventListener = {
      listen: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return {remove: function() {
              target.removeEventListener(eventType, callback, false);
            }};
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return {remove: function() {
              target.detachEvent('on' + eventType, callback);
            }};
        }
      },
      capture: function(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, true);
          return {remove: function() {
              target.removeEventListener(eventType, callback, true);
            }};
        } else {
          if (process.env.NODE_ENV !== 'production') {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return {remove: emptyFunction};
        }
      },
      registerDefault: function() {}
    };
    module.exports = EventListener;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/getUnboundedScrollPosition", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }
  module.exports = getUnboundedScrollPosition;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactNoopUpdateQueue", ["npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function warnTDZ(publicInstance, callerName) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
      }
    }
    var ReactNoopUpdateQueue = {
      isMounted: function(publicInstance) {
        return false;
      },
      enqueueCallback: function(publicInstance, callback) {},
      enqueueForceUpdate: function(publicInstance) {
        warnTDZ(publicInstance, 'forceUpdate');
      },
      enqueueReplaceState: function(publicInstance, completeState) {
        warnTDZ(publicInstance, 'replaceState');
      },
      enqueueSetState: function(publicInstance, partialState) {
        warnTDZ(publicInstance, 'setState');
      },
      enqueueSetProps: function(publicInstance, partialProps) {
        warnTDZ(publicInstance, 'setProps');
      },
      enqueueReplaceProps: function(publicInstance, props) {
        warnTDZ(publicInstance, 'replaceProps');
      }
    };
    module.exports = ReactNoopUpdateQueue;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactErrorUtils", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactErrorUtils = {guard: function(func, name) {
      return func;
    }};
  module.exports = ReactErrorUtils;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/getNodeForCharacterOffset", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;
    while (node) {
      if (node.nodeType === 3) {
        nodeEnd = nodeStart + node.textContent.length;
        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }
        nodeStart = nodeEnd;
      }
      node = getLeafNode(getSiblingNode(node));
    }
  }
  module.exports = getNodeForCharacterOffset;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/getActiveElement", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function getActiveElement() {
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }
  module.exports = getActiveElement;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SelectEventPlugin", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:react@0.14.0-beta3/lib/EventPropagators", "npm:react@0.14.0-beta3/lib/ReactInputSelection", "npm:react@0.14.0-beta3/lib/SyntheticEvent", "npm:fbjs@0.1.0-alpha.4/lib/getActiveElement", "npm:react@0.14.0-beta3/lib/isTextInputElement", "npm:fbjs@0.1.0-alpha.4/lib/keyOf", "npm:fbjs@0.1.0-alpha.4/lib/shallowEqual"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
  var EventPropagators = require("npm:react@0.14.0-beta3/lib/EventPropagators");
  var ReactInputSelection = require("npm:react@0.14.0-beta3/lib/ReactInputSelection");
  var SyntheticEvent = require("npm:react@0.14.0-beta3/lib/SyntheticEvent");
  var getActiveElement = require("npm:fbjs@0.1.0-alpha.4/lib/getActiveElement");
  var isTextInputElement = require("npm:react@0.14.0-beta3/lib/isTextInputElement");
  var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
  var shallowEqual = require("npm:fbjs@0.1.0-alpha.4/lib/shallowEqual");
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {select: {
      phasedRegistrationNames: {
        bubbled: keyOf({onSelect: null}),
        captured: keyOf({onSelectCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
    }};
  var activeElement = null;
  var activeElementID = null;
  var lastSelection = null;
  var mouseDown = false;
  var hasListener = false;
  var ON_SELECT_KEY = keyOf({onSelect: null});
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
      return null;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
    return null;
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      if (!hasListener) {
        return null;
      }
      switch (topLevelType) {
        case topLevelTypes.topFocus:
          if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
            activeElement = topLevelTarget;
            activeElementID = topLevelTargetID;
            lastSelection = null;
          }
          break;
        case topLevelTypes.topBlur:
          activeElement = null;
          activeElementID = null;
          lastSelection = null;
          break;
        case topLevelTypes.topMouseDown:
          mouseDown = true;
          break;
        case topLevelTypes.topContextMenu:
        case topLevelTypes.topMouseUp:
          mouseDown = false;
          return constructSelectEvent(nativeEvent, nativeEventTarget);
        case topLevelTypes.topSelectionChange:
        case topLevelTypes.topKeyDown:
        case topLevelTypes.topKeyUp:
          return constructSelectEvent(nativeEvent, nativeEventTarget);
      }
      return null;
    },
    didPutListener: function(id, registrationName, listener) {
      if (registrationName === ON_SELECT_KEY) {
        hasListener = true;
      }
    }
  };
  module.exports = SelectEventPlugin;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ServerReactRootIndex", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
  var ServerReactRootIndex = {createReactRootIndex: function() {
      return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
    }};
  module.exports = ServerReactRootIndex;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticClipboardEvent", ["npm:react@0.14.0-beta3/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("npm:react@0.14.0-beta3/lib/SyntheticEvent");
  var ClipboardEventInterface = {clipboardData: function(event) {
      return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
    }};
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticFocusEvent", ["npm:react@0.14.0-beta3/lib/SyntheticUIEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("npm:react@0.14.0-beta3/lib/SyntheticUIEvent");
  var FocusEventInterface = {relatedTarget: null};
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/getEventCharCode", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;
    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      charCode = keyCode;
    }
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }
    return 0;
  }
  module.exports = getEventCharCode;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/getEventKey", ["npm:react@0.14.0-beta3/lib/getEventCharCode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var getEventCharCode = require("npm:react@0.14.0-beta3/lib/getEventCharCode");
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticDragEvent", ["npm:react@0.14.0-beta3/lib/SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticMouseEvent = require("npm:react@0.14.0-beta3/lib/SyntheticMouseEvent");
  var DragEventInterface = {dataTransfer: null};
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticTouchEvent", ["npm:react@0.14.0-beta3/lib/SyntheticUIEvent", "npm:react@0.14.0-beta3/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("npm:react@0.14.0-beta3/lib/SyntheticUIEvent");
  var getEventModifierState = require("npm:react@0.14.0-beta3/lib/getEventModifierState");
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticWheelEvent", ["npm:react@0.14.0-beta3/lib/SyntheticMouseEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticMouseEvent = require("npm:react@0.14.0-beta3/lib/SyntheticMouseEvent");
  var WheelEventInterface = {
    deltaX: function(event) {
      return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function(event) {
      return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SVGDOMPropertyConfig", ["npm:react@0.14.0-beta3/lib/DOMProperty"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("npm:react@0.14.0-beta3/lib/DOMProperty");
  var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
  var NS = {
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };
  var SVGDOMPropertyConfig = {
    Properties: {
      clipPath: MUST_USE_ATTRIBUTE,
      cx: MUST_USE_ATTRIBUTE,
      cy: MUST_USE_ATTRIBUTE,
      d: MUST_USE_ATTRIBUTE,
      dx: MUST_USE_ATTRIBUTE,
      dy: MUST_USE_ATTRIBUTE,
      fill: MUST_USE_ATTRIBUTE,
      fillOpacity: MUST_USE_ATTRIBUTE,
      fontFamily: MUST_USE_ATTRIBUTE,
      fontSize: MUST_USE_ATTRIBUTE,
      fx: MUST_USE_ATTRIBUTE,
      fy: MUST_USE_ATTRIBUTE,
      gradientTransform: MUST_USE_ATTRIBUTE,
      gradientUnits: MUST_USE_ATTRIBUTE,
      markerEnd: MUST_USE_ATTRIBUTE,
      markerMid: MUST_USE_ATTRIBUTE,
      markerStart: MUST_USE_ATTRIBUTE,
      offset: MUST_USE_ATTRIBUTE,
      opacity: MUST_USE_ATTRIBUTE,
      patternContentUnits: MUST_USE_ATTRIBUTE,
      patternUnits: MUST_USE_ATTRIBUTE,
      points: MUST_USE_ATTRIBUTE,
      preserveAspectRatio: MUST_USE_ATTRIBUTE,
      r: MUST_USE_ATTRIBUTE,
      rx: MUST_USE_ATTRIBUTE,
      ry: MUST_USE_ATTRIBUTE,
      spreadMethod: MUST_USE_ATTRIBUTE,
      stopColor: MUST_USE_ATTRIBUTE,
      stopOpacity: MUST_USE_ATTRIBUTE,
      stroke: MUST_USE_ATTRIBUTE,
      strokeDasharray: MUST_USE_ATTRIBUTE,
      strokeLinecap: MUST_USE_ATTRIBUTE,
      strokeOpacity: MUST_USE_ATTRIBUTE,
      strokeWidth: MUST_USE_ATTRIBUTE,
      textAnchor: MUST_USE_ATTRIBUTE,
      transform: MUST_USE_ATTRIBUTE,
      version: MUST_USE_ATTRIBUTE,
      viewBox: MUST_USE_ATTRIBUTE,
      x1: MUST_USE_ATTRIBUTE,
      x2: MUST_USE_ATTRIBUTE,
      x: MUST_USE_ATTRIBUTE,
      xlinkActuate: MUST_USE_ATTRIBUTE,
      xlinkArcrole: MUST_USE_ATTRIBUTE,
      xlinkHref: MUST_USE_ATTRIBUTE,
      xlinkRole: MUST_USE_ATTRIBUTE,
      xlinkShow: MUST_USE_ATTRIBUTE,
      xlinkTitle: MUST_USE_ATTRIBUTE,
      xlinkType: MUST_USE_ATTRIBUTE,
      xmlBase: MUST_USE_ATTRIBUTE,
      xmlLang: MUST_USE_ATTRIBUTE,
      xmlSpace: MUST_USE_ATTRIBUTE,
      y1: MUST_USE_ATTRIBUTE,
      y2: MUST_USE_ATTRIBUTE,
      y: MUST_USE_ATTRIBUTE
    },
    DOMAttributeNamespaces: {
      xlinkActuate: NS.xlink,
      xlinkArcrole: NS.xlink,
      xlinkHref: NS.xlink,
      xlinkRole: NS.xlink,
      xlinkShow: NS.xlink,
      xlinkTitle: NS.xlink,
      xlinkType: NS.xlink,
      xmlBase: NS.xml,
      xmlLang: NS.xml,
      xmlSpace: NS.xml
    },
    DOMAttributeNames: {
      clipPath: 'clip-path',
      fillOpacity: 'fill-opacity',
      fontFamily: 'font-family',
      fontSize: 'font-size',
      gradientTransform: 'gradientTransform',
      gradientUnits: 'gradientUnits',
      markerEnd: 'marker-end',
      markerMid: 'marker-mid',
      markerStart: 'marker-start',
      patternContentUnits: 'patternContentUnits',
      patternUnits: 'patternUnits',
      preserveAspectRatio: 'preserveAspectRatio',
      spreadMethod: 'spreadMethod',
      stopColor: 'stop-color',
      stopOpacity: 'stop-opacity',
      strokeDasharray: 'stroke-dasharray',
      strokeLinecap: 'stroke-linecap',
      strokeOpacity: 'stroke-opacity',
      strokeWidth: 'stroke-width',
      textAnchor: 'text-anchor',
      viewBox: 'viewBox',
      xlinkActuate: 'xlink:actuate',
      xlinkArcrole: 'xlink:arcrole',
      xlinkHref: 'xlink:href',
      xlinkRole: 'xlink:role',
      xlinkShow: 'xlink:show',
      xlinkTitle: 'xlink:title',
      xlinkType: 'xlink:type',
      xmlBase: 'xml:base',
      xmlLang: 'xml:lang',
      xmlSpace: 'xml:space'
    }
  };
  module.exports = SVGDOMPropertyConfig;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDefaultPerfAnalysis", ["npm:react@0.14.0-beta3/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
  var DONT_CARE_THRESHOLD = 1.2;
  var DOM_OPERATION_TYPES = {
    '_mountImageIntoNode': 'set innerHTML',
    INSERT_MARKUP: 'set innerHTML',
    MOVE_EXISTING: 'move',
    REMOVE_NODE: 'remove',
    SET_MARKUP: 'set innerHTML',
    TEXT_CONTENT: 'set textContent',
    'updatePropertyByID': 'update attribute',
    'deletePropertyByID': 'delete attribute',
    'updateStylesByID': 'update styles',
    'dangerouslyReplaceNodeWithMarkupByID': 'replace'
  };
  function getTotalTime(measurements) {
    var totalTime = 0;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      totalTime += measurement.totalTime;
    }
    return totalTime;
  }
  function getDOMSummary(measurements) {
    var items = [];
    measurements.forEach(function(measurement) {
      Object.keys(measurement.writes).forEach(function(id) {
        measurement.writes[id].forEach(function(write) {
          items.push({
            id: id,
            type: DOM_OPERATION_TYPES[write.type] || write.type,
            args: write.args
          });
        });
      });
    });
    return items;
  }
  function getExclusiveSummary(measurements) {
    var candidates = {};
    var displayName;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      for (var id in allIDs) {
        displayName = measurement.displayNames[id].current;
        candidates[displayName] = candidates[displayName] || {
          componentName: displayName,
          inclusive: 0,
          exclusive: 0,
          render: 0,
          count: 0
        };
        if (measurement.render[id]) {
          candidates[displayName].render += measurement.render[id];
        }
        if (measurement.exclusive[id]) {
          candidates[displayName].exclusive += measurement.exclusive[id];
        }
        if (measurement.inclusive[id]) {
          candidates[displayName].inclusive += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[displayName].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (displayName in candidates) {
      if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[displayName]);
      }
    }
    arr.sort(function(a, b) {
      return b.exclusive - a.exclusive;
    });
    return arr;
  }
  function getInclusiveSummary(measurements, onlyClean) {
    var candidates = {};
    var inclusiveKey;
    for (var i = 0; i < measurements.length; i++) {
      var measurement = measurements[i];
      var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
      var cleanComponents;
      if (onlyClean) {
        cleanComponents = getUnchangedComponents(measurement);
      }
      for (var id in allIDs) {
        if (onlyClean && !cleanComponents[id]) {
          continue;
        }
        var displayName = measurement.displayNames[id];
        inclusiveKey = displayName.owner + ' > ' + displayName.current;
        candidates[inclusiveKey] = candidates[inclusiveKey] || {
          componentName: inclusiveKey,
          time: 0,
          count: 0
        };
        if (measurement.inclusive[id]) {
          candidates[inclusiveKey].time += measurement.inclusive[id];
        }
        if (measurement.counts[id]) {
          candidates[inclusiveKey].count += measurement.counts[id];
        }
      }
    }
    var arr = [];
    for (inclusiveKey in candidates) {
      if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
        arr.push(candidates[inclusiveKey]);
      }
    }
    arr.sort(function(a, b) {
      return b.time - a.time;
    });
    return arr;
  }
  function getUnchangedComponents(measurement) {
    var cleanComponents = {};
    var dirtyLeafIDs = Object.keys(measurement.writes);
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    for (var id in allIDs) {
      var isDirty = false;
      for (var i = 0; i < dirtyLeafIDs.length; i++) {
        if (dirtyLeafIDs[i].indexOf(id) === 0) {
          isDirty = true;
          break;
        }
      }
      if (!isDirty && measurement.counts[id] > 0) {
        cleanComponents[id] = true;
      }
    }
    return cleanComponents;
  }
  var ReactDefaultPerfAnalysis = {
    getExclusiveSummary: getExclusiveSummary,
    getInclusiveSummary: getInclusiveSummary,
    getDOMSummary: getDOMSummary,
    getTotalTime: getTotalTime
  };
  module.exports = ReactDefaultPerfAnalysis;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/performance", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/renderSubtreeIntoContainer", ["npm:react@0.14.0-beta3/lib/ReactMount"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
  module.exports = ReactMount.renderSubtreeIntoContainer;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactServerBatchingStrategy", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactServerBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function(callback) {}
  };
  module.exports = ReactServerBatchingStrategy;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactServerRenderingTransaction", ["npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/CallbackQueue", "npm:react@0.14.0-beta3/lib/Transaction", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/emptyFunction"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
  var CallbackQueue = require("npm:react@0.14.0-beta3/lib/CallbackQueue");
  var Transaction = require("npm:react@0.14.0-beta3/lib/Transaction");
  var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
  var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: emptyFunction
  };
  var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.reactMountReady = CallbackQueue.getPooled(null);
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
    }
  };
  assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactServerRenderingTransaction);
  module.exports = ReactServerRenderingTransaction;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactElementValidator", ["npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactFragment", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocations", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames", "npm:react@0.14.0-beta3/lib/ReactCurrentOwner", "npm:react@0.14.0-beta3/lib/getIteratorFn", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactFragment = require("npm:react@0.14.0-beta3/lib/ReactFragment");
    var ReactPropTypeLocations = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocations");
    var ReactPropTypeLocationNames = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames");
    var ReactCurrentOwner = require("npm:react@0.14.0-beta3/lib/ReactCurrentOwner");
    var getIteratorFn = require("npm:react@0.14.0-beta3/lib/getIteratorFn");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = ReactCurrentOwner.current.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var ownerHasKeyUseWarning = {};
    var loggedTypeFailures = {};
    var NUMERIC_PROPERTY_REGEX = /^\d+$/;
    function getName(instance) {
      var publicInstance = instance && instance.getPublicInstance();
      if (!publicInstance) {
        return undefined;
      }
      var constructor = publicInstance.constructor;
      if (!constructor) {
        return undefined;
      }
      return constructor.displayName || constructor.name || undefined;
    }
    function getCurrentOwnerDisplayName() {
      var current = ReactCurrentOwner.current;
      return current && getName(current) || undefined;
    }
    function validateExplicitKey(element, parentType) {
      if (element._store.validated || element.key != null) {
        return ;
      }
      element._store.validated = true;
      var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
      if (addenda === null) {
        return ;
      }
      process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
    }
    function validatePropertyKey(name, element, parentType) {
      if (!NUMERIC_PROPERTY_REGEX.test(name)) {
        return ;
      }
      var addenda = getAddendaForKeyUse('numericKeys', element, parentType);
      if (addenda === null) {
        return ;
      }
      process.env.NODE_ENV !== 'production' ? warning(false, 'Child objects should have non-numeric keys so ordering is preserved.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
    }
    function getAddendaForKeyUse(messageType, element, parentType) {
      var ownerName = getCurrentOwnerDisplayName();
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
      var useName = ownerName || parentName;
      var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
      if (memoizer[useName]) {
        return null;
      }
      memoizer[useName] = true;
      var addenda = {
        parentOrOwner: ownerName ? ' Check the render method of ' + ownerName + '.' : parentName ? ' Check the React.render call using <' + parentName + '>.' : null,
        url: ' See https://fb.me/react-warning-keys for more information.',
        childOwner: null
      };
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        addenda.childOwner = ' It was passed a child from ' + getName(element._owner) + '.';
      }
      return addenda;
    }
    function validateChildKeys(node, parentType) {
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(node)) {
        node._store.validated = true;
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (iteratorFn) {
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (ReactElement.isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        } else if (typeof node === 'object') {
          var fragment = ReactFragment.extractIfFragment(node);
          for (var key in fragment) {
            if (fragment.hasOwnProperty(key)) {
              validatePropertyKey(key, fragment[key], parentType);
            }
          }
        }
      }
    }
    function checkPropTypes(componentName, propTypes, props, location) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error;
          try {
            !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
            error = propTypes[propName](props, propName, componentName, location);
          } catch (ex) {
            error = ex;
          }
          process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum();
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return ;
      }
      var name = componentClass.displayName || componentClass.name;
      if (componentClass.propTypes) {
        checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
      }
    }
    var ReactElementValidator = {
      createElement: function(type, props, children) {
        process.env.NODE_ENV !== 'production' ? warning(typeof type === 'string' || typeof type === 'function', 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
        validatePropTypes(element);
        return element;
      },
      createFactory: function(type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        if (process.env.NODE_ENV !== 'production') {
          try {
            Object.defineProperty(validatedFactory, 'type', {
              enumerable: false,
              get: function() {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
                Object.defineProperty(this, 'type', {value: type});
                return type;
              }
            });
          } catch (x) {}
        }
        return validatedFactory;
      },
      cloneElement: function(element, props, children) {
        var newElement = ReactElement.cloneElement.apply(this, arguments);
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
    };
    module.exports = ReactElementValidator;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/mapObject", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }
  module.exports = mapObject;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/onlyChild", ["npm:react@0.14.0-beta3/lib/ReactElement", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    function onlyChild(children) {
      !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
      return children;
    }
    module.exports = onlyChild;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/deprecated", ["npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function deprecated(fnName, newModule, ctx, fn) {
      var warned = false;
      if (process.env.NODE_ENV !== 'production') {
        var newFn = function() {
          process.env.NODE_ENV !== 'production' ? warning(warned, '`require' + '("react").%s` is deprecated. Please use `require' + '("%s").%s` ' + 'instead.', fnName, newModule, fnName) : undefined;
          warned = true;
          return fn.apply(ctx, arguments);
        };
        return assign(newFn, fn);
      }
      return fn;
    }
    module.exports = deprecated;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$.fw", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = function($) {
    $.FW = false;
    $.path = $.core;
    return $;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$.def", ["npm:core-js@0.9.18/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$"),
      global = $.g,
      core = $.core,
      isFunction = $.isFunction;
  function ctx(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  }
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  function $def(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] : (global[name] || {}).prototype,
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      if (isGlobal && !isFunction(target[key]))
        exp = source[key];
      else if (type & $def.B && own)
        exp = ctx(out, global);
      else if (type & $def.W && target[key] == out)
        !function(C) {
          exp = function(param) {
            return this instanceof C ? new C(param) : C(param);
          };
          exp.prototype = C.prototype;
        }(out);
      else
        exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
      exports[key] = exp;
      if (isProto)
        (exports.prototype || (exports.prototype = {}))[key] = out;
    }
  }
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$.get-names", ["npm:core-js@0.9.18/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$"),
      toString = {}.toString,
      getNames = $.getNames;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  function getWindowNames(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  }
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames($.toObject(it));
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/fn/object/create", ["npm:core-js@0.9.18/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$");
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$.assert", ["npm:core-js@0.9.18/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$");
  function assert(condition, msg1, msg2) {
    if (!condition)
      throw TypeError(msg2 ? msg1 + msg2 : msg1);
  }
  assert.def = $.assertDefined;
  assert.fn = function(it) {
    if (!$.isFunction(it))
      throw TypeError(it + ' is not a function!');
    return it;
  };
  assert.obj = function(it) {
    if (!$.isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  assert.inst = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  module.exports = assert;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$.ctx", ["npm:core-js@0.9.18/library/modules/$.assert"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var assertFunction = require("npm:core-js@0.9.18/library/modules/$.assert").fn;
  module.exports = function(fn, that, length) {
    assertFunction(fn);
    if (~length && that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/fn/object/define-property", ["npm:core-js@0.9.18/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$");
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/helpers/class-call-check", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3/lib/invariant", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var invariant = function(condition, format, a, b, c, d, e, f) {
    if (false) {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error('Invariant Violation: ' + format.replace(/%s/g, function() {
          return args[argIndex++];
        }));
      }
      error.framesToPop = 1;
      throw error;
    }
  };
  module.exports = invariant;
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/utils/functions", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  exports.isPromise = isPromise;
  exports.eachObject = eachObject;
  exports.assign = assign;
  var isFunction = function isFunction(x) {
    return typeof x === 'function';
  };
  exports.isFunction = isFunction;
  function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
  }
  function eachObject(f, o) {
    o.forEach(function(from) {
      Object.keys(Object(from)).forEach(function(key) {
        f(key, from[key]);
      });
    });
  }
  function assign(target) {
    for (var _len = arguments.length,
        source = Array(_len > 1 ? _len - 1 : 0),
        _key = 1; _key < _len; _key++) {
      source[_key - 1] = arguments[_key];
    }
    eachObject(function(key, value) {
      return target[key] = value;
    }, source);
    return target;
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib/utils/AltUtils", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  exports.getInternalMethods = getInternalMethods;
  exports.warn = warn;
  exports.uid = uid;
  exports.formatAsConstant = formatAsConstant;
  exports.dispatchIdentity = dispatchIdentity;
  var builtIns = Object.getOwnPropertyNames(NoopClass);
  var builtInProto = Object.getOwnPropertyNames(NoopClass.prototype);
  function getInternalMethods(Obj, isProto) {
    var excluded = isProto ? builtInProto : builtIns;
    var obj = isProto ? Obj.prototype : Obj;
    return Object.getOwnPropertyNames(obj).reduce(function(value, m) {
      if (excluded.indexOf(m) !== -1) {
        return value;
      }
      value[m] = obj[m];
      return value;
    }, {});
  }
  function warn(msg) {
    if (typeof console !== 'undefined') {
      console.warn(new ReferenceError(msg));
    }
  }
  function uid(container, name) {
    var count = 0;
    var key = name;
    while (Object.hasOwnProperty.call(container, key)) {
      key = name + String(++count);
    }
    return key;
  }
  function formatAsConstant(name) {
    return name.replace(/[a-z]([A-Z])/g, function(i) {
      return i[0] + '_' + i[1].toLowerCase();
    }).toUpperCase();
  }
  function dispatchIdentity(x) {
    for (var _len = arguments.length,
        a = Array(_len > 1 ? _len - 1 : 0),
        _key = 1; _key < _len; _key++) {
      a[_key - 1] = arguments[_key];
    }
    this.dispatch(a.length ? [x].concat(a) : x);
  }
  function NoopClass() {}
  global.define = __define;
  return module.exports;
});

System.register("npm:transmitter@1.0.2/dist/transmitter", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function transmitter() {
    var subscriptions = [];
    var unsubscribe = function unsubscribe(onChange) {
      var id = subscriptions.indexOf(onChange);
      if (id >= 0)
        subscriptions.splice(id, 1);
    };
    var subscribe = function subscribe(onChange) {
      subscriptions.push(onChange);
      var dispose = function dispose() {
        return unsubscribe(onChange);
      };
      return {dispose: dispose};
    };
    var push = function push(value) {
      subscriptions.forEach(function(subscription) {
        return subscription(value);
      });
    };
    return {
      subscribe: subscribe,
      push: push,
      unsubscribe: unsubscribe
    };
  }
  module.exports = transmitter;
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib/store/StoreMixin", ["npm:transmitter@1.0.2", "npm:alt@0.17.1/utils/functions"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _transmitter = require("npm:transmitter@1.0.2");
  var _transmitter2 = _interopRequireDefault(_transmitter);
  var _utilsFunctions = require("npm:alt@0.17.1/utils/functions");
  var fn = _interopRequireWildcard(_utilsFunctions);
  var StoreMixin = {
    waitFor: function waitFor() {
      for (var _len = arguments.length,
          sources = Array(_len),
          _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      if (!sources.length) {
        throw new ReferenceError('Dispatch tokens not provided');
      }
      var sourcesArray = sources;
      if (sources.length === 1) {
        sourcesArray = Array.isArray(sources[0]) ? sources[0] : sources;
      }
      var tokens = sourcesArray.map(function(source) {
        return source.dispatchToken || source;
      });
      this.dispatcher.waitFor(tokens);
    },
    exportAsync: function exportAsync(asyncMethods) {
      this.registerAsync(asyncMethods);
    },
    registerAsync: function registerAsync(asyncDef) {
      var _this = this;
      var loadCounter = 0;
      var asyncMethods = fn.isFunction(asyncDef) ? asyncDef(this.alt) : asyncDef;
      var toExport = Object.keys(asyncMethods).reduce(function(publicMethods, methodName) {
        var desc = asyncMethods[methodName];
        var spec = fn.isFunction(desc) ? desc(_this) : desc;
        var validHandlers = ['success', 'error', 'loading'];
        validHandlers.forEach(function(handler) {
          if (spec[handler] && !spec[handler].id) {
            throw new Error(handler + ' handler must be an action function');
          }
        });
        publicMethods[methodName] = function() {
          for (var _len2 = arguments.length,
              args = Array(_len2),
              _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          var state = _this.getInstance().getState();
          var value = spec.local && spec.local.apply(spec, [state].concat(args));
          var shouldFetch = spec.shouldFetch ? spec.shouldFetch.apply(spec, [state].concat(args)) : value == null;
          var intercept = spec.interceptResponse || function(x) {
            return x;
          };
          var makeActionHandler = function makeActionHandler(action, isError) {
            return function(x) {
              var fire = function fire() {
                loadCounter -= 1;
                action(intercept(x, action, args));
                if (isError)
                  throw x;
              };
              return _this.alt.trapAsync ? function() {
                return fire();
              } : fire();
            };
          };
          if (shouldFetch) {
            loadCounter += 1;
            if (spec.loading)
              spec.loading(intercept(null, spec.loading, args));
            return spec.remote.apply(spec, [state].concat(args)).then(makeActionHandler(spec.success), makeActionHandler(spec.error, 1));
          } else {
            _this.emitChange();
          }
        };
        return publicMethods;
      }, {});
      this.exportPublicMethods(toExport);
      this.exportPublicMethods({isLoading: function isLoading() {
          return loadCounter > 0;
        }});
    },
    exportPublicMethods: function exportPublicMethods(methods) {
      var _this2 = this;
      fn.eachObject(function(methodName, value) {
        if (!fn.isFunction(value)) {
          throw new TypeError('exportPublicMethods expects a function');
        }
        _this2.publicMethods[methodName] = value;
      }, [methods]);
    },
    emitChange: function emitChange() {
      this.getInstance().emitChange();
    },
    on: function on(lifecycleEvent, handler) {
      if (lifecycleEvent === 'error')
        this.handlesOwnErrors = true;
      var bus = this.lifecycleEvents[lifecycleEvent] || (0, _transmitter2['default'])();
      this.lifecycleEvents[lifecycleEvent] = bus;
      return bus.subscribe(handler.bind(this));
    },
    bindAction: function bindAction(symbol, handler) {
      if (!symbol) {
        throw new ReferenceError('Invalid action reference passed in');
      }
      if (!fn.isFunction(handler)) {
        throw new TypeError('bindAction expects a function');
      }
      if (handler.length > 1) {
        throw new TypeError('Action handler in store ' + this.displayName + ' for ' + ((symbol.id || symbol).toString() + ' was defined with ') + 'two parameters. Only a single parameter is passed through the ' + 'dispatcher, did you mean to pass in an Object instead?');
      }
      var key = symbol.id ? symbol.id : symbol;
      this.actionListeners[key] = handler.bind(this);
      this.boundListeners.push(key);
    },
    bindActions: function bindActions(actions) {
      var _this3 = this;
      fn.eachObject(function(action, symbol) {
        var matchFirstCharacter = /./;
        var assumedEventHandler = action.replace(matchFirstCharacter, function(x) {
          return 'on' + x[0].toUpperCase();
        });
        var handler = null;
        if (_this3[action] && _this3[assumedEventHandler]) {
          throw new ReferenceError('You have multiple action handlers bound to an action: ' + (action + ' and ' + assumedEventHandler));
        } else if (_this3[action]) {
          handler = _this3[action];
        } else if (_this3[assumedEventHandler]) {
          handler = _this3[assumedEventHandler];
        }
        if (handler) {
          _this3.bindAction(symbol, handler);
        }
      }, [actions]);
    },
    bindListeners: function bindListeners(obj) {
      var _this4 = this;
      fn.eachObject(function(methodName, symbol) {
        var listener = _this4[methodName];
        if (!listener) {
          throw new ReferenceError(methodName + ' defined but does not exist in ' + _this4.displayName);
        }
        if (Array.isArray(symbol)) {
          symbol.forEach(function(action) {
            _this4.bindAction(action, listener);
          });
        } else {
          _this4.bindAction(symbol, listener);
        }
      }, [obj]);
    }
  };
  exports['default'] = StoreMixin;
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib/actions/index", ["npm:alt@0.17.1/utils/functions", "npm:alt@0.17.1/lib/utils/AltUtils"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports['default'] = makeAction;
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var _utilsFunctions = require("npm:alt@0.17.1/utils/functions");
  var fn = _interopRequireWildcard(_utilsFunctions);
  var _utilsAltUtils = require("npm:alt@0.17.1/lib/utils/AltUtils");
  var utils = _interopRequireWildcard(_utilsAltUtils);
  var AltAction = (function() {
    function AltAction(alt, id, action, actions, actionDetails) {
      _classCallCheck(this, AltAction);
      this.id = id;
      this._dispatch = action.bind(this);
      this.actions = actions;
      this.actionDetails = actionDetails;
      this.alt = alt;
    }
    _createClass(AltAction, [{
      key: 'dispatch',
      value: function dispatch(data) {
        this.dispatched = true;
        this.alt.dispatch(this.id, data, this.actionDetails);
      }
    }]);
    return AltAction;
  })();
  function makeAction(alt, namespace, name, implementation, obj) {
    var id = utils.uid(alt._actionsRegistry, namespace + '.' + name);
    alt._actionsRegistry[id] = 1;
    var data = {
      id: id,
      namespace: namespace,
      name: name
    };
    var newAction = new AltAction(alt, id, implementation, obj, data);
    var dispatch = function dispatch(payload) {
      return alt.dispatch(id, payload, data);
    };
    var action = function action() {
      newAction.dispatched = false;
      var result = newAction._dispatch.apply(newAction, arguments);
      if (!newAction.dispatched && result !== undefined && !fn.isPromise(result)) {
        if (fn.isFunction(result)) {
          result(dispatch);
        } else {
          dispatch(result);
        }
      }
      return result;
    };
    action.defer = function() {
      for (var _len = arguments.length,
          args = Array(_len),
          _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      setTimeout(function() {
        newAction._dispatch.apply(null, args);
      });
    };
    action.id = id;
    action.data = data;
    var container = alt.actions[namespace];
    var namespaceId = utils.uid(container, name);
    container[namespaceId] = action;
    return action;
  }
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(undefined) {
      var objectTypes = {
        'function': true,
        'object': true
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
          freeSelf = objectTypes[typeof self] && self.Object && self,
          freeWindow = objectTypes[typeof window] && window && window.Object && window,
          freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
          freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      var Rx = {
        internals: {},
        config: {Promise: root.Promise},
        helpers: {}
      };
      var noop = Rx.helpers.noop = function() {},
          identity = Rx.helpers.identity = function(x) {
            return x;
          },
          defaultNow = Rx.helpers.defaultNow = Date.now,
          defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
            return isEqual(x, y);
          },
          defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
            return x > y ? 1 : (x < y ? -1 : 0);
          },
          defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
            return x.toString();
          },
          defaultError = Rx.helpers.defaultError = function(err) {
            throw err;
          },
          isPromise = Rx.helpers.isPromise = function(p) {
            return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
          },
          isFunction = Rx.helpers.isFunction = (function() {
            var isFn = function(value) {
              return typeof value == 'function' || false;
            };
            if (isFn(/x/)) {
              isFn = function(value) {
                return typeof value == 'function' && toString.call(value) == '[object Function]';
              };
            }
            return isFn;
          }());
      function cloneArray(arr) {
        for (var a = [],
            i = 0,
            len = arr.length; i < len; i++) {
          a.push(arr[i]);
        }
        return a;
      }
      var errorObj = {e: {}};
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn) {
        if (!isFunction(fn)) {
          throw new TypeError('fn must be a function');
        }
        tryCatchTarget = fn;
        return tryCatcher;
      }
      function thrower(e) {
        throw e;
      }
      Rx.config.longStackSupport = false;
      var hasStacks = false,
          stacks = tryCatch(function() {
            throw new Error();
          })();
      hasStacks = !!stacks.e && !!stacks.e.stack;
      var rStartingLine = captureLine(),
          rFileName;
      var STACK_JUMP_SEPARATOR = 'From previous event:';
      function makeStackTraceLong(error, observable) {
        if (hasStacks && observable.stack && typeof error === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          var stacks = [];
          for (var o = observable; !!o; o = o.source) {
            if (o.stack) {
              stacks.unshift(o.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join('\n' + STACK_JUMP_SEPARATOR + '\n');
          error.stack = filterStackString(concatedStacks);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split('\n'),
            desiredLines = [];
        for (var i = 0,
            len = lines.length; i < len; i++) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join('\n');
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0],
            lineNumber = fileNameAndLineNumber[1];
        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
      }
      function captureLine() {
        if (!hasStacks) {
          return ;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split('\n');
          var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return ;
          }
          rFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      var EmptyError = Rx.EmptyError = function() {
        this.message = 'Sequence contains no elements.';
        Error.call(this);
      };
      EmptyError.prototype = Error.prototype;
      var ObjectDisposedError = Rx.ObjectDisposedError = function() {
        this.message = 'Object has been disposed';
        Error.call(this);
      };
      ObjectDisposedError.prototype = Error.prototype;
      var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
        this.message = 'Argument out of range';
        Error.call(this);
      };
      ArgumentOutOfRangeError.prototype = Error.prototype;
      var NotSupportedError = Rx.NotSupportedError = function(message) {
        this.message = message || 'This operation is not supported';
        Error.call(this);
      };
      NotSupportedError.prototype = Error.prototype;
      var NotImplementedError = Rx.NotImplementedError = function(message) {
        this.message = message || 'This operation is not implemented';
        Error.call(this);
      };
      NotImplementedError.prototype = Error.prototype;
      var notImplemented = Rx.helpers.notImplemented = function() {
        throw new NotImplementedError();
      };
      var notSupported = Rx.helpers.notSupported = function() {
        throw new NotSupportedError();
      };
      var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
      if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
        $iterator$ = '@@iterator';
      }
      var doneEnumerator = Rx.doneEnumerator = {
        done: true,
        value: undefined
      };
      var isIterable = Rx.helpers.isIterable = function(o) {
        return o[$iterator$] !== undefined;
      };
      var isArrayLike = Rx.helpers.isArrayLike = function(o) {
        return o && o.length !== undefined;
      };
      Rx.helpers.iterator = $iterator$;
      var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
        if (typeof thisArg === 'undefined') {
          return func;
        }
        switch (argCount) {
          case 0:
            return function() {
              return func.call(thisArg);
            };
          case 1:
            return function(arg) {
              return func.call(thisArg, arg);
            };
          case 2:
            return function(value, index) {
              return func.call(thisArg, value, index);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
        }
        return function() {
          return func.apply(thisArg, arguments);
        };
      };
      var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
          dontEnumsLength = dontEnums.length;
      var argsClass = '[object Arguments]',
          arrayClass = '[object Array]',
          boolClass = '[object Boolean]',
          dateClass = '[object Date]',
          errorClass = '[object Error]',
          funcClass = '[object Function]',
          numberClass = '[object Number]',
          objectClass = '[object Object]',
          regexpClass = '[object RegExp]',
          stringClass = '[object String]';
      var toString = Object.prototype.toString,
          hasOwnProperty = Object.prototype.hasOwnProperty,
          supportsArgsClass = toString.call(arguments) == argsClass,
          supportNodeClass,
          errorProto = Error.prototype,
          objectProto = Object.prototype,
          stringProto = String.prototype,
          propertyIsEnumerable = objectProto.propertyIsEnumerable;
      try {
        supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
      } catch (e) {
        supportNodeClass = true;
      }
      var nonEnumProps = {};
      nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
        'constructor': true,
        'toLocaleString': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
        'constructor': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
        'constructor': true,
        'toString': true
      };
      nonEnumProps[objectClass] = {'constructor': true};
      var support = {};
      (function() {
        var ctor = function() {
          this.x = 1;
        },
            props = [];
        ctor.prototype = {
          'valueOf': 1,
          'y': 1
        };
        for (var key in new ctor) {
          props.push(key);
        }
        for (key in arguments) {}
        support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
        support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props);
      }(1));
      var isObject = Rx.internals.isObject = function(value) {
        var type = typeof value;
        return value && (type == 'function' || type == 'object') || false;
      };
      function keysIn(object) {
        var result = [];
        if (!isObject(object)) {
          return result;
        }
        if (support.nonEnumArgs && object.length && isArguments(object)) {
          object = slice.call(object);
        }
        var skipProto = support.enumPrototypes && typeof object == 'function',
            skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
        for (var key in object) {
          if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
            result.push(key);
          }
        }
        if (support.nonEnumShadows && object !== objectProto) {
          var ctor = object.constructor,
              index = -1,
              length = dontEnumsLength;
          if (object === (ctor && ctor.prototype)) {
            var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
                nonEnum = nonEnumProps[className];
          }
          while (++index < length) {
            key = dontEnums[index];
            if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
        }
        return result;
      }
      function internalFor(object, callback, keysFunc) {
        var index = -1,
            props = keysFunc(object),
            length = props.length;
        while (++index < length) {
          var key = props[index];
          if (callback(object[key], key, object) === false) {
            break;
          }
        }
        return object;
      }
      function internalForIn(object, callback) {
        return internalFor(object, callback, keysIn);
      }
      function isNode(value) {
        return typeof value.toString != 'function' && typeof(value + '') == 'string';
      }
      var isArguments = function(value) {
        return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
      };
      if (!supportsArgsClass) {
        isArguments = function(value) {
          return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
        };
      }
      var isEqual = Rx.internals.isEqual = function(x, y) {
        return deepEquals(x, y, [], []);
      };
      function deepEquals(a, b, stackA, stackB) {
        if (a === b) {
          return a !== 0 || (1 / a == 1 / b);
        }
        var type = typeof a,
            otherType = typeof b;
        if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
          return false;
        }
        var className = toString.call(a),
            otherClass = toString.call(b);
        if (className == argsClass) {
          className = objectClass;
        }
        if (otherClass == argsClass) {
          otherClass = objectClass;
        }
        if (className != otherClass) {
          return false;
        }
        switch (className) {
          case boolClass:
          case dateClass:
            return +a == +b;
          case numberClass:
            return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
          case regexpClass:
          case stringClass:
            return a == String(b);
        }
        var isArr = className == arrayClass;
        if (!isArr) {
          if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
            return false;
          }
          var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
              ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
          if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        var initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) {
          if (stackA[length] == a) {
            return stackB[length] == b;
          }
        }
        var size = 0;
        var result = true;
        stackA.push(a);
        stackB.push(b);
        if (isArr) {
          length = a.length;
          size = b.length;
          result = size == length;
          if (result) {
            while (size--) {
              var index = length,
                  value = b[size];
              if (!(result = deepEquals(a[size], value, stackA, stackB))) {
                break;
              }
            }
          }
        } else {
          internalForIn(b, function(value, key, b) {
            if (hasOwnProperty.call(b, key)) {
              size++;
              return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
            }
          });
          if (result) {
            internalForIn(a, function(value, key, a) {
              if (hasOwnProperty.call(a, key)) {
                return (result = --size > -1);
              }
            });
          }
        }
        stackA.pop();
        stackB.pop();
        return result;
      }
      var hasProp = {}.hasOwnProperty,
          slice = Array.prototype.slice;
      var inherits = this.inherits = Rx.internals.inherits = function(child, parent) {
        function __() {
          this.constructor = child;
        }
        __.prototype = parent.prototype;
        child.prototype = new __();
      };
      var addProperties = Rx.internals.addProperties = function(obj) {
        for (var sources = [],
            i = 1,
            len = arguments.length; i < len; i++) {
          sources.push(arguments[i]);
        }
        for (var idx = 0,
            ln = sources.length; idx < ln; idx++) {
          var source = sources[idx];
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      };
      var addRef = Rx.internals.addRef = function(xs, r) {
        return new AnonymousObservable(function(observer) {
          return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
        });
      };
      function arrayInitialize(count, factory) {
        var a = new Array(count);
        for (var i = 0; i < count; i++) {
          a[i] = factory();
        }
        return a;
      }
      var CompositeDisposable = Rx.CompositeDisposable = function() {
        var args = [],
            i,
            len;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
          len = args.length;
        } else {
          len = arguments.length;
          args = new Array(len);
          for (i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        for (i = 0; i < len; i++) {
          if (!isDisposable(args[i])) {
            throw new TypeError('Not a disposable');
          }
        }
        this.disposables = args;
        this.isDisposed = false;
        this.length = args.length;
      };
      var CompositeDisposablePrototype = CompositeDisposable.prototype;
      CompositeDisposablePrototype.add = function(item) {
        if (this.isDisposed) {
          item.dispose();
        } else {
          this.disposables.push(item);
          this.length++;
        }
      };
      CompositeDisposablePrototype.remove = function(item) {
        var shouldDispose = false;
        if (!this.isDisposed) {
          var idx = this.disposables.indexOf(item);
          if (idx !== -1) {
            shouldDispose = true;
            this.disposables.splice(idx, 1);
            this.length--;
            item.dispose();
          }
        }
        return shouldDispose;
      };
      CompositeDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var len = this.disposables.length,
              currentDisposables = new Array(len);
          for (var i = 0; i < len; i++) {
            currentDisposables[i] = this.disposables[i];
          }
          this.disposables = [];
          this.length = 0;
          for (i = 0; i < len; i++) {
            currentDisposables[i].dispose();
          }
        }
      };
      var Disposable = Rx.Disposable = function(action) {
        this.isDisposed = false;
        this.action = action || noop;
      };
      Disposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.action();
          this.isDisposed = true;
        }
      };
      var disposableCreate = Disposable.create = function(action) {
        return new Disposable(action);
      };
      var disposableEmpty = Disposable.empty = {dispose: noop};
      var isDisposable = Disposable.isDisposable = function(d) {
        return d && isFunction(d.dispose);
      };
      var checkDisposed = Disposable.checkDisposed = function(disposable) {
        if (disposable.isDisposed) {
          throw new ObjectDisposedError();
        }
      };
      var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SingleAssignmentDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SingleAssignmentDisposable.prototype.setDisposable = function(value) {
        if (this.current) {
          throw new Error('Disposable has already been assigned');
        }
        var shouldDispose = this.isDisposed;
        !shouldDispose && (this.current = value);
        shouldDispose && value && value.dispose();
      };
      SingleAssignmentDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var SerialDisposable = Rx.SerialDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SerialDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SerialDisposable.prototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
          var old = this.current;
          this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
      };
      SerialDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var RefCountDisposable = Rx.RefCountDisposable = (function() {
        function InnerDisposable(disposable) {
          this.disposable = disposable;
          this.disposable.count++;
          this.isInnerDisposed = false;
        }
        InnerDisposable.prototype.dispose = function() {
          if (!this.disposable.isDisposed && !this.isInnerDisposed) {
            this.isInnerDisposed = true;
            this.disposable.count--;
            if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
              this.disposable.isDisposed = true;
              this.disposable.underlyingDisposable.dispose();
            }
          }
        };
        function RefCountDisposable(disposable) {
          this.underlyingDisposable = disposable;
          this.isDisposed = false;
          this.isPrimaryDisposed = false;
          this.count = 0;
        }
        RefCountDisposable.prototype.dispose = function() {
          if (!this.isDisposed && !this.isPrimaryDisposed) {
            this.isPrimaryDisposed = true;
            if (this.count === 0) {
              this.isDisposed = true;
              this.underlyingDisposable.dispose();
            }
          }
        };
        RefCountDisposable.prototype.getDisposable = function() {
          return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
        };
        return RefCountDisposable;
      })();
      function ScheduledDisposable(scheduler, disposable) {
        this.scheduler = scheduler;
        this.disposable = disposable;
        this.isDisposed = false;
      }
      function scheduleItem(s, self) {
        if (!self.isDisposed) {
          self.isDisposed = true;
          self.disposable.dispose();
        }
      }
      ScheduledDisposable.prototype.dispose = function() {
        this.scheduler.scheduleWithState(this, scheduleItem);
      };
      var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
        this.scheduler = scheduler;
        this.state = state;
        this.action = action;
        this.dueTime = dueTime;
        this.comparer = comparer || defaultSubComparer;
        this.disposable = new SingleAssignmentDisposable();
      };
      ScheduledItem.prototype.invoke = function() {
        this.disposable.setDisposable(this.invokeCore());
      };
      ScheduledItem.prototype.compareTo = function(other) {
        return this.comparer(this.dueTime, other.dueTime);
      };
      ScheduledItem.prototype.isCancelled = function() {
        return this.disposable.isDisposed;
      };
      ScheduledItem.prototype.invokeCore = function() {
        return this.action(this.scheduler, this.state);
      };
      var Scheduler = Rx.Scheduler = (function() {
        function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
          this.now = now;
          this._schedule = schedule;
          this._scheduleRelative = scheduleRelative;
          this._scheduleAbsolute = scheduleAbsolute;
        }
        Scheduler.isScheduler = function(s) {
          return s instanceof Scheduler;
        };
        function invokeAction(scheduler, action) {
          action();
          return disposableEmpty;
        }
        var schedulerProto = Scheduler.prototype;
        schedulerProto.schedule = function(action) {
          return this._schedule(action, invokeAction);
        };
        schedulerProto.scheduleWithState = function(state, action) {
          return this._schedule(state, action);
        };
        schedulerProto.scheduleWithRelative = function(dueTime, action) {
          return this._scheduleRelative(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative(state, dueTime, action);
        };
        schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
          return this._scheduleAbsolute(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute(state, dueTime, action);
        };
        Scheduler.now = defaultNow;
        Scheduler.normalize = function(timeSpan) {
          timeSpan < 0 && (timeSpan = 0);
          return timeSpan;
        };
        return Scheduler;
      }());
      var normalizeTime = Scheduler.normalize,
          isScheduler = Scheduler.isScheduler;
      (function(schedulerProto) {
        function invokeRecImmediate(scheduler, pair) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          action(state, innerAction);
          return group;
          function innerAction(state2) {
            var isAdded = false,
                isDone = false;
            var d = scheduler.scheduleWithState(state2, scheduleWork);
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
            function scheduleWork(_, state3) {
              if (isAdded) {
                group.remove(d);
              } else {
                isDone = true;
              }
              action(state3, innerAction);
              return disposableEmpty;
            }
          }
        }
        function invokeRecDate(scheduler, pair, method) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          action(state, innerAction);
          return group;
          function innerAction(state2, dueTime1) {
            var isAdded = false,
                isDone = false;
            var d = scheduler[method](state2, dueTime1, scheduleWork);
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
            function scheduleWork(_, state3) {
              if (isAdded) {
                group.remove(d);
              } else {
                isDone = true;
              }
              action(state3, innerAction);
              return disposableEmpty;
            }
          }
        }
        function invokeRecDateRelative(s, p) {
          return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
        }
        function invokeRecDateAbsolute(s, p) {
          return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
        }
        function scheduleInnerRecursive(action, self) {
          action(function(dt) {
            self(action, dt);
          });
        }
        schedulerProto.scheduleRecursive = function(action) {
          return this.scheduleRecursiveWithState(action, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithState = function(state, action) {
          return this.scheduleWithState([state, action], invokeRecImmediate);
        };
        schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
          return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative([state, action], dueTime, invokeRecDateRelative);
        };
        schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
          return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute([state, action], dueTime, invokeRecDateAbsolute);
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        Scheduler.prototype.schedulePeriodic = function(period, action) {
          return this.schedulePeriodicWithState(null, period, action);
        };
        Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          if (typeof root.setInterval === 'undefined') {
            throw new NotSupportedError();
          }
          period = normalizeTime(period);
          var s = state,
              id = root.setInterval(function() {
                s = action(s);
              }, period);
          return disposableCreate(function() {
            root.clearInterval(id);
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        schedulerProto.catchError = schedulerProto['catch'] = function(handler) {
          return new CatchScheduler(this, handler);
        };
      }(Scheduler.prototype));
      var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function() {
        function tick(command, recurse) {
          recurse(0, this._period);
          try {
            this._state = this._action(this._state);
          } catch (e) {
            this._cancel.dispose();
            throw e;
          }
        }
        function SchedulePeriodicRecursive(scheduler, state, period, action) {
          this._scheduler = scheduler;
          this._state = state;
          this._period = period;
          this._action = action;
        }
        SchedulePeriodicRecursive.prototype.start = function() {
          var d = new SingleAssignmentDisposable();
          this._cancel = d;
          d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
          return d;
        };
        return SchedulePeriodicRecursive;
      }());
      var immediateScheduler = Scheduler.immediate = (function() {
        function scheduleNow(state, action) {
          return action(this, state);
        }
        return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
      }());
      var currentThreadScheduler = Scheduler.currentThread = (function() {
        var queue;
        function runTrampoline() {
          while (queue.length > 0) {
            var item = queue.shift();
            !item.isCancelled() && item.invoke();
          }
        }
        function scheduleNow(state, action) {
          var si = new ScheduledItem(this, state, action, this.now());
          if (!queue) {
            queue = [si];
            var result = tryCatch(runTrampoline)();
            queue = null;
            if (result === errorObj) {
              return thrower(result.e);
            }
          } else {
            queue.push(si);
          }
          return si.disposable;
        }
        var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
        currentScheduler.scheduleRequired = function() {
          return !queue;
        };
        return currentScheduler;
      }());
      var scheduleMethod,
          clearMethod;
      var localTimer = (function() {
        var localSetTimeout,
            localClearTimeout = noop;
        if (!!root.setTimeout) {
          localSetTimeout = root.setTimeout;
          localClearTimeout = root.clearTimeout;
        } else if (!!root.WScript) {
          localSetTimeout = function(fn, time) {
            root.WScript.Sleep(time);
            fn();
          };
        } else {
          throw new NotSupportedError();
        }
        return {
          setTimeout: localSetTimeout,
          clearTimeout: localClearTimeout
        };
      }());
      var localSetTimeout = localTimer.setTimeout,
          localClearTimeout = localTimer.clearTimeout;
      (function() {
        var nextHandle = 1,
            tasksByHandle = {},
            currentlyRunning = false;
        clearMethod = function(handle) {
          delete tasksByHandle[handle];
        };
        function runTask(handle) {
          if (currentlyRunning) {
            localSetTimeout(function() {
              runTask(handle);
            }, 0);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunning = true;
              var result = tryCatch(task)();
              clearMethod(handle);
              currentlyRunning = false;
              if (result === errorObj) {
                return thrower(result.e);
              }
            }
          }
        }
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var setImmediate = typeof(setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
        function postMessageSupported() {
          if (!root.postMessage || root.importScripts) {
            return false;
          }
          var isAsync = false,
              oldHandler = root.onmessage;
          root.onmessage = function() {
            isAsync = true;
          };
          root.postMessage('', '*');
          root.onmessage = oldHandler;
          return isAsync;
        }
        if (isFunction(setImmediate)) {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            setImmediate(function() {
              runTask(id);
            });
            return id;
          };
        } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            process.nextTick(function() {
              runTask(id);
            });
            return id;
          };
        } else if (postMessageSupported()) {
          var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
          function onGlobalPostMessage(event) {
            if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
              runTask(event.data.substring(MSG_PREFIX.length));
            }
          }
          if (root.addEventListener) {
            root.addEventListener('message', onGlobalPostMessage, false);
          } else if (root.attachEvent) {
            root.attachEvent('onmessage', onGlobalPostMessage);
          } else {
            root.onmessage = onGlobalPostMessage;
          }
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            root.postMessage(MSG_PREFIX + currentId, '*');
            return id;
          };
        } else if (!!root.MessageChannel) {
          var channel = new root.MessageChannel();
          channel.port1.onmessage = function(e) {
            runTask(e.data);
          };
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            channel.port2.postMessage(id);
            return id;
          };
        } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
          scheduleMethod = function(action) {
            var scriptElement = root.document.createElement('script');
            var id = nextHandle++;
            tasksByHandle[id] = action;
            scriptElement.onreadystatechange = function() {
              runTask(id);
              scriptElement.onreadystatechange = null;
              scriptElement.parentNode.removeChild(scriptElement);
              scriptElement = null;
            };
            root.document.documentElement.appendChild(scriptElement);
            return id;
          };
        } else {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            localSetTimeout(function() {
              runTask(id);
            }, 0);
            return id;
          };
        }
      }());
      var timeoutScheduler = Scheduler.timeout = Scheduler['default'] = (function() {
        function scheduleNow(state, action) {
          var scheduler = this,
              disposable = new SingleAssignmentDisposable();
          var id = scheduleMethod(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          });
          return new CompositeDisposable(disposable, disposableCreate(function() {
            clearMethod(id);
          }));
        }
        function scheduleRelative(state, dueTime, action) {
          var scheduler = this,
              dt = Scheduler.normalize(dueTime),
              disposable = new SingleAssignmentDisposable();
          if (dt === 0) {
            return scheduler.scheduleWithState(state, action);
          }
          var id = localSetTimeout(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          }, dt);
          return new CompositeDisposable(disposable, disposableCreate(function() {
            localClearTimeout(id);
          }));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      })();
      var CatchScheduler = (function(__super__) {
        function scheduleNow(state, action) {
          return this._scheduler.scheduleWithState(state, this._wrap(action));
        }
        function scheduleRelative(state, dueTime, action) {
          return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
        }
        inherits(CatchScheduler, __super__);
        function CatchScheduler(scheduler, handler) {
          this._scheduler = scheduler;
          this._handler = handler;
          this._recursiveOriginal = null;
          this._recursiveWrapper = null;
          __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
        }
        CatchScheduler.prototype._clone = function(scheduler) {
          return new CatchScheduler(scheduler, this._handler);
        };
        CatchScheduler.prototype._wrap = function(action) {
          var parent = this;
          return function(self, state) {
            try {
              return action(parent._getRecursiveWrapper(self), state);
            } catch (e) {
              if (!parent._handler(e)) {
                throw e;
              }
              return disposableEmpty;
            }
          };
        };
        CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
          if (this._recursiveOriginal !== scheduler) {
            this._recursiveOriginal = scheduler;
            var wrapper = this._clone(scheduler);
            wrapper._recursiveOriginal = scheduler;
            wrapper._recursiveWrapper = wrapper;
            this._recursiveWrapper = wrapper;
          }
          return this._recursiveWrapper;
        };
        CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          var self = this,
              failed = false,
              d = new SingleAssignmentDisposable();
          d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function(state1) {
            if (failed) {
              return null;
            }
            try {
              return action(state1);
            } catch (e) {
              failed = true;
              if (!self._handler(e)) {
                throw e;
              }
              d.dispose();
              return null;
            }
          }));
          return d;
        };
        return CatchScheduler;
      }(Scheduler));
      var Notification = Rx.Notification = (function() {
        function Notification(kind, value, exception, accept, acceptObservable, toString) {
          this.kind = kind;
          this.value = value;
          this.exception = exception;
          this._accept = accept;
          this._acceptObservable = acceptObservable;
          this.toString = toString;
        }
        Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {
          return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
        };
        Notification.prototype.toObservable = function(scheduler) {
          var self = this;
          isScheduler(scheduler) || (scheduler = immediateScheduler);
          return new AnonymousObservable(function(observer) {
            return scheduler.scheduleWithState(self, function(_, notification) {
              notification._acceptObservable(observer);
              notification.kind === 'N' && observer.onCompleted();
            });
          });
        };
        return Notification;
      })();
      var notificationCreateOnNext = Notification.createOnNext = (function() {
        function _accept(onNext) {
          return onNext(this.value);
        }
        function _acceptObservable(observer) {
          return observer.onNext(this.value);
        }
        function toString() {
          return 'OnNext(' + this.value + ')';
        }
        return function(value) {
          return new Notification('N', value, null, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnError = Notification.createOnError = (function() {
        function _accept(onNext, onError) {
          return onError(this.exception);
        }
        function _acceptObservable(observer) {
          return observer.onError(this.exception);
        }
        function toString() {
          return 'OnError(' + this.exception + ')';
        }
        return function(e) {
          return new Notification('E', null, e, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnCompleted = Notification.createOnCompleted = (function() {
        function _accept(onNext, onError, onCompleted) {
          return onCompleted();
        }
        function _acceptObservable(observer) {
          return observer.onCompleted();
        }
        function toString() {
          return 'OnCompleted()';
        }
        return function() {
          return new Notification('C', null, null, _accept, _acceptObservable, toString);
        };
      }());
      var Observer = Rx.Observer = function() {};
      Observer.prototype.toNotifier = function() {
        var observer = this;
        return function(n) {
          return n.accept(observer);
        };
      };
      Observer.prototype.asObserver = function() {
        var self = this;
        return new AnonymousObserver(function(x) {
          self.onNext(x);
        }, function(err) {
          self.onError(err);
        }, function() {
          self.onCompleted();
        });
      };
      Observer.prototype.checked = function() {
        return new CheckedObserver(this);
      };
      var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
        onNext || (onNext = noop);
        onError || (onError = defaultError);
        onCompleted || (onCompleted = noop);
        return new AnonymousObserver(onNext, onError, onCompleted);
      };
      Observer.fromNotifier = function(handler, thisArg) {
        var cb = bindCallback(handler, thisArg, 1);
        return new AnonymousObserver(function(x) {
          return cb(notificationCreateOnNext(x));
        }, function(e) {
          return cb(notificationCreateOnError(e));
        }, function() {
          return cb(notificationCreateOnCompleted());
        });
      };
      Observer.prototype.notifyOn = function(scheduler) {
        return new ObserveOnObserver(scheduler, this);
      };
      Observer.prototype.makeSafe = function(disposable) {
        return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
      };
      var AbstractObserver = Rx.internals.AbstractObserver = (function(__super__) {
        inherits(AbstractObserver, __super__);
        function AbstractObserver() {
          this.isStopped = false;
        }
        AbstractObserver.prototype.next = notImplemented;
        AbstractObserver.prototype.error = notImplemented;
        AbstractObserver.prototype.completed = notImplemented;
        AbstractObserver.prototype.onNext = function(value) {
          !this.isStopped && this.next(value);
        };
        AbstractObserver.prototype.onError = function(error) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(error);
          }
        };
        AbstractObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.completed();
          }
        };
        AbstractObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        AbstractObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(e);
            return true;
          }
          return false;
        };
        return AbstractObserver;
      }(Observer));
      var AnonymousObserver = Rx.AnonymousObserver = (function(__super__) {
        inherits(AnonymousObserver, __super__);
        function AnonymousObserver(onNext, onError, onCompleted) {
          __super__.call(this);
          this._onNext = onNext;
          this._onError = onError;
          this._onCompleted = onCompleted;
        }
        AnonymousObserver.prototype.next = function(value) {
          this._onNext(value);
        };
        AnonymousObserver.prototype.error = function(error) {
          this._onError(error);
        };
        AnonymousObserver.prototype.completed = function() {
          this._onCompleted();
        };
        return AnonymousObserver;
      }(AbstractObserver));
      var CheckedObserver = (function(__super__) {
        inherits(CheckedObserver, __super__);
        function CheckedObserver(observer) {
          __super__.call(this);
          this._observer = observer;
          this._state = 0;
        }
        var CheckedObserverPrototype = CheckedObserver.prototype;
        CheckedObserverPrototype.onNext = function(value) {
          this.checkAccess();
          var res = tryCatch(this._observer.onNext).call(this._observer, value);
          this._state = 0;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onError = function(err) {
          this.checkAccess();
          var res = tryCatch(this._observer.onError).call(this._observer, err);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onCompleted = function() {
          this.checkAccess();
          var res = tryCatch(this._observer.onCompleted).call(this._observer);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.checkAccess = function() {
          if (this._state === 1) {
            throw new Error('Re-entrancy detected');
          }
          if (this._state === 2) {
            throw new Error('Observer completed');
          }
          if (this._state === 0) {
            this._state = 1;
          }
        };
        return CheckedObserver;
      }(Observer));
      var ScheduledObserver = Rx.internals.ScheduledObserver = (function(__super__) {
        inherits(ScheduledObserver, __super__);
        function ScheduledObserver(scheduler, observer) {
          __super__.call(this);
          this.scheduler = scheduler;
          this.observer = observer;
          this.isAcquired = false;
          this.hasFaulted = false;
          this.queue = [];
          this.disposable = new SerialDisposable();
        }
        ScheduledObserver.prototype.next = function(value) {
          var self = this;
          this.queue.push(function() {
            self.observer.onNext(value);
          });
        };
        ScheduledObserver.prototype.error = function(e) {
          var self = this;
          this.queue.push(function() {
            self.observer.onError(e);
          });
        };
        ScheduledObserver.prototype.completed = function() {
          var self = this;
          this.queue.push(function() {
            self.observer.onCompleted();
          });
        };
        ScheduledObserver.prototype.ensureActive = function() {
          var isOwner = false;
          if (!this.hasFaulted && this.queue.length > 0) {
            isOwner = !this.isAcquired;
            this.isAcquired = true;
          }
          if (isOwner) {
            this.disposable.setDisposable(this.scheduler.scheduleRecursiveWithState(this, function(parent, self) {
              var work;
              if (parent.queue.length > 0) {
                work = parent.queue.shift();
              } else {
                parent.isAcquired = false;
                return ;
              }
              var res = tryCatch(work)();
              if (res === errorObj) {
                parent.queue = [];
                parent.hasFaulted = true;
                return thrower(res.e);
              }
              self(parent);
            }));
          }
        };
        ScheduledObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.disposable.dispose();
        };
        return ScheduledObserver;
      }(AbstractObserver));
      var ObserveOnObserver = (function(__super__) {
        inherits(ObserveOnObserver, __super__);
        function ObserveOnObserver(scheduler, observer, cancel) {
          __super__.call(this, scheduler, observer);
          this._cancel = cancel;
        }
        ObserveOnObserver.prototype.next = function(value) {
          __super__.prototype.next.call(this, value);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.error = function(e) {
          __super__.prototype.error.call(this, e);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.completed = function() {
          __super__.prototype.completed.call(this);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this._cancel && this._cancel.dispose();
          this._cancel = null;
        };
        return ObserveOnObserver;
      })(ScheduledObserver);
      var observableProto;
      var Observable = Rx.Observable = (function() {
        function makeSubscribe(self, subscribe) {
          return function(o) {
            var oldOnError = o.onError;
            o.onError = function(e) {
              makeStackTraceLong(e, self);
              oldOnError.call(o, e);
            };
            return subscribe.call(self, o);
          };
        }
        function Observable(subscribe) {
          if (Rx.config.longStackSupport && hasStacks) {
            var e = tryCatch(thrower)(new Error()).e;
            this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
            this._subscribe = makeSubscribe(this, subscribe);
          } else {
            this._subscribe = subscribe;
          }
        }
        observableProto = Observable.prototype;
        Observable.isObservable = function(o) {
          return o && isFunction(o.subscribe);
        };
        observableProto.subscribe = observableProto.forEach = function(oOrOnNext, onError, onCompleted) {
          return this._subscribe(typeof oOrOnNext === 'object' ? oOrOnNext : observerCreate(oOrOnNext, onError, onCompleted));
        };
        observableProto.subscribeOnNext = function(onNext, thisArg) {
          return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) {
            onNext.call(thisArg, x);
          } : onNext));
        };
        observableProto.subscribeOnError = function(onError, thisArg) {
          return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) {
            onError.call(thisArg, e);
          } : onError));
        };
        observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
          return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() {
            onCompleted.call(thisArg);
          } : onCompleted));
        };
        return Observable;
      })();
      var ObservableBase = Rx.ObservableBase = (function(__super__) {
        inherits(ObservableBase, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              self = state[1];
          var sub = tryCatch(self.subscribeCore).call(self, ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function subscribe(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, this];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        function ObservableBase() {
          __super__.call(this, subscribe);
        }
        ObservableBase.prototype.subscribeCore = notImplemented;
        return ObservableBase;
      }(Observable));
      var FlatMapObservable = (function(__super__) {
        inherits(FlatMapObservable, __super__);
        function FlatMapObservable(source, selector, resultSelector, thisArg) {
          this.resultSelector = Rx.helpers.isFunction(resultSelector) ? resultSelector : null;
          this.selector = Rx.internals.bindCallback(Rx.helpers.isFunction(selector) ? selector : function() {
            return selector;
          }, thisArg, 3);
          this.source = source;
          __super__.call(this);
        }
        FlatMapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));
        };
        function InnerObserver(observer, selector, resultSelector, source) {
          this.i = 0;
          this.selector = selector;
          this.resultSelector = resultSelector;
          this.source = source;
          this.isStopped = false;
          this.o = observer;
        }
        InnerObserver.prototype._wrapResult = function(result, x, i) {
          return this.resultSelector ? result.map(function(y, i2) {
            return this.resultSelector(x, y, i, i2);
          }, this) : result;
        };
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped)
            return ;
          var i = this.i++;
          var result = tryCatch(this.selector)(x, i, this.source);
          if (result === errorObj) {
            return this.o.onError(result.e);
          }
          Rx.helpers.isPromise(result) && (result = Rx.Observable.fromPromise(result));
          (Rx.helpers.isArrayLike(result) || Rx.helpers.isIterable(result)) && (result = Rx.Observable.from(result));
          this.o.onNext(this._wrapResult(result, x, i));
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        return FlatMapObservable;
      }(ObservableBase));
      var Enumerable = Rx.internals.Enumerable = function() {};
      var ConcatEnumerableObservable = (function(__super__) {
        inherits(ConcatEnumerableObservable, __super__);
        function ConcatEnumerableObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatEnumerableObservable.prototype.subscribeCore = function(o) {
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(this.sources[$iterator$](), function(e, self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(new InnerObserver(o, self, e)));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        function InnerObserver(o, s, e) {
          this.o = o;
          this.s = s;
          this.e = e;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.s(this.e);
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
            return true;
          }
          return false;
        };
        return ConcatEnumerableObservable;
      }(ObservableBase));
      Enumerable.prototype.concat = function() {
        return new ConcatEnumerableObservable(this);
      };
      var CatchErrorObservable = (function(__super__) {
        inherits(CatchErrorObservable, __super__);
        function CatchErrorObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        CatchErrorObservable.prototype.subscribeCore = function(o) {
          var e = this.sources[$iterator$]();
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return lastException !== null ? o.onError(lastException) : o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, self, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return CatchErrorObservable;
      }(ObservableBase));
      Enumerable.prototype.catchError = function() {
        return new CatchErrorObservable(this);
      };
      Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
        var sources = this;
        return new AnonymousObservable(function(o) {
          var exceptions = new Subject(),
              notifier = new Subject(),
              handled = notificationHandler(exceptions),
              notificationDisposable = handled.subscribe(notifier);
          var e = sources[$iterator$]();
          var isDisposed,
              lastException,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursive(function(self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              if (lastException) {
                o.onError(lastException);
              } else {
                o.onCompleted();
              }
              return ;
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var outer = new SingleAssignmentDisposable();
            var inner = new SingleAssignmentDisposable();
            subscription.setDisposable(new CompositeDisposable(inner, outer));
            outer.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(exn) {
              inner.setDisposable(notifier.subscribe(self, function(ex) {
                o.onError(ex);
              }, function() {
                o.onCompleted();
              }));
              exceptions.onNext(exn);
            }, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        });
      };
      var RepeatEnumerable = (function(__super__) {
        inherits(RepeatEnumerable, __super__);
        function RepeatEnumerable(v, c) {
          this.v = v;
          this.c = c == null ? -1 : c;
        }
        RepeatEnumerable.prototype[$iterator$] = function() {
          return new RepeatEnumerator(this);
        };
        function RepeatEnumerator(p) {
          this.v = p.v;
          this.l = p.c;
        }
        RepeatEnumerator.prototype.next = function() {
          if (this.l === 0) {
            return doneEnumerator;
          }
          if (this.l > 0) {
            this.l--;
          }
          return {
            done: false,
            value: this.v
          };
        };
        return RepeatEnumerable;
      }(Enumerable));
      var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
        return new RepeatEnumerable(value, repeatCount);
      };
      var OfEnumerable = (function(__super__) {
        inherits(OfEnumerable, __super__);
        function OfEnumerable(s, fn, thisArg) {
          this.s = s;
          this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
        }
        OfEnumerable.prototype[$iterator$] = function() {
          return new OfEnumerator(this);
        };
        function OfEnumerator(p) {
          this.i = -1;
          this.s = p.s;
          this.l = this.s.length;
          this.fn = p.fn;
        }
        OfEnumerator.prototype.next = function() {
          return ++this.i < this.l ? {
            done: false,
            value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s)
          } : doneEnumerator;
        };
        return OfEnumerable;
      }(Enumerable));
      var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
        return new OfEnumerable(source, selector, thisArg);
      };
      observableProto.observeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(new ObserveOnObserver(scheduler, observer));
        }, source);
      };
      observableProto.subscribeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              d = new SerialDisposable();
          d.setDisposable(m);
          m.setDisposable(scheduler.schedule(function() {
            d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
          }));
          return d;
        }, source);
      };
      var FromPromiseObservable = (function(__super__) {
        inherits(FromPromiseObservable, __super__);
        function FromPromiseObservable(p) {
          this.p = p;
          __super__.call(this);
        }
        FromPromiseObservable.prototype.subscribeCore = function(o) {
          this.p.then(function(data) {
            o.onNext(data);
            o.onCompleted();
          }, function(err) {
            o.onError(err);
          });
          return disposableEmpty;
        };
        return FromPromiseObservable;
      }(ObservableBase));
      var observableFromPromise = Observable.fromPromise = function(promise) {
        return new FromPromiseObservable(promise);
      };
      observableProto.toPromise = function(promiseCtor) {
        promiseCtor || (promiseCtor = Rx.config.Promise);
        if (!promiseCtor) {
          throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
        }
        var source = this;
        return new promiseCtor(function(resolve, reject) {
          var value,
              hasValue = false;
          source.subscribe(function(v) {
            value = v;
            hasValue = true;
          }, reject, function() {
            hasValue && resolve(value);
          });
        });
      };
      var ToArrayObservable = (function(__super__) {
        inherits(ToArrayObservable, __super__);
        function ToArrayObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        ToArrayObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.a = [];
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.a.push(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onNext(this.a);
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return ToArrayObservable;
      }(ObservableBase));
      observableProto.toArray = function() {
        return new ToArrayObservable(this);
      };
      Observable.create = function(subscribe, parent) {
        return new AnonymousObservable(subscribe, parent);
      };
      var observableDefer = Observable.defer = function(observableFactory) {
        return new AnonymousObservable(function(observer) {
          var result;
          try {
            result = observableFactory();
          } catch (e) {
            return observableThrow(e).subscribe(observer);
          }
          isPromise(result) && (result = observableFromPromise(result));
          return result.subscribe(observer);
        });
      };
      var EmptyObservable = (function(__super__) {
        inherits(EmptyObservable, __super__);
        function EmptyObservable(scheduler) {
          this.scheduler = scheduler;
          __super__.call(this);
        }
        EmptyObservable.prototype.subscribeCore = function(observer) {
          var sink = new EmptySink(observer, this);
          return sink.run();
        };
        function EmptySink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          state.onCompleted();
        }
        EmptySink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState(this.observer, scheduleItem);
        };
        return EmptyObservable;
      }(ObservableBase));
      var observableEmpty = Observable.empty = function(scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new EmptyObservable(scheduler);
      };
      var FromObservable = (function(__super__) {
        inherits(FromObservable, __super__);
        function FromObservable(iterable, mapper, scheduler) {
          this.iterable = iterable;
          this.mapper = mapper;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromObservable.prototype.subscribeCore = function(o) {
          var sink = new FromSink(o, this);
          return sink.run();
        };
        return FromObservable;
      }(ObservableBase));
      var FromSink = (function() {
        function FromSink(o, parent) {
          this.o = o;
          this.parent = parent;
        }
        FromSink.prototype.run = function() {
          var list = Object(this.parent.iterable),
              it = getIterable(list),
              o = this.o,
              mapper = this.parent.mapper;
          function loopRecursive(i, recurse) {
            var next = tryCatch(it.next).call(it);
            if (next === errorObj) {
              return o.onError(next.e);
            }
            if (next.done) {
              return o.onCompleted();
            }
            var result = next.value;
            if (isFunction(mapper)) {
              result = tryCatch(mapper)(result, i);
              if (result === errorObj) {
                return o.onError(result.e);
              }
            }
            o.onNext(result);
            recurse(i + 1);
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return FromSink;
      }());
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function StringIterable(s) {
        this._s = s;
      }
      StringIterable.prototype[$iterator$] = function() {
        return new StringIterator(this._s);
      };
      function StringIterator(s) {
        this._s = s;
        this._l = s.length;
        this._i = 0;
      }
      StringIterator.prototype[$iterator$] = function() {
        return this;
      };
      StringIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._s.charAt(this._i++)
        } : doneEnumerator;
      };
      function ArrayIterable(a) {
        this._a = a;
      }
      ArrayIterable.prototype[$iterator$] = function() {
        return new ArrayIterator(this._a);
      };
      function ArrayIterator(a) {
        this._a = a;
        this._l = toLength(a);
        this._i = 0;
      }
      ArrayIterator.prototype[$iterator$] = function() {
        return this;
      };
      ArrayIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._a[this._i++]
        } : doneEnumerator;
      };
      function numberIsFinite(value) {
        return typeof value === 'number' && root.isFinite(value);
      }
      function isNan(n) {
        return n !== n;
      }
      function getIterable(o) {
        var i = o[$iterator$],
            it;
        if (!i && typeof o === 'string') {
          it = new StringIterable(o);
          return it[$iterator$]();
        }
        if (!i && o.length !== undefined) {
          it = new ArrayIterable(o);
          return it[$iterator$]();
        }
        if (!i) {
          throw new TypeError('Object is not iterable');
        }
        return o[$iterator$]();
      }
      function sign(value) {
        var number = +value;
        if (number === 0) {
          return number;
        }
        if (isNaN(number)) {
          return number;
        }
        return number < 0 ? -1 : 1;
      }
      function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) {
          return 0;
        }
        if (len === 0 || !numberIsFinite(len)) {
          return len;
        }
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) {
          return 0;
        }
        if (len > maxSafeInteger) {
          return maxSafeInteger;
        }
        return len;
      }
      var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
        if (iterable == null) {
          throw new Error('iterable cannot be null.');
        }
        if (mapFn && !isFunction(mapFn)) {
          throw new Error('mapFn when provided must be a function');
        }
        if (mapFn) {
          var mapper = bindCallback(mapFn, thisArg, 2);
        }
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromObservable(iterable, mapper, scheduler);
      };
      var FromArrayObservable = (function(__super__) {
        inherits(FromArrayObservable, __super__);
        function FromArrayObservable(args, scheduler) {
          this.args = args;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromArrayObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromArraySink(observer, this);
          return sink.run();
        };
        return FromArrayObservable;
      }(ObservableBase));
      function FromArraySink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      FromArraySink.prototype.run = function() {
        var observer = this.observer,
            args = this.parent.args,
            len = args.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            observer.onNext(args[i]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      var observableFromArray = Observable.fromArray = function(array, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      };
      Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new AnonymousObservable(function(o) {
          var first = true;
          return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
            var hasResult,
                result;
            try {
              if (first) {
                first = false;
              } else {
                state = iterate(state);
              }
              hasResult = condition(state);
              hasResult && (result = resultSelector(state));
            } catch (e) {
              return o.onError(e);
            }
            if (hasResult) {
              o.onNext(result);
              self(state);
            } else {
              o.onCompleted();
            }
          });
        });
      };
      var NeverObservable = (function(__super__) {
        inherits(NeverObservable, __super__);
        function NeverObservable() {
          __super__.call(this);
        }
        NeverObservable.prototype.subscribeCore = function(observer) {
          return disposableEmpty;
        };
        return NeverObservable;
      }(ObservableBase));
      var observableNever = Observable.never = function() {
        return new NeverObservable();
      };
      function observableOf(scheduler, array) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      }
      Observable.of = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new FromArrayObservable(args, currentThreadScheduler);
      };
      Observable.ofWithScheduler = function(scheduler) {
        var len = arguments.length,
            args = new Array(len - 1);
        for (var i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }
        return new FromArrayObservable(args, scheduler);
      };
      var PairsObservable = (function(__super__) {
        inherits(PairsObservable, __super__);
        function PairsObservable(obj, scheduler) {
          this.obj = obj;
          this.keys = Object.keys(obj);
          this.scheduler = scheduler;
          __super__.call(this);
        }
        PairsObservable.prototype.subscribeCore = function(observer) {
          var sink = new PairsSink(observer, this);
          return sink.run();
        };
        return PairsObservable;
      }(ObservableBase));
      function PairsSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      PairsSink.prototype.run = function() {
        var observer = this.observer,
            obj = this.parent.obj,
            keys = this.parent.keys,
            len = keys.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            var key = keys[i];
            observer.onNext([key, obj[key]]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      Observable.pairs = function(obj, scheduler) {
        scheduler || (scheduler = currentThreadScheduler);
        return new PairsObservable(obj, scheduler);
      };
      var RangeObservable = (function(__super__) {
        inherits(RangeObservable, __super__);
        function RangeObservable(start, count, scheduler) {
          this.start = start;
          this.rangeCount = count;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RangeObservable.prototype.subscribeCore = function(observer) {
          var sink = new RangeSink(observer, this);
          return sink.run();
        };
        return RangeObservable;
      }(ObservableBase));
      var RangeSink = (function() {
        function RangeSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        RangeSink.prototype.run = function() {
          var start = this.parent.start,
              count = this.parent.rangeCount,
              observer = this.observer;
          function loopRecursive(i, recurse) {
            if (i < count) {
              observer.onNext(start + i);
              recurse(i + 1);
            } else {
              observer.onCompleted();
            }
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return RangeSink;
      }());
      Observable.range = function(start, count, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RangeObservable(start, count, scheduler);
      };
      var RepeatObservable = (function(__super__) {
        inherits(RepeatObservable, __super__);
        function RepeatObservable(value, repeatCount, scheduler) {
          this.value = value;
          this.repeatCount = repeatCount == null ? -1 : repeatCount;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RepeatObservable.prototype.subscribeCore = function(observer) {
          var sink = new RepeatSink(observer, this);
          return sink.run();
        };
        return RepeatObservable;
      }(ObservableBase));
      function RepeatSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      RepeatSink.prototype.run = function() {
        var observer = this.observer,
            value = this.parent.value;
        function loopRecursive(i, recurse) {
          if (i === -1 || i > 0) {
            observer.onNext(value);
            i > 0 && i--;
          }
          if (i === 0) {
            return observer.onCompleted();
          }
          recurse(i);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount, loopRecursive);
      };
      Observable.repeat = function(value, repeatCount, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RepeatObservable(value, repeatCount, scheduler);
      };
      var JustObservable = (function(__super__) {
        inherits(JustObservable, __super__);
        function JustObservable(value, scheduler) {
          this.value = value;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        JustObservable.prototype.subscribeCore = function(observer) {
          var sink = new JustSink(observer, this);
          return sink.run();
        };
        function JustSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          var value = state[0],
              observer = state[1];
          observer.onNext(value);
          observer.onCompleted();
        }
        JustSink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState([this.parent.value, this.observer], scheduleItem);
        };
        return JustObservable;
      }(ObservableBase));
      var observableReturn = Observable['return'] = Observable.just = function(value, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new JustObservable(value, scheduler);
      };
      var ThrowObservable = (function(__super__) {
        inherits(ThrowObservable, __super__);
        function ThrowObservable(error, scheduler) {
          this.error = error;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        ThrowObservable.prototype.subscribeCore = function(o) {
          var sink = new ThrowSink(o, this);
          return sink.run();
        };
        function ThrowSink(o, p) {
          this.o = o;
          this.p = p;
        }
        function scheduleItem(s, state) {
          var e = state[0],
              o = state[1];
          o.onError(e);
        }
        ThrowSink.prototype.run = function() {
          return this.p.scheduler.scheduleWithState([this.p.error, this.o], scheduleItem);
        };
        return ThrowObservable;
      }(ObservableBase));
      var observableThrow = Observable['throw'] = function(error, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new ThrowObservable(error, scheduler);
      };
      Observable.using = function(resourceFactory, observableFactory) {
        return new AnonymousObservable(function(o) {
          var disposable = disposableEmpty;
          var resource = tryCatch(resourceFactory)();
          if (resource === errorObj) {
            return new CompositeDisposable(observableThrow(resource.e).subscribe(o), disposable);
          }
          resource && (disposable = resource);
          var source = tryCatch(observableFactory)(resource);
          if (source === errorObj) {
            return new CompositeDisposable(observableThrow(source.e).subscribe(o), disposable);
          }
          return new CompositeDisposable(source.subscribe(o), disposable);
        });
      };
      observableProto.amb = function(rightSource) {
        var leftSource = this;
        return new AnonymousObservable(function(observer) {
          var choice,
              leftChoice = 'L',
              rightChoice = 'R',
              leftSubscription = new SingleAssignmentDisposable(),
              rightSubscription = new SingleAssignmentDisposable();
          isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
          function choiceL() {
            if (!choice) {
              choice = leftChoice;
              rightSubscription.dispose();
            }
          }
          function choiceR() {
            if (!choice) {
              choice = rightChoice;
              leftSubscription.dispose();
            }
          }
          var leftSubscribe = observerCreate(function(left) {
            choiceL();
            choice === leftChoice && observer.onNext(left);
          }, function(e) {
            choiceL();
            choice === leftChoice && observer.onError(e);
          }, function() {
            choiceL();
            choice === leftChoice && observer.onCompleted();
          });
          var rightSubscribe = observerCreate(function(right) {
            choiceR();
            choice === rightChoice && observer.onNext(right);
          }, function(e) {
            choiceR();
            choice === rightChoice && observer.onError(e);
          }, function() {
            choiceR();
            choice === rightChoice && observer.onCompleted();
          });
          leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));
          rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));
          return new CompositeDisposable(leftSubscription, rightSubscription);
        });
      };
      function amb(p, c) {
        return p.amb(c);
      }
      Observable.amb = function() {
        var acc = observableNever(),
            items;
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          var len = arguments.length;
          items = new Array(items);
          for (var i = 0; i < len; i++) {
            items[i] = arguments[i];
          }
        }
        for (var i = 0,
            len = items.length; i < len; i++) {
          acc = amb(acc, items[i]);
        }
        return acc;
      };
      var CatchObserver = (function(__super__) {
        inherits(CatchObserver, __super__);
        function CatchObserver(o, s, fn) {
          this._o = o;
          this._s = s;
          this._fn = fn;
          __super__.call(this);
        }
        CatchObserver.prototype.next = function(x) {
          this._o.onNext(x);
        };
        CatchObserver.prototype.completed = function() {
          return this._o.onCompleted();
        };
        CatchObserver.prototype.error = function(e) {
          var result = tryCatch(this._fn)(e);
          if (result === errorObj) {
            return this._o.onError(result.e);
          }
          isPromise(result) && (result = observableFromPromise(result));
          var d = new SingleAssignmentDisposable();
          this._s.setDisposable(d);
          d.setDisposable(result.subscribe(this._o));
        };
        return CatchObserver;
      }(AbstractObserver));
      function observableCatchHandler(source, handler) {
        return new AnonymousObservable(function(o) {
          var d1 = new SingleAssignmentDisposable(),
              subscription = new SerialDisposable();
          subscription.setDisposable(d1);
          d1.setDisposable(source.subscribe(new CatchObserver(o, subscription, handler)));
          return subscription;
        }, source);
      }
      observableProto['catch'] = function(handlerOrSecond) {
        return isFunction(handlerOrSecond) ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
      };
      var observableCatch = Observable['catch'] = function() {
        var items;
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          var len = arguments.length;
          items = new Array(len);
          for (var i = 0; i < len; i++) {
            items[i] = arguments[i];
          }
        }
        return enumerableOf(items).catchError();
      };
      observableProto.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
          args[0].unshift(this);
        } else {
          args.unshift(this);
        }
        return combineLatest.apply(this, args);
      };
      var combineLatest = Observable.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop();
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              falseFactory = function() {
                return false;
              },
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              isDone = arrayInitialize(n, falseFactory),
              values = new Array(n);
          function next(i) {
            hasValue[i] = true;
            if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
              try {
                var res = resultSelector.apply(null, values);
              } catch (e) {
                return o.onError(e);
              }
              o.onNext(res);
            } else if (isDone.filter(function(x, j) {
              return j !== i;
            }).every(identity)) {
              o.onCompleted();
            }
          }
          function done(i) {
            isDone[i] = true;
            isDone.every(identity) && o.onCompleted();
          }
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                values[i] = x;
                next(i);
              }, function(e) {
                o.onError(e);
              }, function() {
                done(i);
              }));
              subscriptions[i] = sad;
            }(idx));
          }
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      observableProto.concat = function() {
        for (var args = [],
            i = 0,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args.unshift(this);
        return observableConcat.apply(null, args);
      };
      var ConcatObservable = (function(__super__) {
        inherits(ConcatObservable, __super__);
        function ConcatObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatObservable.prototype.subscribeCore = function(o) {
          var sink = new ConcatSink(this.sources, o);
          return sink.run();
        };
        function ConcatSink(sources, o) {
          this.sources = sources;
          this.o = o;
        }
        ConcatSink.prototype.run = function() {
          var isDisposed,
              subscription = new SerialDisposable(),
              sources = this.sources,
              length = sources.length,
              o = this.o;
          var cancelable = immediateScheduler.scheduleRecursiveWithState(0, function(i, self) {
            if (isDisposed) {
              return ;
            }
            if (i === length) {
              return o.onCompleted();
            }
            var currentValue = sources[i];
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              o.onError(e);
            }, function() {
              self(i + 1);
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return ConcatObservable;
      }(ObservableBase));
      var observableConcat = Observable.concat = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(arguments.length);
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ConcatObservable(args);
      };
      observableProto.concatAll = function() {
        return this.merge(1);
      };
      var MergeObservable = (function(__super__) {
        inherits(MergeObservable, __super__);
        function MergeObservable(source, maxConcurrent) {
          this.source = source;
          this.maxConcurrent = maxConcurrent;
          __super__.call(this);
        }
        MergeObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable();
          g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
          return g;
        };
        return MergeObservable;
      }(ObservableBase));
      var MergeObserver = (function() {
        function MergeObserver(o, max, g) {
          this.o = o;
          this.max = max;
          this.g = g;
          this.done = false;
          this.q = [];
          this.activeCount = 0;
          this.isStopped = false;
        }
        MergeObserver.prototype.handleSubscribe = function(xs) {
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(xs) && (xs = observableFromPromise(xs));
          sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
        };
        MergeObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          if (this.activeCount < this.max) {
            this.activeCount++;
            this.handleSubscribe(innerSource);
          } else {
            this.q.push(innerSource);
          }
        };
        MergeObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.activeCount === 0 && this.o.onCompleted();
          }
        };
        MergeObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, sad) {
          this.parent = parent;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var parent = this.parent;
            parent.g.remove(this.sad);
            if (parent.q.length > 0) {
              parent.handleSubscribe(parent.q.shift());
            } else {
              parent.activeCount--;
              parent.done && parent.activeCount === 0 && parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeObserver;
      }());
      observableProto.merge = function(maxConcurrentOrOther) {
        return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
      };
      var observableMerge = Observable.merge = function() {
        var scheduler,
            sources = [],
            i,
            len = arguments.length;
        if (!arguments[0]) {
          scheduler = immediateScheduler;
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else if (isScheduler(arguments[0])) {
          scheduler = arguments[0];
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else {
          scheduler = immediateScheduler;
          for (i = 0; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        if (Array.isArray(sources[0])) {
          sources = sources[0];
        }
        return observableOf(scheduler, sources).mergeAll();
      };
      var CompositeError = Rx.CompositeError = function(errors) {
        this.name = "NotImplementedError";
        this.innerErrors = errors;
        this.message = 'This contains multiple errors. Check the innerErrors';
        Error.call(this);
      };
      CompositeError.prototype = Error.prototype;
      Observable.mergeDelayError = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          var len = arguments.length;
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        var source = observableOf(null, args);
        return new AnonymousObservable(function(o) {
          var group = new CompositeDisposable(),
              m = new SingleAssignmentDisposable(),
              isStopped = false,
              errors = [];
          function setCompletion() {
            if (errors.length === 0) {
              o.onCompleted();
            } else if (errors.length === 1) {
              o.onError(errors[0]);
            } else {
              o.onError(new CompositeError(errors));
            }
          }
          group.add(m);
          m.setDisposable(source.subscribe(function(innerSource) {
            var innerSubscription = new SingleAssignmentDisposable();
            group.add(innerSubscription);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              errors.push(e);
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }, function() {
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }));
          }, function(e) {
            errors.push(e);
            isStopped = true;
            group.length === 1 && setCompletion();
          }, function() {
            isStopped = true;
            group.length === 1 && setCompletion();
          }));
          return group;
        });
      };
      var MergeAllObservable = (function(__super__) {
        inherits(MergeAllObservable, __super__);
        function MergeAllObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        MergeAllObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable(),
              m = new SingleAssignmentDisposable();
          g.add(m);
          m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
          return g;
        };
        function MergeAllObserver(o, g) {
          this.o = o;
          this.g = g;
          this.isStopped = false;
          this.done = false;
        }
        MergeAllObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));
        };
        MergeAllObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeAllObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.g.length === 1 && this.o.onCompleted();
          }
        };
        MergeAllObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeAllObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, sad) {
          this.parent = parent;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            var parent = this.parent;
            this.isStopped = true;
            parent.g.remove(this.sad);
            parent.done && parent.g.length === 1 && parent.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeAllObservable;
      }(ObservableBase));
      observableProto.mergeAll = function() {
        return new MergeAllObservable(this);
      };
      observableProto.onErrorResumeNext = function(second) {
        if (!second) {
          throw new Error('Second observable is required');
        }
        return onErrorResumeNext([this, second]);
      };
      var onErrorResumeNext = Observable.onErrorResumeNext = function() {
        var sources = [];
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        return new AnonymousObservable(function(observer) {
          var pos = 0,
              subscription = new SerialDisposable(),
              cancelable = immediateScheduler.scheduleRecursive(function(self) {
                var current,
                    d;
                if (pos < sources.length) {
                  current = sources[pos++];
                  isPromise(current) && (current = observableFromPromise(current));
                  d = new SingleAssignmentDisposable();
                  subscription.setDisposable(d);
                  d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
                } else {
                  observer.onCompleted();
                }
              });
          return new CompositeDisposable(subscription, cancelable);
        });
      };
      observableProto.skipUntil = function(other) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var isOpen = false;
          var disposables = new CompositeDisposable(source.subscribe(function(left) {
            isOpen && o.onNext(left);
          }, function(e) {
            o.onError(e);
          }, function() {
            isOpen && o.onCompleted();
          }));
          isPromise(other) && (other = observableFromPromise(other));
          var rightSubscription = new SingleAssignmentDisposable();
          disposables.add(rightSubscription);
          rightSubscription.setDisposable(other.subscribe(function() {
            isOpen = true;
            rightSubscription.dispose();
          }, function(e) {
            o.onError(e);
          }, function() {
            rightSubscription.dispose();
          }));
          return disposables;
        }, source);
      };
      var SwitchObservable = (function(__super__) {
        inherits(SwitchObservable, __super__);
        function SwitchObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        SwitchObservable.prototype.subscribeCore = function(o) {
          var inner = new SerialDisposable(),
              s = this.source.subscribe(new SwitchObserver(o, inner));
          return new CompositeDisposable(s, inner);
        };
        function SwitchObserver(o, inner) {
          this.o = o;
          this.inner = inner;
          this.stopped = false;
          this.latest = 0;
          this.hasLatest = false;
          this.isStopped = false;
        }
        SwitchObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          var d = new SingleAssignmentDisposable(),
              id = ++this.latest;
          this.hasLatest = true;
          this.inner.setDisposable(d);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
        };
        SwitchObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        SwitchObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.stopped = true;
            !this.hasLatest && this.o.onCompleted();
          }
        };
        SwitchObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        SwitchObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, id) {
          this.parent = parent;
          this.id = id;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          this.parent.latest === this.id && this.parent.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.latest === this.id && this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            if (this.parent.latest === this.id) {
              this.parent.hasLatest = false;
              this.parent.isStopped && this.parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return SwitchObservable;
      }(ObservableBase));
      observableProto['switch'] = observableProto.switchLatest = function() {
        return new SwitchObservable(this);
      };
      var TakeUntilObservable = (function(__super__) {
        inherits(TakeUntilObservable, __super__);
        function TakeUntilObservable(source, other) {
          this.source = source;
          this.other = isPromise(other) ? observableFromPromise(other) : other;
          __super__.call(this);
        }
        TakeUntilObservable.prototype.subscribeCore = function(o) {
          return new CompositeDisposable(this.source.subscribe(o), this.other.subscribe(new InnerObserver(o)));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          this.o.onCompleted();
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          !this.isStopped && (this.isStopped = true);
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TakeUntilObservable;
      }(ObservableBase));
      observableProto.takeUntil = function(other) {
        return new TakeUntilObservable(this, other);
      };
      function falseFactory() {
        return false;
      }
      observableProto.withLatestFrom = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop(),
            source = this;
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(observer) {
          var n = args.length,
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              values = new Array(n);
          var subscriptions = new Array(n + 1);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var other = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(other) && (other = observableFromPromise(other));
              sad.setDisposable(other.subscribe(function(x) {
                values[i] = x;
                hasValue[i] = true;
                hasValueAll = hasValue.every(identity);
              }, function(e) {
                observer.onError(e);
              }, noop));
              subscriptions[i] = sad;
            }(idx));
          }
          var sad = new SingleAssignmentDisposable();
          sad.setDisposable(source.subscribe(function(x) {
            var allValues = [x].concat(values);
            if (!hasValueAll) {
              return ;
            }
            var res = tryCatch(resultSelector).apply(null, allValues);
            if (res === errorObj) {
              return observer.onError(res.e);
            }
            observer.onNext(res);
          }, function(e) {
            observer.onError(e);
          }, function() {
            observer.onCompleted();
          }));
          subscriptions[n] = sad;
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      function zipArray(second, resultSelector) {
        var first = this;
        return new AnonymousObservable(function(o) {
          var index = 0,
              len = second.length;
          return first.subscribe(function(left) {
            if (index < len) {
              var right = second[index++],
                  res = tryCatch(resultSelector)(left, right);
              if (res === errorObj) {
                return o.onError(res.e);
              }
              o.onNext(res);
            } else {
              o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, first);
      }
      function falseFactory() {
        return false;
      }
      function emptyArrayFactory() {
        return [];
      }
      observableProto.zip = function() {
        if (Array.isArray(arguments[0])) {
          return zipArray.apply(this, arguments);
        }
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var parent = this,
            resultSelector = args.pop();
        args.unshift(parent);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              queues = arrayInitialize(n, emptyArrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var queuedValues = queues.map(function(x) {
                    return x.shift();
                  }),
                      res = tryCatch(resultSelector).apply(parent, queuedValues);
                  if (res === errorObj) {
                    return o.onError(res.e);
                  }
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
              subscriptions[i] = sad;
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        }, parent);
      };
      Observable.zip = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var first = args.shift();
        return first.zip.apply(first, args);
      };
      function falseFactory() {
        return false;
      }
      function arrayFactory() {
        return [];
      }
      Observable.zipArray = function() {
        var sources;
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          var len = arguments.length;
          sources = new Array(len);
          for (var i = 0; i < len; i++) {
            sources[i] = arguments[i];
          }
        }
        return new AnonymousObservable(function(o) {
          var n = sources.length,
              queues = arrayInitialize(n, arrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              subscriptions[i] = new SingleAssignmentDisposable();
              subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var res = queues.map(function(x) {
                    return x.shift();
                  });
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  return o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        });
      };
      function asObservable(source) {
        return function subscribe(o) {
          return source.subscribe(o);
        };
      }
      observableProto.asObservable = function() {
        return new AnonymousObservable(asObservable(this), this);
      };
      function toArray(x) {
        return x.toArray();
      }
      function notEmpty(x) {
        return x.length > 0;
      }
      observableProto.bufferWithCount = function(count, skip) {
        typeof skip !== 'number' && (skip = count);
        return this.windowWithCount(count, skip).flatMap(toArray).filter(notEmpty);
      };
      observableProto.dematerialize = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(function(x) {
            return x.accept(o);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var DistinctUntilChangedObservable = (function(__super__) {
        inherits(DistinctUntilChangedObservable, __super__);
        function DistinctUntilChangedObservable(source, keyFn, comparer) {
          this.source = source;
          this.keyFn = keyFn;
          this.comparer = comparer;
          __super__.call(this);
        }
        DistinctUntilChangedObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));
        };
        return DistinctUntilChangedObservable;
      }(ObservableBase));
      function DistinctUntilChangedObserver(o, keyFn, comparer) {
        this.o = o;
        this.keyFn = keyFn;
        this.comparer = comparer;
        this.hasCurrentKey = false;
        this.currentKey = null;
        this.isStopped = false;
      }
      DistinctUntilChangedObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return ;
        }
        var key = x;
        if (isFunction(this.keyFn)) {
          key = tryCatch(this.keyFn)(x);
          if (key === errorObj) {
            return this.o.onError(key.e);
          }
        }
        if (this.hasCurrentKey) {
          comparerEquals = tryCatch(this.comparer)(this.currentKey, key);
          if (comparerEquals === errorObj) {
            return this.o.onError(comparerEquals.e);
          }
        }
        if (!this.hasCurrentKey || !comparerEquals) {
          this.hasCurrentKey = true;
          this.currentKey = key;
          this.o.onNext(x);
        }
      };
      DistinctUntilChangedObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      DistinctUntilChangedObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onCompleted();
        }
      };
      DistinctUntilChangedObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      DistinctUntilChangedObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      observableProto.distinctUntilChanged = function(keyFn, comparer) {
        comparer || (comparer = defaultComparer);
        return new DistinctUntilChangedObservable(this, keyFn, comparer);
      };
      var TapObservable = (function(__super__) {
        inherits(TapObservable, __super__);
        function TapObservable(source, observerOrOnNext, onError, onCompleted) {
          this.source = source;
          this._oN = observerOrOnNext;
          this._oE = onError;
          this._oC = onCompleted;
          __super__.call(this);
        }
        TapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this));
        };
        function InnerObserver(o, p) {
          this.o = o;
          this.t = !p._oN || isFunction(p._oN) ? observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) : p._oN;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var res = tryCatch(this.t.onNext).call(this.t, x);
          if (res === errorObj) {
            this.o.onError(res.e);
          }
          this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onError).call(this.t, err);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onCompleted).call(this.t);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TapObservable;
      }(ObservableBase));
      observableProto['do'] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
        return new TapObservable(this, observerOrOnNext, onError, onCompleted);
      };
      observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
        return this.tap(typeof thisArg !== 'undefined' ? function(x) {
          onNext.call(thisArg, x);
        } : onNext);
      };
      observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
        return this.tap(noop, typeof thisArg !== 'undefined' ? function(e) {
          onError.call(thisArg, e);
        } : onError);
      };
      observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
        return this.tap(noop, null, typeof thisArg !== 'undefined' ? function() {
          onCompleted.call(thisArg);
        } : onCompleted);
      };
      observableProto['finally'] = observableProto.ensure = function(action) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var subscription = tryCatch(source.subscribe).call(source, observer);
          if (subscription === errorObj) {
            action();
            return thrower(subscription.e);
          }
          return disposableCreate(function() {
            var r = tryCatch(subscription.dispose).call(subscription);
            action();
            r === errorObj && thrower(r.e);
          });
        }, this);
      };
      var IgnoreElementsObservable = (function(__super__) {
        inherits(IgnoreElementsObservable, __super__);
        function IgnoreElementsObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        IgnoreElementsObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = noop;
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e);
            return true;
          }
          return false;
        };
        return IgnoreElementsObservable;
      }(ObservableBase));
      observableProto.ignoreElements = function() {
        return new IgnoreElementsObservable(this);
      };
      observableProto.materialize = function() {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(function(value) {
            observer.onNext(notificationCreateOnNext(value));
          }, function(e) {
            observer.onNext(notificationCreateOnError(e));
            observer.onCompleted();
          }, function() {
            observer.onNext(notificationCreateOnCompleted());
            observer.onCompleted();
          });
        }, source);
      };
      observableProto.repeat = function(repeatCount) {
        return enumerableRepeat(this, repeatCount).concat();
      };
      observableProto.retry = function(retryCount) {
        return enumerableRepeat(this, retryCount).catchError();
      };
      observableProto.retryWhen = function(notifier) {
        return enumerableRepeat(this).catchErrorWhen(notifier);
      };
      var ScanObservable = (function(__super__) {
        inherits(ScanObservable, __super__);
        function ScanObservable(source, accumulator, hasSeed, seed) {
          this.source = source;
          this.accumulator = accumulator;
          this.hasSeed = hasSeed;
          this.seed = seed;
          __super__.call(this);
        }
        ScanObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this));
        };
        return ScanObservable;
      }(ObservableBase));
      function InnerObserver(o, parent) {
        this.o = o;
        this.accumulator = parent.accumulator;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.accumulation = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      InnerObserver.prototype = {
        onNext: function(x) {
          if (this.isStopped) {
            return ;
          }
          !this.hasValue && (this.hasValue = true);
          if (this.hasAccumulation) {
            this.accumulation = tryCatch(this.accumulator)(this.accumulation, x);
          } else {
            this.accumulation = this.hasSeed ? tryCatch(this.accumulator)(this.seed, x) : x;
            this.hasAccumulation = true;
          }
          if (this.accumulation === errorObj) {
            return this.o.onError(this.accumulation.e);
          }
          this.o.onNext(this.accumulation);
        },
        onError: function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        },
        onCompleted: function() {
          if (!this.isStopped) {
            this.isStopped = true;
            !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
            this.o.onCompleted();
          }
        },
        dispose: function() {
          this.isStopped = true;
        },
        fail: function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        }
      };
      observableProto.scan = function() {
        var hasSeed = false,
            seed,
            accumulator = arguments[0];
        if (arguments.length === 2) {
          hasSeed = true;
          seed = arguments[1];
        }
        return new ScanObservable(this, accumulator, hasSeed, seed);
      };
      observableProto.skipLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && o.onNext(q.shift());
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.startWith = function() {
        var values,
            scheduler,
            start = 0;
        if (!!arguments.length && isScheduler(arguments[0])) {
          scheduler = arguments[0];
          start = 1;
        } else {
          scheduler = immediateScheduler;
        }
        for (var args = [],
            i = start,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return enumerableOf([observableFromArray(args, scheduler), this]).concat();
      };
      observableProto.takeLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            while (q.length > 0) {
              o.onNext(q.shift());
            }
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeLastBuffer = function(count) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onNext(q);
            o.onCompleted();
          });
        }, source);
      };
      observableProto.windowWithCount = function(count, skip) {
        var source = this;
        +count || (count = 0);
        Math.abs(count) === Infinity && (count = 0);
        if (count <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        skip == null && (skip = count);
        +skip || (skip = 0);
        Math.abs(skip) === Infinity && (skip = 0);
        if (skip <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              refCountDisposable = new RefCountDisposable(m),
              n = 0,
              q = [];
          function createWindow() {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          createWindow();
          m.setDisposable(source.subscribe(function(x) {
            for (var i = 0,
                len = q.length; i < len; i++) {
              q[i].onNext(x);
            }
            var c = n - count + 1;
            c >= 0 && c % skip === 0 && q.shift().onCompleted();
            ++n % skip === 0 && createWindow();
          }, function(e) {
            while (q.length > 0) {
              q.shift().onError(e);
            }
            observer.onError(e);
          }, function() {
            while (q.length > 0) {
              q.shift().onCompleted();
            }
            observer.onCompleted();
          }));
          return refCountDisposable;
        }, source);
      };
      observableProto.flatMapConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(1);
      };
      observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this,
            onNextFunc = bindCallback(onNext, thisArg, 2),
            onErrorFunc = bindCallback(onError, thisArg, 1),
            onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNextFunc(x, index++);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onErrorFunc(err);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompletedFunc();
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, this).concatAll();
      };
      observableProto.defaultIfEmpty = function(defaultValue) {
        var source = this;
        defaultValue === undefined && (defaultValue = null);
        return new AnonymousObservable(function(observer) {
          var found = false;
          return source.subscribe(function(x) {
            found = true;
            observer.onNext(x);
          }, function(e) {
            observer.onError(e);
          }, function() {
            !found && observer.onNext(defaultValue);
            observer.onCompleted();
          });
        }, source);
      };
      function arrayIndexOfComparer(array, item, comparer) {
        for (var i = 0,
            len = array.length; i < len; i++) {
          if (comparer(array[i], item)) {
            return i;
          }
        }
        return -1;
      }
      function HashSet(comparer) {
        this.comparer = comparer;
        this.set = [];
      }
      HashSet.prototype.push = function(value) {
        var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
        retValue && this.set.push(value);
        return retValue;
      };
      observableProto.distinct = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hashSet = new HashSet(comparer);
          return source.subscribe(function(x) {
            var key = x;
            if (keySelector) {
              try {
                key = keySelector(x);
              } catch (e) {
                o.onError(e);
                return ;
              }
            }
            hashSet.push(key) && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var MapObservable = (function(__super__) {
        inherits(MapObservable, __super__);
        function MapObservable(source, selector, thisArg) {
          this.source = source;
          this.selector = bindCallback(selector, thisArg, 3);
          __super__.call(this);
        }
        function innerMap(selector, self) {
          return function(x, i, o) {
            return selector.call(this, self.selector(x, i, o), i, o);
          };
        }
        MapObservable.prototype.internalMap = function(selector, thisArg) {
          return new MapObservable(this.source, innerMap(selector, this), thisArg);
        };
        MapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.selector, this));
        };
        function InnerObserver(o, selector, source) {
          this.o = o;
          this.selector = selector;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var result = tryCatch(this.selector)(x, this.i++, this.source);
          if (result === errorObj) {
            return this.o.onError(result.e);
          }
          this.o.onNext(result);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return MapObservable;
      }(ObservableBase));
      observableProto.map = observableProto.select = function(selector, thisArg) {
        var selectorFn = typeof selector === 'function' ? selector : function() {
          return selector;
        };
        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
      };
      function plucker(args, len) {
        return function mapper(x) {
          var currentProp = x;
          for (var i = 0; i < len; i++) {
            var p = currentProp[args[i]];
            if (typeof p !== 'undefined') {
              currentProp = p;
            } else {
              return undefined;
            }
          }
          return currentProp;
        };
      }
      observableProto.pluck = function() {
        var len = arguments.length,
            args = new Array(len);
        if (len === 0) {
          throw new Error('List of properties cannot be empty.');
        }
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return this.map(plucker(args, len));
      };
      observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNext.call(thisArg, x, index++);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onError.call(thisArg, err);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompleted.call(thisArg);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, source).mergeAll();
      };
      observableProto.flatMap = observableProto.selectMany = function(selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
      };
      Rx.Observable.prototype.flatMapLatest = function(selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
      };
      var SkipObservable = (function(__super__) {
        inherits(SkipObservable, __super__);
        function SkipObservable(source, count) {
          this.source = source;
          this.skipCount = count;
          __super__.call(this);
        }
        SkipObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.skipCount));
        };
        function InnerObserver(o, c) {
          this.c = c;
          this.r = c;
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          if (this.r <= 0) {
            this.o.onNext(x);
          } else {
            this.r--;
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return SkipObservable;
      }(ObservableBase));
      observableProto.skip = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new SkipObservable(this, count);
      };
      observableProto.skipWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = false;
          return source.subscribe(function(x) {
            if (!running) {
              try {
                running = !callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return ;
              }
            }
            running && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.take = function(count, scheduler) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (count === 0) {
          return observableEmpty(scheduler);
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var remaining = count;
          return source.subscribe(function(x) {
            if (remaining-- > 0) {
              o.onNext(x);
              remaining <= 0 && o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = true;
          return source.subscribe(function(x) {
            if (running) {
              try {
                running = callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return ;
              }
              if (running) {
                o.onNext(x);
              } else {
                o.onCompleted();
              }
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      var FilterObservable = (function(__super__) {
        inherits(FilterObservable, __super__);
        function FilterObservable(source, predicate, thisArg) {
          this.source = source;
          this.predicate = bindCallback(predicate, thisArg, 3);
          __super__.call(this);
        }
        FilterObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.predicate, this));
        };
        function innerPredicate(predicate, self) {
          return function(x, i, o) {
            return self.predicate(x, i, o) && predicate.call(this, x, i, o);
          };
        }
        FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
          return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
        };
        function InnerObserver(o, predicate, source) {
          this.o = o;
          this.predicate = predicate;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
          if (shouldYield === errorObj) {
            return this.o.onError(shouldYield.e);
          }
          shouldYield && this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return FilterObservable;
      }(ObservableBase));
      observableProto.filter = observableProto.where = function(predicate, thisArg) {
        return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
      };
      observableProto.transduce = function(transducer) {
        var source = this;
        function transformForObserver(o) {
          return {
            '@@transducer/init': function() {
              return o;
            },
            '@@transducer/step': function(obs, input) {
              return obs.onNext(input);
            },
            '@@transducer/result': function(obs) {
              return obs.onCompleted();
            }
          };
        }
        return new AnonymousObservable(function(o) {
          var xform = transducer(transformForObserver(o));
          return source.subscribe(function(v) {
            var res = tryCatch(xform['@@transducer/step']).call(xform, o, v);
            if (res === errorObj) {
              o.onError(res.e);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            xform['@@transducer/result'](o);
          });
        }, source);
      };
      var AnonymousObservable = Rx.AnonymousObservable = (function(__super__) {
        inherits(AnonymousObservable, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              self = state[1];
          var sub = tryCatch(self.__subscribe).call(self, ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function innerSubscribe(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, this];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        function AnonymousObservable(subscribe, parent) {
          this.source = parent;
          this.__subscribe = subscribe;
          __super__.call(this, innerSubscribe);
        }
        return AnonymousObservable;
      }(Observable));
      var AutoDetachObserver = (function(__super__) {
        inherits(AutoDetachObserver, __super__);
        function AutoDetachObserver(observer) {
          __super__.call(this);
          this.observer = observer;
          this.m = new SingleAssignmentDisposable();
        }
        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
        AutoDetachObserverPrototype.next = function(value) {
          var result = tryCatch(this.observer.onNext).call(this.observer, value);
          if (result === errorObj) {
            this.dispose();
            thrower(result.e);
          }
        };
        AutoDetachObserverPrototype.error = function(err) {
          var result = tryCatch(this.observer.onError).call(this.observer, err);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.completed = function() {
          var result = tryCatch(this.observer.onCompleted).call(this.observer);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.setDisposable = function(value) {
          this.m.setDisposable(value);
        };
        AutoDetachObserverPrototype.getDisposable = function() {
          return this.m.getDisposable();
        };
        AutoDetachObserverPrototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.m.dispose();
        };
        return AutoDetachObserver;
      }(AbstractObserver));
      var InnerSubscription = function(subject, observer) {
        this.subject = subject;
        this.observer = observer;
      };
      InnerSubscription.prototype.dispose = function() {
        if (!this.subject.isDisposed && this.observer !== null) {
          var idx = this.subject.observers.indexOf(this.observer);
          this.subject.observers.splice(idx, 1);
          this.observer = null;
        }
      };
      var Subject = Rx.Subject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
            return disposableEmpty;
          }
          observer.onCompleted();
          return disposableEmpty;
        }
        inherits(Subject, __super__);
        function Subject() {
          __super__.call(this, subscribe);
          this.isDisposed = false, this.isStopped = false, this.observers = [];
          this.hasError = false;
        }
        addProperties(Subject.prototype, Observer.prototype, {
          hasObservers: function() {
            return this.observers.length > 0;
          },
          onCompleted: function() {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onCompleted();
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.error = error;
              this.hasError = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (!this.isStopped) {
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onNext(value);
              }
            }
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
          }
        });
        Subject.create = function(observer, observable) {
          return new AnonymousSubject(observer, observable);
        };
        return Subject;
      }(Observable));
      var AsyncSubject = Rx.AsyncSubject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
          } else if (this.hasValue) {
            observer.onNext(this.value);
            observer.onCompleted();
          } else {
            observer.onCompleted();
          }
          return disposableEmpty;
        }
        inherits(AsyncSubject, __super__);
        function AsyncSubject() {
          __super__.call(this, subscribe);
          this.isDisposed = false;
          this.isStopped = false;
          this.hasValue = false;
          this.observers = [];
          this.hasError = false;
        }
        addProperties(AsyncSubject.prototype, Observer, {
          hasObservers: function() {
            checkDisposed(this);
            return this.observers.length > 0;
          },
          onCompleted: function() {
            var i,
                len;
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              var os = cloneArray(this.observers),
                  len = os.length;
              if (this.hasValue) {
                for (i = 0; i < len; i++) {
                  var o = os[i];
                  o.onNext(this.value);
                  o.onCompleted();
                }
              } else {
                for (i = 0; i < len; i++) {
                  os[i].onCompleted();
                }
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.hasError = true;
              this.error = error;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (this.isStopped) {
              return ;
            }
            this.value = value;
            this.hasValue = true;
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
            this.exception = null;
            this.value = null;
          }
        });
        return AsyncSubject;
      }(Observable));
      var AnonymousSubject = Rx.AnonymousSubject = (function(__super__) {
        inherits(AnonymousSubject, __super__);
        function subscribe(observer) {
          return this.observable.subscribe(observer);
        }
        function AnonymousSubject(observer, observable) {
          this.observer = observer;
          this.observable = observable;
          __super__.call(this, subscribe);
        }
        addProperties(AnonymousSubject.prototype, Observer.prototype, {
          onCompleted: function() {
            this.observer.onCompleted();
          },
          onError: function(error) {
            this.observer.onError(error);
          },
          onNext: function(value) {
            this.observer.onNext(value);
          }
        });
        return AnonymousSubject;
      }(Observable));
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root.Rx = Rx;
        define(function() {
          return Rx;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = Rx).Rx = Rx;
        } else {
          freeExports.Rx = Rx;
        }
      } else {
        root.Rx = Rx;
      }
      var rEndingLine = captureLine();
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.aggregates", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        CompositeDisposable = Rx.CompositeDisposable,
        AnonymousObservable = Rx.AnonymousObservable,
        AbstractObserver = Rx.internals.AbstractObserver,
        disposableEmpty = Rx.Disposable.empty,
        isEqual = Rx.internals.isEqual,
        helpers = Rx.helpers,
        not = helpers.not,
        defaultComparer = helpers.defaultComparer,
        identity = helpers.identity,
        defaultSubComparer = helpers.defaultSubComparer,
        isFunction = helpers.isFunction,
        isPromise = helpers.isPromise,
        isArrayLike = helpers.isArrayLike,
        isIterable = helpers.isIterable,
        inherits = Rx.internals.inherits,
        observableFromPromise = Observable.fromPromise,
        observableFrom = Observable.from,
        bindCallback = Rx.internals.bindCallback,
        EmptyError = Rx.EmptyError,
        ObservableBase = Rx.ObservableBase,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function extremaBy(source, keySelector, comparer) {
      return new AnonymousObservable(function(o) {
        var hasValue = false,
            lastKey = null,
            list = [];
        return source.subscribe(function(x) {
          var comparison,
              key;
          try {
            key = keySelector(x);
          } catch (ex) {
            o.onError(ex);
            return ;
          }
          comparison = 0;
          if (!hasValue) {
            hasValue = true;
            lastKey = key;
          } else {
            try {
              comparison = comparer(key, lastKey);
            } catch (ex1) {
              o.onError(ex1);
              return ;
            }
          }
          if (comparison > 0) {
            lastKey = key;
            list = [];
          }
          if (comparison >= 0) {
            list.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(list);
          o.onCompleted();
        });
      }, source);
    }
    function firstOnly(x) {
      if (x.length === 0) {
        throw new EmptyError();
      }
      return x[0];
    }
    var ReduceObservable = (function(__super__) {
      inherits(ReduceObservable, __super__);
      function ReduceObservable(source, acc, hasSeed, seed) {
        this.source = source;
        this.acc = acc;
        this.hasSeed = hasSeed;
        this.seed = seed;
        __super__.call(this);
      }
      ReduceObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new InnerObserver(observer, this));
      };
      function InnerObserver(o, parent) {
        this.o = o;
        this.acc = parent.acc;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.result = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return ;
        }
        !this.hasValue && (this.hasValue = true);
        if (this.hasAccumulation) {
          this.result = tryCatch(this.acc)(this.result, x);
        } else {
          this.result = this.hasSeed ? tryCatch(this.acc)(this.seed, x) : x;
          this.hasAccumulation = true;
        }
        if (this.result === errorObj) {
          this.o.onError(this.result.e);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasValue && this.o.onNext(this.result);
          !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
          !this.hasValue && !this.hasSeed && this.o.onError(new EmptyError());
          this.o.onCompleted();
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      return ReduceObservable;
    }(ObservableBase));
    observableProto.reduce = function(accumulator) {
      var hasSeed = false;
      if (arguments.length === 2) {
        hasSeed = true;
        var seed = arguments[1];
      }
      return new ReduceObservable(this, accumulator, hasSeed, seed);
    };
    var SomeObserver = (function(__super__) {
      inherits(SomeObserver, __super__);
      function SomeObserver(o, fn, s) {
        this._o = o;
        this._fn = fn;
        this._s = s;
        this._i = 0;
        __super__.call(this);
      }
      SomeObserver.prototype.next = function(x) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        if (Boolean(result)) {
          this._o.onNext(true);
          this._o.onCompleted();
        }
      };
      SomeObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      SomeObserver.prototype.completed = function() {
        this._o.onNext(false);
        this._o.onCompleted();
      };
      return SomeObserver;
    }(AbstractObserver));
    observableProto.some = function(predicate, thisArg) {
      var source = this,
          fn = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        return source.subscribe(new SomeObserver(o, fn, source));
      });
    };
    var IsEmptyObserver = (function(__super__) {
      inherits(IsEmptyObserver, __super__);
      function IsEmptyObserver(o) {
        this._o = o;
        __super__.call(this);
      }
      IsEmptyObserver.prototype.next = function() {
        this._o.onNext(false);
        this._o.onCompleted();
      };
      IsEmptyObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      IsEmptyObserver.prototype.completed = function() {
        this._o.onNext(true);
        this._o.onCompleted();
      };
      return IsEmptyObserver;
    }(AbstractObserver));
    observableProto.isEmpty = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(new IsEmptyObserver(o));
      }, source);
    };
    var EveryObserver = (function(__super__) {
      inherits(EveryObserver, __super__);
      function EveryObserver(o, fn, s) {
        this._o = o;
        this._fn = fn;
        this._s = s;
        this._i = 0;
        __super__.call(this);
      }
      EveryObserver.prototype.next = function(x) {
        var result = tryCatch(this._fn)(x, this._i++, this._s);
        if (result === errorObj) {
          return this._o.onError(result.e);
        }
        if (!Boolean(result)) {
          this._o.onNext(false);
          this._o.onCompleted();
        }
      };
      EveryObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      EveryObserver.prototype.completed = function() {
        this._o.onNext(true);
        this._o.onCompleted();
      };
      return EveryObserver;
    }(AbstractObserver));
    observableProto.every = function(predicate, thisArg) {
      var source = this,
          fn = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        return source.subscribe(new EveryObserver(o, fn, source));
      }, this);
    };
    observableProto.includes = function(searchElement, fromIndex) {
      var source = this;
      function comparer(a, b) {
        return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));
      }
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(false);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i++ >= n && comparer(x, searchElement)) {
            o.onNext(true);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(false);
          o.onCompleted();
        });
      }, this);
    };
    observableProto.contains = function(searchElement, fromIndex) {
      observableProto.includes(searchElement, fromIndex);
    };
    observableProto.count = function(predicate, thisArg) {
      return predicate ? this.filter(predicate, thisArg).count() : this.reduce(function(count) {
        return count + 1;
      }, 0);
    };
    observableProto.indexOf = function(searchElement, fromIndex) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(-1);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i >= n && x === searchElement) {
            o.onNext(i);
            o.onCompleted();
          }
          i++;
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(-1);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.sum = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).sum() : this.reduce(function(prev, curr) {
        return prev + curr;
      }, 0);
    };
    observableProto.minBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, function(x, y) {
        return comparer(x, y) * -1;
      });
    };
    observableProto.min = function(comparer) {
      return this.minBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.maxBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, comparer);
    };
    observableProto.max = function(comparer) {
      return this.maxBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    var AverageObserver = (function(__super__) {
      inherits(AverageObserver, __super__);
      function AverageObserver(o, fn, s) {
        this._o = o;
        this._fn = fn;
        this._s = s;
        this._c = 0;
        this._t = 0;
        __super__.call(this);
      }
      AverageObserver.prototype.next = function(x) {
        if (this._fn) {
          var r = tryCatch(this._fn)(x, this._c++, this._s);
          if (r === errorObj) {
            return this._o.onError(r.e);
          }
          this._t += r;
        } else {
          this._c++;
          this._t += x;
        }
      };
      AverageObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      AverageObserver.prototype.completed = function() {
        if (this._c === 0) {
          return this._o.onError(new EmptyError());
        }
        this._o.onNext(this._t / this._c);
        this._o.onCompleted();
      };
      return AverageObserver;
    }(AbstractObserver));
    observableProto.average = function(keySelector, thisArg) {
      var source = this,
          fn;
      if (isFunction(keySelector)) {
        fn = bindCallback(keySelector, thisArg, 3);
      }
      return new AnonymousObservable(function(o) {
        return source.subscribe(new AverageObserver(o, fn, source));
      }, source);
    };
    observableProto.sequenceEqual = function(second, comparer) {
      var first = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var donel = false,
            doner = false,
            ql = [],
            qr = [];
        var subscription1 = first.subscribe(function(x) {
          var equal,
              v;
          if (qr.length > 0) {
            v = qr.shift();
            try {
              equal = comparer(v, x);
            } catch (e) {
              o.onError(e);
              return ;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (doner) {
            o.onNext(false);
            o.onCompleted();
          } else {
            ql.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          donel = true;
          if (ql.length === 0) {
            if (qr.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (doner) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
        isPromise(second) && (second = observableFromPromise(second));
        var subscription2 = second.subscribe(function(x) {
          var equal;
          if (ql.length > 0) {
            var v = ql.shift();
            try {
              equal = comparer(v, x);
            } catch (exception) {
              o.onError(exception);
              return ;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (donel) {
            o.onNext(false);
            o.onCompleted();
          } else {
            qr.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          doner = true;
          if (qr.length === 0) {
            if (ql.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (donel) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        return new CompositeDisposable(subscription1, subscription2);
      }, first);
    };
    observableProto.elementAt = function(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var i = index;
        return source.subscribe(function(x) {
          if (i-- === 0) {
            o.onNext(x);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (defaultValue === undefined) {
            o.onError(new ArgumentOutOfRangeError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    };
    observableProto.single = function(predicate, thisArg) {
      if (isFunction(predicate)) {
        return this.filter(predicate, thisArg).single();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var value,
            seenValue = false;
        return source.subscribe(function(x) {
          if (seenValue) {
            o.onError(new Error('Sequence contains more than one element'));
          } else {
            value = x;
            seenValue = true;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(value);
          o.onCompleted();
        });
      }, source);
    };
    var FirstObserver = (function(__super__) {
      inherits(FirstObserver, __super__);
      function FirstObserver(o, obj, s) {
        this._o = o;
        this._obj = obj;
        this._s = s;
        this._i = 0;
        __super__.call(this);
      }
      FirstObserver.prototype.next = function(x) {
        if (this._obj.predicate) {
          var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);
          if (res === errorObj) {
            return this._o.onError(res.e);
          }
          if (Boolean(res)) {
            this._o.onNext(x);
            this._o.onCompleted();
          }
        } else if (!this._obj.predicate) {
          this._o.onNext(x);
          this._o.onCompleted();
        }
      };
      FirstObserver.prototype.error = function(e) {
        this._o.onError(e);
      };
      FirstObserver.prototype.completed = function() {
        if (this._obj.defaultValue === undefined) {
          this._o.onError(new EmptyError());
        } else {
          this._o.onNext(this._obj.defaultValue);
          this._o.onCompleted();
        }
      };
      return FirstObserver;
    }(AbstractObserver));
    observableProto.first = function() {
      var obj = {},
          source = this;
      if (typeof arguments[0] === 'object') {
        obj = arguments[0];
      } else {
        obj = {
          predicate: arguments[0],
          thisArg: arguments[1],
          defaultValue: arguments[2]
        };
      }
      if (isFunction(obj.predicate)) {
        var fn = obj.predicate;
        obj.predicate = bindCallback(fn, obj.thisArg, 3);
      }
      return new AnonymousObservable(function(o) {
        return source.subscribe(new FirstObserver(o, obj, source));
      }, source);
    };
    observableProto.last = function() {
      var obj = {},
          source = this;
      if (typeof arguments[0] === 'object') {
        obj = arguments[0];
      } else {
        obj = {
          predicate: arguments[0],
          thisArg: arguments[1],
          defaultValue: arguments[2]
        };
      }
      if (isFunction(obj.predicate)) {
        var fn = obj.predicate;
        obj.predicate = bindCallback(fn, obj.thisArg, 3);
      }
      return new AnonymousObservable(function(o) {
        var value,
            seenValue = false,
            i = 0;
        return source.subscribe(function(x) {
          if (obj.predicate) {
            var res = tryCatch(obj.predicate)(x, i++, source);
            if (res === errorObj) {
              return o.onError(res.e);
            }
            if (res) {
              seenValue = true;
              value = x;
            }
          } else if (!obj.predicate) {
            seenValue = true;
            value = x;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (seenValue) {
            o.onNext(value);
            o.onCompleted();
          } else if (obj.defaultValue === undefined) {
            o.onError(new EmptyError());
          } else {
            o.onNext(obj.defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    };
    function findValue(source, predicate, thisArg, yieldIndex) {
      var callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0;
        return source.subscribe(function(x) {
          var shouldRun;
          try {
            shouldRun = callback(x, i, source);
          } catch (e) {
            o.onError(e);
            return ;
          }
          if (shouldRun) {
            o.onNext(yieldIndex ? i : x);
            o.onCompleted();
          } else {
            i++;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(yieldIndex ? -1 : undefined);
          o.onCompleted();
        });
      }, source);
    }
    observableProto.find = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, false);
    };
    observableProto.findIndex = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, true);
    };
    observableProto.toSet = function() {
      if (typeof root.Set === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var s = new root.Set();
        return source.subscribe(function(x) {
          s.add(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(s);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.toMap = function(keySelector, elementSelector) {
      if (typeof root.Map === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var m = new root.Map();
        return source.subscribe(function(x) {
          var key;
          try {
            key = keySelector(x);
          } catch (e) {
            o.onError(e);
            return ;
          }
          var element = x;
          if (elementSelector) {
            try {
              element = elementSelector(x);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          m.set(key, element);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(m);
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.async", ["npm:rx@3.0.0/dist/rx", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(factory) {
      var objectTypes = {
        'function': true,
        'object': true
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
          freeSelf = objectTypes[typeof self] && self.Object && self,
          freeWindow = objectTypes[typeof window] && window && window.Object && window,
          freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
          freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      if (typeof define === 'function' && define.amd) {
        define(["rx.binding", "exports"], function(Rx, exports) {
          root.Rx = factory(root, exports, Rx);
          return root.Rx;
        });
      } else if (typeof module === 'object' && module && module.exports === freeExports) {
        module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
      } else {
        root.Rx = factory(root, {}, root.Rx);
      }
    }.call(this, function(root, exp, Rx, undefined) {
      var Observable = Rx.Observable,
          observableProto = Observable.prototype,
          observableFromPromise = Observable.fromPromise,
          observableThrow = Observable.throwError,
          AnonymousObservable = Rx.AnonymousObservable,
          AsyncSubject = Rx.AsyncSubject,
          disposableCreate = Rx.Disposable.create,
          CompositeDisposable = Rx.CompositeDisposable,
          immediateScheduler = Rx.Scheduler.immediate,
          timeoutScheduler = Rx.Scheduler['default'],
          isScheduler = Rx.Scheduler.isScheduler,
          isPromise = Rx.helpers.isPromise,
          isFunction = Rx.helpers.isFunction;
      var errorObj = {e: {}};
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn) {
        if (!isFunction(fn)) {
          throw new TypeError('fn must be a function');
        }
        tryCatchTarget = fn;
        return tryCatcher;
      }
      function thrower(e) {
        throw e;
      }
      var spawn = Observable.spawn = function() {
        var gen = arguments[0],
            self = this,
            args = [];
        for (var i = 1,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return new AnonymousObservable(function(o) {
          var g = new CompositeDisposable();
          if (isFunction(gen)) {
            gen = gen.apply(self, args);
          }
          if (!gen || !isFunction(gen.next)) {
            o.onNext(gen);
            return o.onCompleted();
          }
          processGenerator();
          function processGenerator(res) {
            var ret = tryCatch(gen.next).call(gen, res);
            if (ret === errorObj) {
              return o.onError(ret.e);
            }
            next(ret);
          }
          function onError(err) {
            var ret = tryCatch(gen.next).call(gen, err);
            if (ret === errorObj) {
              return o.onError(ret.e);
            }
            next(ret);
          }
          function next(ret) {
            if (ret.done) {
              o.onNext(ret.value);
              o.onCompleted();
            }
            var value = toObservable.call(self, ret.value);
            if (Observable.isObservable(value)) {
              g.add(value.subscribe(processGenerator, onError));
            } else {
              onError(new TypeError('type not supported'));
            }
          }
          return g;
        });
      };
      function toObservable(obj) {
        if (!obj) {
          return obj;
        }
        if (Observable.isObservable(obj)) {
          return obj;
        }
        if (isPromise(obj)) {
          return Observable.fromPromise(obj);
        }
        if (isGeneratorFunction(obj) || isGenerator(obj)) {
          return spawn.call(this, obj);
        }
        if (isFunction(obj)) {
          return thunkToObservable.call(this, obj);
        }
        if (isArrayLike(obj) || isIterable(obj)) {
          return arrayToObservable.call(this, obj);
        }
        if (isObject(obj))
          return objectToObservable.call(this, obj);
        return obj;
      }
      function arrayToObservable(obj) {
        return Observable.from(obj).map(toObservable, this).toArray();
      }
      function objectToObservable(obj) {
        var results = new obj.constructor(),
            keys = Object.keys(obj),
            observables = [];
        for (var i = 0,
            len = keys.length; i < len; i++) {
          var key = keys[i],
              observable = toObservable.call(this, obj[key]);
          if (observable && Observable.isObservable(observable)) {
            defer(observable, key);
          } else {
            results[key] = obj[key];
          }
        }
        return Observable.concat(observables).startWith(results);
        function defer(observable, key) {
          results[key] = undefined;
          observables.push(new AnonymousObservable(function(o) {
            return observable.subscribe(function(next) {
              results[key] = next;
              o.onCompleted();
            });
          }));
        }
      }
      function thunkToObservable(fn) {
        var self = this;
        return new AnonymousObservable(function(o) {
          fn.call(self, function() {
            var err = arguments[0],
                res = arguments[1];
            if (err) {
              return o.onError(err);
            }
            if (arguments.length > 2) {
              var args = [];
              for (var i = 1,
                  len = arguments.length; i < len; i++) {
                args.push(arguments[i]);
              }
              res = args;
            }
            o.onNext(res);
            o.onCompleted();
          });
        });
      }
      function isGenerator(obj) {
        return isFunction(obj.next) && isFunction(obj.throw);
      }
      function isGeneratorFunction(obj) {
        var ctor = obj.constructor;
        if (!ctor) {
          return false;
        }
        if (ctor.name === 'GeneratorFunction' || ctor.displayName === 'GeneratorFunction') {
          return true;
        }
        return isGenerator(ctor.prototype);
      }
      function isObject(val) {
        return Object == val.constructor;
      }
      Observable.start = function(func, context, scheduler) {
        return observableToAsync(func, context, scheduler)();
      };
      var observableToAsync = Observable.toAsync = function(func, context, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return function() {
          var args = arguments,
              subject = new AsyncSubject();
          scheduler.schedule(function() {
            var result;
            try {
              result = func.apply(context, args);
            } catch (e) {
              subject.onError(e);
              return ;
            }
            subject.onNext(result);
            subject.onCompleted();
          });
          return subject.asObservable();
        };
      };
      function createCbObservable(fn, ctx, selector, args) {
        var o = new AsyncSubject();
        args.push(createCbHandler(o, ctx, selector));
        fn.apply(ctx, args);
        return o.asObservable();
      }
      function createCbHandler(o, ctx, selector) {
        return function handler() {
          var len = arguments.length,
              results = new Array(len);
          for (var i = 0; i < len; i++) {
            results[i] = arguments[i];
          }
          if (isFunction(selector)) {
            results = tryCatch(selector).apply(ctx, results);
            if (results === errorObj) {
              return o.onError(results.e);
            }
            o.onNext(results);
          } else {
            if (results.length <= 1) {
              o.onNext(results[0]);
            } else {
              o.onNext(results);
            }
          }
          o.onCompleted();
        };
      }
      Observable.fromCallback = function(fn, ctx, selector) {
        return function() {
          var len = arguments.length,
              args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
          return createCbObservable(fn, ctx, selector, args);
        };
      };
      function createNodeObservable(fn, ctx, selector, args) {
        var o = new AsyncSubject();
        args.push(createNodeHandler(o, ctx, selector));
        fn.apply(ctx, args);
        return o.asObservable();
      }
      function createNodeHandler(o, ctx, selector) {
        return function handler() {
          var err = arguments[0];
          if (err) {
            return o.onError(err);
          }
          var len = arguments.length,
              results = [];
          for (var i = 1; i < len; i++) {
            results[i - 1] = arguments[i];
          }
          if (isFunction(selector)) {
            var results = tryCatch(selector).apply(ctx, results);
            if (results === errorObj) {
              return o.onError(results.e);
            }
            o.onNext(results);
          } else {
            if (results.length <= 1) {
              o.onNext(results[0]);
            } else {
              o.onNext(results);
            }
          }
          o.onCompleted();
        };
      }
      Observable.fromNodeCallback = function(fn, ctx, selector) {
        return function() {
          var len = arguments.length,
              args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
          return createNodeObservable(fn, ctx, selector, args);
        };
      };
      function ListenDisposable(e, n, fn) {
        this._e = e;
        this._n = n;
        this._fn = fn;
        this._e.addEventListener(this._n, this._fn, false);
        this.isDisposed = false;
      }
      ListenDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this._e.removeEventListener(this._n, this._fn, false);
          this.isDisposed = true;
        }
      };
      function createEventListener(el, eventName, handler) {
        var disposables = new CompositeDisposable();
        var toStr = Object.prototype.toString;
        if (toStr.call(el) === '[object NodeList]' || toStr.call(el) === '[object HTMLCollection]') {
          for (var i = 0,
              len = el.length; i < len; i++) {
            disposables.add(createEventListener(el.item(i), eventName, handler));
          }
        } else if (el) {
          disposables.add(new ListenDisposable(el, eventName, handler));
        }
        return disposables;
      }
      Rx.config.useNativeEvents = false;
      Observable.fromEvent = function(element, eventName, selector) {
        if (element.addListener) {
          return fromEventPattern(function(h) {
            element.addListener(eventName, h);
          }, function(h) {
            element.removeListener(eventName, h);
          }, selector);
        }
        if (!Rx.config.useNativeEvents) {
          if (typeof element.on === 'function' && typeof element.off === 'function') {
            return fromEventPattern(function(h) {
              element.on(eventName, h);
            }, function(h) {
              element.off(eventName, h);
            }, selector);
          }
        }
        function eventHandler(o) {
          return function handler() {
            var results = arguments[0];
            if (isFunction(selector)) {
              results = tryCatch(selector).apply(null, arguments);
              if (results === errorObj) {
                return o.onError(results.e);
              }
            }
            o.onNext(results);
          };
        }
        return new AnonymousObservable(function(o) {
          return createEventListener(element, eventName, eventHandler(o));
        }).publish().refCount();
      };
      var fromEventPattern = Observable.fromEventPattern = function(addHandler, removeHandler, selector) {
        return new AnonymousObservable(function(o) {
          function innerHandler() {
            var result = arguments[0];
            if (isFunction(selector)) {
              result = tryCatch(selector).apply(null, arguments);
              if (result === errorObj) {
                return o.onError(result.e);
              }
            }
            o.onNext(result);
          }
          var returnValue = addHandler(innerHandler);
          return disposableCreate(function() {
            isFunction(removeHandler) && removeHandler(innerHandler, returnValue);
          });
        }).publish().refCount();
      };
      Observable.startAsync = function(functionAsync) {
        var promise;
        try {
          promise = functionAsync();
        } catch (e) {
          return observableThrow(e);
        }
        return observableFromPromise(promise);
      };
      return Rx;
    }));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.backpressure", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        AbstractObserver = Rx.internals.AbstractObserver,
        CompositeDisposable = Rx.CompositeDisposable,
        Notification = Rx.Notification,
        Subject = Rx.Subject,
        Observer = Rx.Observer,
        disposableEmpty = Rx.Disposable.empty,
        disposableCreate = Rx.Disposable.create,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        timeoutScheduler = Rx.Scheduler.timeout,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        identity = Rx.helpers.identity,
        isScheduler = Rx.Scheduler.isScheduler,
        isFunction = Rx.helpers.isFunction,
        checkDisposed = Rx.Disposable.checkDisposed;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    Rx.Pauser = (function(__super__) {
      inherits(Pauser, __super__);
      function Pauser() {
        __super__.call(this);
      }
      Pauser.prototype.pause = function() {
        this.onNext(false);
      };
      Pauser.prototype.resume = function() {
        this.onNext(true);
      };
      return Pauser;
    }(Subject));
    var PausableObservable = (function(__super__) {
      inherits(PausableObservable, __super__);
      function subscribe(observer) {
        var conn = this.source.publish(),
            subscription = conn.subscribe(observer),
            connection = disposableEmpty;
        var pausable = this.pauser.distinctUntilChanged().subscribe(function(b) {
          if (b) {
            connection = conn.connect();
          } else {
            connection.dispose();
            connection = disposableEmpty;
          }
        });
        return new CompositeDisposable(subscription, connection, pausable);
      }
      function PausableObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableObservable;
    }(Observable));
    observableProto.pausable = function(pauser) {
      return new PausableObservable(this, pauser);
    };
    function combineLatestSource(source, subject, resultSelector) {
      return new AnonymousObservable(function(o) {
        var hasValue = [false, false],
            hasValueAll = false,
            isDone = false,
            values = new Array(2),
            err;
        function next(x, i) {
          values[i] = x;
          hasValue[i] = true;
          if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
            if (err) {
              return o.onError(err);
            }
            var res = tryCatch(resultSelector).apply(null, values);
            if (res === errorObj) {
              return o.onError(res.e);
            }
            o.onNext(res);
          }
          isDone && values[1] && o.onCompleted();
        }
        return new CompositeDisposable(source.subscribe(function(x) {
          next(x, 0);
        }, function(e) {
          if (values[1]) {
            o.onError(e);
          } else {
            err = e;
          }
        }, function() {
          isDone = true;
          values[1] && o.onCompleted();
        }), subject.subscribe(function(x) {
          next(x, 1);
        }, function(e) {
          o.onError(e);
        }, function() {
          isDone = true;
          next(true, 1);
        }));
      }, source);
    }
    var PausableBufferedObservable = (function(__super__) {
      inherits(PausableBufferedObservable, __super__);
      function subscribe(o) {
        var q = [],
            previousShouldFire;
        function drainQueue() {
          while (q.length > 0) {
            o.onNext(q.shift());
          }
        }
        var subscription = combineLatestSource(this.source, this.pauser.startWith(false).distinctUntilChanged(), function(data, shouldFire) {
          return {
            data: data,
            shouldFire: shouldFire
          };
        }).subscribe(function(results) {
          if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              drainQueue();
            }
          } else {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              o.onNext(results.data);
            } else {
              q.push(results.data);
            }
          }
        }, function(err) {
          drainQueue();
          o.onError(err);
        }, function() {
          drainQueue();
          o.onCompleted();
        });
        return subscription;
      }
      function PausableBufferedObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableBufferedObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableBufferedObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableBufferedObservable;
    }(Observable));
    observableProto.pausableBuffered = function(subject) {
      return new PausableBufferedObservable(this, subject);
    };
    var ControlledObservable = (function(__super__) {
      inherits(ControlledObservable, __super__);
      function subscribe(observer) {
        return this.source.subscribe(observer);
      }
      function ControlledObservable(source, enableQueue, scheduler) {
        __super__.call(this, subscribe, source);
        this.subject = new ControlledSubject(enableQueue, scheduler);
        this.source = source.multicast(this.subject).refCount();
      }
      ControlledObservable.prototype.request = function(numberOfItems) {
        return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
      };
      return ControlledObservable;
    }(Observable));
    var ControlledSubject = (function(__super__) {
      function subscribe(observer) {
        return this.subject.subscribe(observer);
      }
      inherits(ControlledSubject, __super__);
      function ControlledSubject(enableQueue, scheduler) {
        enableQueue == null && (enableQueue = true);
        __super__.call(this, subscribe);
        this.subject = new Subject();
        this.enableQueue = enableQueue;
        this.queue = enableQueue ? [] : null;
        this.requestedCount = 0;
        this.requestedDisposable = null;
        this.error = null;
        this.hasFailed = false;
        this.hasCompleted = false;
        this.scheduler = scheduler || currentThreadScheduler;
      }
      addProperties(ControlledSubject.prototype, Observer, {
        onCompleted: function() {
          this.hasCompleted = true;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onCompleted();
            this.disposeCurrentRequest();
          } else {
            this.queue.push(Notification.createOnCompleted());
          }
        },
        onError: function(error) {
          this.hasFailed = true;
          this.error = error;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onError(error);
            this.disposeCurrentRequest();
          } else {
            this.queue.push(Notification.createOnError(error));
          }
        },
        onNext: function(value) {
          if (this.requestedCount <= 0) {
            this.enableQueue && this.queue.push(Notification.createOnNext(value));
          } else {
            (this.requestedCount-- === 0) && this.disposeCurrentRequest();
            this.subject.onNext(value);
          }
        },
        _processRequest: function(numberOfItems) {
          if (this.enableQueue) {
            while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {
              var first = this.queue.shift();
              first.accept(this.subject);
              if (first.kind === 'N') {
                numberOfItems--;
              } else {
                this.disposeCurrentRequest();
                this.queue = [];
              }
            }
          }
          return numberOfItems;
        },
        request: function(number) {
          this.disposeCurrentRequest();
          var self = this;
          this.requestedDisposable = this.scheduler.scheduleWithState(number, function(s, i) {
            var remaining = self._processRequest(i);
            var stopped = self.hasCompleted || self.hasFailed;
            if (!stopped && remaining > 0) {
              self.requestedCount = remaining;
              return disposableCreate(function() {
                self.requestedCount = 0;
              });
            }
          });
          return this.requestedDisposable;
        },
        disposeCurrentRequest: function() {
          if (this.requestedDisposable) {
            this.requestedDisposable.dispose();
            this.requestedDisposable = null;
          }
        }
      });
      return ControlledSubject;
    }(Observable));
    observableProto.controlled = function(enableQueue, scheduler) {
      if (enableQueue && isScheduler(enableQueue)) {
        scheduler = enableQueue;
        enableQueue = true;
      }
      if (enableQueue == null) {
        enableQueue = true;
      }
      return new ControlledObservable(this, enableQueue, scheduler);
    };
    var StopAndWaitObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new StopAndWaitObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(1);
        });
        return this.subscription;
      }
      inherits(StopAndWaitObservable, __super__);
      function StopAndWaitObservable(source) {
        __super__.call(this, subscribe, source);
        this.source = source;
      }
      var StopAndWaitObserver = (function(__sub__) {
        inherits(StopAndWaitObserver, __sub__);
        function StopAndWaitObserver(observer, observable, cancel) {
          __sub__.call(this);
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
        }
        var stopAndWaitObserverProto = StopAndWaitObserver.prototype;
        stopAndWaitObserverProto.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        stopAndWaitObserverProto.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        stopAndWaitObserverProto.next = function(value) {
          this.observer.onNext(value);
          var self = this;
          timeoutScheduler.schedule(function() {
            self.observable.source.request(1);
          });
        };
        stopAndWaitObserverProto.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return StopAndWaitObserver;
      }(AbstractObserver));
      return StopAndWaitObservable;
    }(Observable));
    ControlledObservable.prototype.stopAndWait = function() {
      return new StopAndWaitObservable(this);
    };
    var WindowedObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new WindowedObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(self.windowSize);
        });
        return this.subscription;
      }
      inherits(WindowedObservable, __super__);
      function WindowedObservable(source, windowSize) {
        __super__.call(this, subscribe, source);
        this.source = source;
        this.windowSize = windowSize;
      }
      var WindowedObserver = (function(__sub__) {
        inherits(WindowedObserver, __sub__);
        function WindowedObserver(observer, observable, cancel) {
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
          this.received = 0;
        }
        var windowedObserverPrototype = WindowedObserver.prototype;
        windowedObserverPrototype.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        windowedObserverPrototype.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        windowedObserverPrototype.next = function(value) {
          this.observer.onNext(value);
          this.received = ++this.received % this.observable.windowSize;
          if (this.received === 0) {
            var self = this;
            timeoutScheduler.schedule(function() {
              self.observable.source.request(self.observable.windowSize);
            });
          }
        };
        windowedObserverPrototype.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return WindowedObserver;
      }(AbstractObserver));
      return WindowedObservable;
    }(Observable));
    ControlledObservable.prototype.windowed = function(windowSize) {
      return new WindowedObservable(this, windowSize);
    };
    observableProto.pipe = function(dest) {
      var source = this.pausableBuffered();
      function onDrain() {
        source.resume();
      }
      dest.addListener('drain', onDrain);
      source.subscribe(function(x) {
        !dest.write(String(x)) && source.pause();
      }, function(err) {
        dest.emit('error', err);
      }, function() {
        !dest._isStdio && dest.end();
        dest.removeListener('drain', onDrain);
      });
      source.resume();
      return dest;
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.binding", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        Subject = Rx.Subject,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        ScheduledObserver = Rx.internals.ScheduledObserver,
        disposableCreate = Rx.Disposable.create,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        isFunction = Rx.helpers.isFunction,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        checkDisposed = Rx.Disposable.checkDisposed;
    function cloneArray(arr) {
      var len = arr.length,
          a = new Array(len);
      for (var i = 0; i < len; i++) {
        a[i] = arr[i];
      }
      return a;
    }
    observableProto.multicast = function(subjectOrSubjectSelector, selector) {
      var source = this;
      return typeof subjectOrSubjectSelector === 'function' ? new AnonymousObservable(function(observer) {
        var connectable = source.multicast(subjectOrSubjectSelector());
        return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());
      }, source) : new ConnectableObservable(source, subjectOrSubjectSelector);
    };
    observableProto.publish = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new Subject();
      }, selector) : this.multicast(new Subject());
    };
    observableProto.share = function() {
      return this.publish().refCount();
    };
    observableProto.publishLast = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new AsyncSubject();
      }, selector) : this.multicast(new AsyncSubject());
    };
    observableProto.publishValue = function(initialValueOrSelector, initialValue) {
      return arguments.length === 2 ? this.multicast(function() {
        return new BehaviorSubject(initialValue);
      }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
    };
    observableProto.shareValue = function(initialValue) {
      return this.publishValue(initialValue).refCount();
    };
    observableProto.replay = function(selector, bufferSize, windowSize, scheduler) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new ReplaySubject(bufferSize, windowSize, scheduler);
      }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
    };
    observableProto.shareReplay = function(bufferSize, windowSize, scheduler) {
      return this.replay(null, bufferSize, windowSize, scheduler).refCount();
    };
    var InnerSubscription = function(subject, observer) {
      this.subject = subject;
      this.observer = observer;
    };
    InnerSubscription.prototype.dispose = function() {
      if (!this.subject.isDisposed && this.observer !== null) {
        var idx = this.subject.observers.indexOf(this.observer);
        this.subject.observers.splice(idx, 1);
        this.observer = null;
      }
    };
    var BehaviorSubject = Rx.BehaviorSubject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          observer.onNext(this.value);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
        } else {
          observer.onCompleted();
        }
        return disposableEmpty;
      }
      inherits(BehaviorSubject, __super__);
      function BehaviorSubject(value) {
        __super__.call(this, subscribe);
        this.value = value, this.observers = [], this.isDisposed = false, this.isStopped = false, this.hasError = false;
      }
      addProperties(BehaviorSubject.prototype, Observer, {
        getValue: function() {
          checkDisposed(this);
          if (this.hasError) {
            throw this.error;
          }
          return this.value;
        },
        hasObservers: function() {
          return this.observers.length > 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onCompleted();
          }
          this.observers.length = 0;
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          this.hasError = true;
          this.error = error;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onError(error);
          }
          this.observers.length = 0;
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.value = value;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onNext(value);
          }
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
          this.value = null;
          this.exception = null;
        }
      });
      return BehaviorSubject;
    }(Observable));
    var ReplaySubject = Rx.ReplaySubject = (function(__super__) {
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function createRemovableDisposable(subject, observer) {
        return disposableCreate(function() {
          observer.dispose();
          !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
        });
      }
      function subscribe(observer) {
        var so = new ScheduledObserver(this.scheduler, observer),
            subscription = createRemovableDisposable(this, so);
        checkDisposed(this);
        this._trim(this.scheduler.now());
        this.observers.push(so);
        for (var i = 0,
            len = this.q.length; i < len; i++) {
          so.onNext(this.q[i].value);
        }
        if (this.hasError) {
          so.onError(this.error);
        } else if (this.isStopped) {
          so.onCompleted();
        }
        so.ensureActive();
        return subscription;
      }
      inherits(ReplaySubject, __super__);
      function ReplaySubject(bufferSize, windowSize, scheduler) {
        this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
        this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
        this.scheduler = scheduler || currentThreadScheduler;
        this.q = [];
        this.observers = [];
        this.isStopped = false;
        this.isDisposed = false;
        this.hasError = false;
        this.error = null;
        __super__.call(this, subscribe);
      }
      addProperties(ReplaySubject.prototype, Observer.prototype, {
        hasObservers: function() {
          return this.observers.length > 0;
        },
        _trim: function(now) {
          while (this.q.length > this.bufferSize) {
            this.q.shift();
          }
          while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {
            this.q.shift();
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          var now = this.scheduler.now();
          this.q.push({
            interval: now,
            value: value
          });
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onNext(value);
            observer.ensureActive();
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          this.error = error;
          this.hasError = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onError(error);
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onCompleted();
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
        }
      });
      return ReplaySubject;
    }(Observable));
    var ConnectableObservable = Rx.ConnectableObservable = (function(__super__) {
      inherits(ConnectableObservable, __super__);
      function ConnectableObservable(source, subject) {
        var hasSubscription = false,
            subscription,
            sourceObservable = source.asObservable();
        this.connect = function() {
          if (!hasSubscription) {
            hasSubscription = true;
            subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function() {
              hasSubscription = false;
            }));
          }
          return subscription;
        };
        __super__.call(this, function(o) {
          return subject.subscribe(o);
        });
      }
      ConnectableObservable.prototype.refCount = function() {
        var connectableSubscription,
            count = 0,
            source = this;
        return new AnonymousObservable(function(observer) {
          var shouldConnect = ++count === 1,
              subscription = source.subscribe(observer);
          shouldConnect && (connectableSubscription = source.connect());
          return function() {
            subscription.dispose();
            --count === 0 && connectableSubscription.dispose();
          };
        });
      };
      return ConnectableObservable;
    }(Observable));
    observableProto.singleInstance = function() {
      var source = this,
          hasObservable = false,
          observable;
      function getObservable() {
        if (!hasObservable) {
          hasObservable = true;
          observable = source.finally(function() {
            hasObservable = false;
          }).publish().refCount();
        }
        return observable;
      }
      ;
      return new AnonymousObservable(function(o) {
        return getObservable().subscribe(o);
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.coincidence", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        Subject = Rx.Subject,
        observableProto = Observable.prototype,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        AnonymousObservable = Rx.AnonymousObservable,
        observerCreate = Rx.Observer.create,
        addRef = Rx.internals.addRef,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        noop = Rx.helpers.noop,
        identity = Rx.helpers.identity,
        isPromise = Rx.helpers.isPromise,
        isFunction = Rx.helpers.isFunction,
        bindCallback = Rx.internals.bindCallback,
        observableFromPromise = Observable.fromPromise,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    var Map = root.Map || (function() {
      function Map() {
        this.size = 0;
        this._values = [];
        this._keys = [];
      }
      Map.prototype['delete'] = function(key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
      };
      Map.prototype.get = function(key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
      };
      Map.prototype.set = function(key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          this._keys.push(key);
          this._values.push(value);
          this.size++;
        } else {
          this._values[i] = value;
        }
        return this;
      };
      Map.prototype.forEach = function(cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
          cb.call(thisArg, this._values[i], this._keys[i]);
        }
      };
      return Map;
    }());
    observableProto.join = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(o) {
        var group = new CompositeDisposable();
        var leftDone = false,
            rightDone = false;
        var leftId = 0,
            rightId = 0;
        var leftMap = new Map(),
            rightMap = new Map();
        var handleError = function(e) {
          o.onError(e);
        };
        group.add(left.subscribe(function(value) {
          var id = leftId++,
              md = new SingleAssignmentDisposable();
          leftMap.set(id, value);
          group.add(md);
          var duration = tryCatch(leftDurationSelector)(value);
          if (duration === errorObj) {
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, handleError, function() {
            leftMap['delete'](id) && leftMap.size === 0 && leftDone && o.onCompleted();
            group.remove(md);
          }));
          rightMap.forEach(function(v) {
            var result = tryCatch(resultSelector)(value, v);
            if (result === errorObj) {
              return o.onError(result.e);
            }
            o.onNext(result);
          });
        }, handleError, function() {
          leftDone = true;
          (rightDone || leftMap.size === 0) && o.onCompleted();
        }));
        group.add(right.subscribe(function(value) {
          var id = rightId++,
              md = new SingleAssignmentDisposable();
          rightMap.set(id, value);
          group.add(md);
          var duration = tryCatch(rightDurationSelector)(value);
          if (duration === errorObj) {
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, handleError, function() {
            rightMap['delete'](id) && rightMap.size === 0 && rightDone && o.onCompleted();
            group.remove(md);
          }));
          leftMap.forEach(function(v) {
            var result = tryCatch(resultSelector)(v, value);
            if (result === errorObj) {
              return o.onError(result.e);
            }
            o.onNext(result);
          });
        }, handleError, function() {
          rightDone = true;
          (leftDone || rightMap.size === 0) && o.onCompleted();
        }));
        return group;
      }, left);
    };
    observableProto.groupJoin = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(o) {
        var group = new CompositeDisposable();
        var r = new RefCountDisposable(group);
        var leftMap = new Map(),
            rightMap = new Map();
        var leftId = 0,
            rightId = 0;
        var handleError = function(e) {
          return function(v) {
            v.onError(e);
          };
        };
        function handleError(e) {}
        ;
        group.add(left.subscribe(function(value) {
          var s = new Subject();
          var id = leftId++;
          leftMap.set(id, s);
          var result = tryCatch(resultSelector)(value, addRef(s, r));
          if (result === errorObj) {
            leftMap.forEach(handleError(result.e));
            return o.onError(result.e);
          }
          o.onNext(result);
          rightMap.forEach(function(v) {
            s.onNext(v);
          });
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var duration = tryCatch(leftDurationSelector)(value);
          if (duration === errorObj) {
            leftMap.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.forEach(handleError(e));
            o.onError(e);
          }, function() {
            leftMap['delete'](id) && s.onCompleted();
            group.remove(md);
          }));
        }, function(e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }, function() {
          o.onCompleted();
        }));
        group.add(right.subscribe(function(value) {
          var id = rightId++;
          rightMap.set(id, value);
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var duration = tryCatch(rightDurationSelector)(value);
          if (duration === errorObj) {
            leftMap.forEach(handleError(duration.e));
            return o.onError(duration.e);
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.forEach(handleError(e));
            o.onError(e);
          }, function() {
            rightMap['delete'](id);
            group.remove(md);
          }));
          leftMap.forEach(function(v) {
            v.onNext(value);
          });
        }, function(e) {
          leftMap.forEach(handleError(e));
          o.onError(e);
        }));
        return r;
      }, left);
    };
    function toArray(x) {
      return x.toArray();
    }
    observableProto.buffer = function() {
      return this.window.apply(this, arguments).flatMap(toArray);
    };
    observableProto.window = function(windowOpeningsOrClosingSelector, windowClosingSelector) {
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
      }
      return typeof windowOpeningsOrClosingSelector === 'function' ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
    };
    function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
      return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function(_, win) {
        return win;
      });
    }
    function observableWindowWithBoundaries(windowBoundaries) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var win = new Subject(),
            d = new CompositeDisposable(),
            r = new RefCountDisposable(d);
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));
        d.add(windowBoundaries.subscribe(function(w) {
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        return r;
      }, source);
    }
    function observableWindowWithClosingSelector(windowClosingSelector) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            r = new RefCountDisposable(d),
            win = new Subject();
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        function createWindowClose() {
          var windowClose;
          try {
            windowClose = windowClosingSelector();
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));
          var m1 = new SingleAssignmentDisposable();
          m.setDisposable(m1);
          m1.setDisposable(windowClose.take(1).subscribe(noop, function(err) {
            win.onError(err);
            observer.onError(err);
          }, function() {
            win.onCompleted();
            win = new Subject();
            observer.onNext(addRef(win, r));
            createWindowClose();
          }));
        }
        createWindowClose();
        return r;
      }, source);
    }
    observableProto.pairwise = function() {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var previous,
            hasPrevious = false;
        return source.subscribe(function(x) {
          if (hasPrevious) {
            observer.onNext([previous, x]);
          } else {
            hasPrevious = true;
          }
          previous = x;
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
      }, source);
    };
    observableProto.partition = function(predicate, thisArg) {
      return [this.filter(predicate, thisArg), this.filter(function(x, i, o) {
        return !predicate.call(thisArg, x, i, o);
      })];
    };
    observableProto.groupBy = function(keySelector, elementSelector) {
      return this.groupByUntil(keySelector, elementSelector, observableNever);
    };
    observableProto.groupByUntil = function(keySelector, elementSelector, durationSelector) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var map = new Map(),
            groupDisposable = new CompositeDisposable(),
            refCountDisposable = new RefCountDisposable(groupDisposable),
            handleError = function(e) {
              return function(item) {
                item.onError(e);
              };
            };
        groupDisposable.add(source.subscribe(function(x) {
          var key = tryCatch(keySelector)(x);
          if (key === errorObj) {
            map.forEach(handleError(key.e));
            return o.onError(key.e);
          }
          var fireNewMapEntry = false,
              writer = map.get(key);
          if (writer === undefined) {
            writer = new Subject();
            map.set(key, writer);
            fireNewMapEntry = true;
          }
          if (fireNewMapEntry) {
            var group = new GroupedObservable(key, writer, refCountDisposable),
                durationGroup = new GroupedObservable(key, writer);
            var duration = tryCatch(durationSelector)(durationGroup);
            if (duration === errorObj) {
              map.forEach(handleError(duration.e));
              return o.onError(duration.e);
            }
            o.onNext(group);
            var md = new SingleAssignmentDisposable();
            groupDisposable.add(md);
            md.setDisposable(duration.take(1).subscribe(noop, function(e) {
              map.forEach(handleError(e));
              o.onError(e);
            }, function() {
              if (map['delete'](key)) {
                writer.onCompleted();
              }
              groupDisposable.remove(md);
            }));
          }
          var element = x;
          if (isFunction(elementSelector)) {
            element = tryCatch(elementSelector)(x);
            if (element === errorObj) {
              map.forEach(handleError(element.e));
              return o.onError(element.e);
            }
          }
          writer.onNext(element);
        }, function(e) {
          map.forEach(handleError(e));
          o.onError(e);
        }, function() {
          map.forEach(function(item) {
            item.onCompleted();
          });
          o.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    var GroupedObservable = (function(__super__) {
      inherits(GroupedObservable, __super__);
      function subscribe(observer) {
        return this.underlyingObservable.subscribe(observer);
      }
      function GroupedObservable(key, underlyingObservable, mergedDisposable) {
        __super__.call(this, subscribe);
        this.key = key;
        this.underlyingObservable = !mergedDisposable ? underlyingObservable : new AnonymousObservable(function(observer) {
          return new CompositeDisposable(mergedDisposable.getDisposable(), underlyingObservable.subscribe(observer));
        });
      }
      return GroupedObservable;
    }(Observable));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.experimental", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableConcat = Observable.concat,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        SerialDisposable = Rx.SerialDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        Enumerator = Rx.internals.Enumerator,
        Enumerable = Rx.internals.Enumerable,
        enumerableOf = Enumerable.of,
        immediateScheduler = Rx.Scheduler.immediate,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        slice = Array.prototype.slice,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        inherits = Rx.internals.inherits,
        bindCallback = Rx.internals.bindCallback,
        addProperties = Rx.internals.addProperties,
        helpers = Rx.helpers,
        noop = helpers.noop,
        isPromise = helpers.isPromise,
        isFunction = helpers.isFunction,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
    if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
      $iterator$ = '@@iterator';
    }
    var doneEnumerator = Rx.doneEnumerator = {
      done: true,
      value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function(o) {
      return o[$iterator$] !== undefined;
    };
    var isArrayLike = Rx.helpers.isArrayLike = function(o) {
      return o && o.length !== undefined;
    };
    Rx.helpers.iterator = $iterator$;
    var WhileEnumerable = (function(__super__) {
      inherits(WhileEnumerable, __super__);
      function WhileEnumerable(c, s) {
        this.c = c;
        this.s = s;
      }
      WhileEnumerable.prototype[$iterator$] = function() {
        var self = this;
        return {next: function() {
            return self.c() ? {
              done: false,
              value: self.s
            } : {
              done: true,
              value: void 0
            };
          }};
      };
      return WhileEnumerable;
    }(Enumerable));
    function enumerableWhile(condition, source) {
      return new WhileEnumerable(condition, source);
    }
    observableProto.letBind = observableProto['let'] = function(func) {
      return func(this);
    };
    Observable['if'] = function(condition, thenSource, elseSourceOrScheduler) {
      return observableDefer(function() {
        elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());
        isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
        isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));
        typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
        return condition() ? thenSource : elseSourceOrScheduler;
      });
    };
    Observable['for'] = Observable.forIn = function(sources, resultSelector, thisArg) {
      return enumerableOf(sources, resultSelector, thisArg).concat();
    };
    var observableWhileDo = Observable['while'] = Observable.whileDo = function(condition, source) {
      isPromise(source) && (source = observableFromPromise(source));
      return enumerableWhile(condition, source).concat();
    };
    observableProto.doWhile = function(condition) {
      return observableConcat([this, observableWhileDo(condition, this)]);
    };
    Observable['case'] = function(selector, sources, defaultSourceOrScheduler) {
      return observableDefer(function() {
        isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
        defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());
        isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));
        var result = sources[selector()];
        isPromise(result) && (result = observableFromPromise(result));
        return result || defaultSourceOrScheduler;
      });
    };
    observableProto.expand = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var q = [],
            m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            activeCount = 0,
            isAcquired = false;
        var ensureActive = function() {
          var isOwner = false;
          if (q.length > 0) {
            isOwner = !isAcquired;
            isAcquired = true;
          }
          if (isOwner) {
            m.setDisposable(scheduler.scheduleRecursive(function(self) {
              var work;
              if (q.length > 0) {
                work = q.shift();
              } else {
                isAcquired = false;
                return ;
              }
              var m1 = new SingleAssignmentDisposable();
              d.add(m1);
              m1.setDisposable(work.subscribe(function(x) {
                observer.onNext(x);
                var result = null;
                try {
                  result = selector(x);
                } catch (e) {
                  observer.onError(e);
                }
                q.push(result);
                activeCount++;
                ensureActive();
              }, observer.onError.bind(observer), function() {
                d.remove(m1);
                activeCount--;
                if (activeCount === 0) {
                  observer.onCompleted();
                }
              }));
              self();
            }));
          }
        };
        q.push(source);
        activeCount++;
        ensureActive();
        return d;
      }, this);
    };
    Observable.forkJoin = function() {
      var allSources = [];
      if (Array.isArray(arguments[0])) {
        allSources = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          allSources.push(arguments[i]);
        }
      }
      return new AnonymousObservable(function(subscriber) {
        var count = allSources.length;
        if (count === 0) {
          subscriber.onCompleted();
          return disposableEmpty;
        }
        var group = new CompositeDisposable(),
            finished = false,
            hasResults = new Array(count),
            hasCompleted = new Array(count),
            results = new Array(count);
        for (var idx = 0; idx < count; idx++) {
          (function(i) {
            var source = allSources[i];
            isPromise(source) && (source = observableFromPromise(source));
            group.add(source.subscribe(function(value) {
              if (!finished) {
                hasResults[i] = true;
                results[i] = value;
              }
            }, function(e) {
              finished = true;
              subscriber.onError(e);
              group.dispose();
            }, function() {
              if (!finished) {
                if (!hasResults[i]) {
                  subscriber.onCompleted();
                  return ;
                }
                hasCompleted[i] = true;
                for (var ix = 0; ix < count; ix++) {
                  if (!hasCompleted[ix]) {
                    return ;
                  }
                }
                finished = true;
                subscriber.onNext(results);
                subscriber.onCompleted();
              }
            }));
          })(idx);
        }
        return group;
      });
    };
    observableProto.forkJoin = function(second, resultSelector) {
      var first = this;
      return new AnonymousObservable(function(observer) {
        var leftStopped = false,
            rightStopped = false,
            hasLeft = false,
            hasRight = false,
            lastLeft,
            lastRight,
            leftSubscription = new SingleAssignmentDisposable(),
            rightSubscription = new SingleAssignmentDisposable();
        isPromise(second) && (second = observableFromPromise(second));
        leftSubscription.setDisposable(first.subscribe(function(left) {
          hasLeft = true;
          lastLeft = left;
        }, function(err) {
          rightSubscription.dispose();
          observer.onError(err);
        }, function() {
          leftStopped = true;
          if (rightStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        rightSubscription.setDisposable(second.subscribe(function(right) {
          hasRight = true;
          lastRight = right;
        }, function(err) {
          leftSubscription.dispose();
          observer.onError(err);
        }, function() {
          rightStopped = true;
          if (leftStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        return new CompositeDisposable(leftSubscription, rightSubscription);
      }, first);
    };
    observableProto.manySelect = observableProto.extend = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return observableDefer(function() {
        var chain;
        return source.map(function(x) {
          var curr = new ChainObservable(x);
          chain && chain.onNext(x);
          chain = curr;
          return curr;
        }).tap(noop, function(e) {
          chain && chain.onError(e);
        }, function() {
          chain && chain.onCompleted();
        }).observeOn(scheduler).map(selector);
      }, source);
    };
    var ChainObservable = (function(__super__) {
      function subscribe(observer) {
        var self = this,
            g = new CompositeDisposable();
        g.add(currentThreadScheduler.schedule(function() {
          observer.onNext(self.head);
          g.add(self.tail.mergeAll().subscribe(observer));
        }));
        return g;
      }
      inherits(ChainObservable, __super__);
      function ChainObservable(head) {
        __super__.call(this, subscribe);
        this.head = head;
        this.tail = new AsyncSubject();
      }
      addProperties(ChainObservable.prototype, Observer, {
        onCompleted: function() {
          this.onNext(Observable.empty());
        },
        onError: function(e) {
          this.onNext(Observable['throw'](e));
        },
        onNext: function(v) {
          this.tail.onNext(v);
          this.tail.onCompleted();
        }
      });
      return ChainObservable;
    }(Observable));
    observableProto.switchFirst = function() {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var hasCurrent = false,
            isStopped = false,
            m = new SingleAssignmentDisposable(),
            g = new CompositeDisposable();
        g.add(m);
        m.setDisposable(sources.subscribe(function(innerSource) {
          if (!hasCurrent) {
            hasCurrent = true;
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            var innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              o.onError(e);
            }, function() {
              g.remove(innerSubscription);
              hasCurrent = false;
              isStopped && g.length === 1 && o.onCompleted();
            }));
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          isStopped = true;
          !hasCurrent && g.length === 1 && o.onCompleted();
        }));
        return g;
      }, this);
    };
    observableProto.flatMapFirst = observableProto.selectManyFirst = function(selector, resultSelector, thisArg) {
      return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();
    };
    Rx.Observable.prototype.flatMapWithMaxConcurrent = function(limit, selector, resultSelector, thisArg) {
      return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.joinpatterns", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableThrow = Observable.throwError,
        observerCreate = Rx.Observer.create,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        AbstractObserver = Rx.internals.AbstractObserver,
        noop = Rx.helpers.noop,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        Enumerable = Rx.internals.Enumerable,
        Enumerator = Rx.internals.Enumerator,
        $iterator$ = Rx.iterator,
        doneEnumerator = Rx.doneEnumerator,
        bindCallback = Rx.internals.bindCallback;
    var Map = root.Map || (function() {
      function Map() {
        this.size = 0;
        this._values = [];
        this._keys = [];
      }
      Map.prototype['delete'] = function(key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
      };
      Map.prototype.get = function(key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
      };
      Map.prototype.set = function(key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
          this._keys.push(key);
          this._values.push(value);
          this.size++;
        } else {
          this._values[i] = value;
        }
        return this;
      };
      Map.prototype.forEach = function(cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
          cb.call(thisArg, this._values[i], this._keys[i]);
        }
      };
      return Map;
    }());
    function Pattern(patterns) {
      this.patterns = patterns;
    }
    Pattern.prototype.and = function(other) {
      return new Pattern(this.patterns.concat(other));
    };
    Pattern.prototype.thenDo = function(selector) {
      return new Plan(this, selector);
    };
    function Plan(expression, selector) {
      this.expression = expression;
      this.selector = selector;
    }
    Plan.prototype.activate = function(externalSubscriptions, observer, deactivate) {
      var self = this;
      var joinObservers = [];
      for (var i = 0,
          len = this.expression.patterns.length; i < len; i++) {
        joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
      }
      var activePlan = new ActivePlan(joinObservers, function() {
        var result;
        try {
          result = self.selector.apply(self, arguments);
        } catch (e) {
          observer.onError(e);
          return ;
        }
        observer.onNext(result);
      }, function() {
        for (var j = 0,
            jlen = joinObservers.length; j < jlen; j++) {
          joinObservers[j].removeActivePlan(activePlan);
        }
        deactivate(activePlan);
      });
      for (i = 0, len = joinObservers.length; i < len; i++) {
        joinObservers[i].addActivePlan(activePlan);
      }
      return activePlan;
    };
    function planCreateObserver(externalSubscriptions, observable, onError) {
      var entry = externalSubscriptions.get(observable);
      if (!entry) {
        var observer = new JoinObserver(observable, onError);
        externalSubscriptions.set(observable, observer);
        return observer;
      }
      return entry;
    }
    function ActivePlan(joinObserverArray, onNext, onCompleted) {
      this.joinObserverArray = joinObserverArray;
      this.onNext = onNext;
      this.onCompleted = onCompleted;
      this.joinObservers = new Map();
      for (var i = 0,
          len = this.joinObserverArray.length; i < len; i++) {
        var joinObserver = this.joinObserverArray[i];
        this.joinObservers.set(joinObserver, joinObserver);
      }
    }
    ActivePlan.prototype.dequeue = function() {
      this.joinObservers.forEach(function(v) {
        v.queue.shift();
      });
    };
    ActivePlan.prototype.match = function() {
      var i,
          len,
          hasValues = true;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
        if (this.joinObserverArray[i].queue.length === 0) {
          hasValues = false;
          break;
        }
      }
      if (hasValues) {
        var firstValues = [],
            isCompleted = false;
        for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
          firstValues.push(this.joinObserverArray[i].queue[0]);
          this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
        }
        if (isCompleted) {
          this.onCompleted();
        } else {
          this.dequeue();
          var values = [];
          for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
            values.push(firstValues[i].value);
          }
          this.onNext.apply(this, values);
        }
      }
    };
    var JoinObserver = (function(__super__) {
      inherits(JoinObserver, __super__);
      function JoinObserver(source, onError) {
        __super__.call(this);
        this.source = source;
        this.onError = onError;
        this.queue = [];
        this.activePlans = [];
        this.subscription = new SingleAssignmentDisposable();
        this.isDisposed = false;
      }
      var JoinObserverPrototype = JoinObserver.prototype;
      JoinObserverPrototype.next = function(notification) {
        if (!this.isDisposed) {
          if (notification.kind === 'E') {
            return this.onError(notification.exception);
          }
          this.queue.push(notification);
          var activePlans = this.activePlans.slice(0);
          for (var i = 0,
              len = activePlans.length; i < len; i++) {
            activePlans[i].match();
          }
        }
      };
      JoinObserverPrototype.error = noop;
      JoinObserverPrototype.completed = noop;
      JoinObserverPrototype.addActivePlan = function(activePlan) {
        this.activePlans.push(activePlan);
      };
      JoinObserverPrototype.subscribe = function() {
        this.subscription.setDisposable(this.source.materialize().subscribe(this));
      };
      JoinObserverPrototype.removeActivePlan = function(activePlan) {
        this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
        this.activePlans.length === 0 && this.dispose();
      };
      JoinObserverPrototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        if (!this.isDisposed) {
          this.isDisposed = true;
          this.subscription.dispose();
        }
      };
      return JoinObserver;
    }(AbstractObserver));
    observableProto.and = function(right) {
      return new Pattern([this, right]);
    };
    observableProto.thenDo = function(selector) {
      return new Pattern([this]).thenDo(selector);
    };
    Observable.when = function() {
      var len = arguments.length,
          plans;
      if (Array.isArray(arguments[0])) {
        plans = arguments[0];
      } else {
        plans = new Array(len);
        for (var i = 0; i < len; i++) {
          plans[i] = arguments[i];
        }
      }
      return new AnonymousObservable(function(o) {
        var activePlans = [],
            externalSubscriptions = new Map();
        var outObserver = observerCreate(function(x) {
          o.onNext(x);
        }, function(err) {
          externalSubscriptions.forEach(function(v) {
            v.onError(err);
          });
          o.onError(err);
        }, function(x) {
          o.onCompleted();
        });
        try {
          for (var i = 0,
              len = plans.length; i < len; i++) {
            activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function(activePlan) {
              var idx = activePlans.indexOf(activePlan);
              activePlans.splice(idx, 1);
              activePlans.length === 0 && o.onCompleted();
            }));
          }
        } catch (e) {
          observableThrow(e).subscribe(o);
        }
        var group = new CompositeDisposable();
        externalSubscriptions.forEach(function(joinObserver) {
          joinObserver.subscribe();
          group.add(joinObserver);
        });
        return group;
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.sorting", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableNever = Observable.never,
        isEqual = Rx.internals.isEqual,
        defaultSubComparer = Rx.helpers.defaultSubComparer;
    observableProto.jortSort = function() {
      return this.jortSortUntil(observableNever());
    };
    observableProto.jortSortUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var arr = [];
        return source.takeUntil(other).subscribe(arr.push.bind(arr), observer.onError.bind(observer), function() {
          var sorted = arr.slice(0).sort(defaultSubComparer);
          observer.onNext(isEqual(arr, sorted));
          observer.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.virtualtime", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Scheduler = Rx.Scheduler,
        ScheduledItem = Rx.internals.ScheduledItem,
        SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive,
        disposableEmpty = Rx.Disposable.empty,
        inherits = Rx.internals.inherits,
        defaultSubComparer = Rx.helpers.defaultSubComparer,
        notImplemented = Rx.helpers.notImplemented;
    function IndexedItem(id, value) {
      this.id = id;
      this.value = value;
    }
    IndexedItem.prototype.compareTo = function(other) {
      var c = this.value.compareTo(other.value);
      c === 0 && (c = this.id - other.id);
      return c;
    };
    var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
      this.items = new Array(capacity);
      this.length = 0;
    };
    var priorityProto = PriorityQueue.prototype;
    priorityProto.isHigherPriority = function(left, right) {
      return this.items[left].compareTo(this.items[right]) < 0;
    };
    priorityProto.percolate = function(index) {
      if (index >= this.length || index < 0) {
        return ;
      }
      var parent = index - 1 >> 1;
      if (parent < 0 || parent === index) {
        return ;
      }
      if (this.isHigherPriority(index, parent)) {
        var temp = this.items[index];
        this.items[index] = this.items[parent];
        this.items[parent] = temp;
        this.percolate(parent);
      }
    };
    priorityProto.heapify = function(index) {
      +index || (index = 0);
      if (index >= this.length || index < 0) {
        return ;
      }
      var left = 2 * index + 1,
          right = 2 * index + 2,
          first = index;
      if (left < this.length && this.isHigherPriority(left, first)) {
        first = left;
      }
      if (right < this.length && this.isHigherPriority(right, first)) {
        first = right;
      }
      if (first !== index) {
        var temp = this.items[index];
        this.items[index] = this.items[first];
        this.items[first] = temp;
        this.heapify(first);
      }
    };
    priorityProto.peek = function() {
      return this.items[0].value;
    };
    priorityProto.removeAt = function(index) {
      this.items[index] = this.items[--this.length];
      this.items[this.length] = undefined;
      this.heapify();
    };
    priorityProto.dequeue = function() {
      var result = this.peek();
      this.removeAt(0);
      return result;
    };
    priorityProto.enqueue = function(item) {
      var index = this.length++;
      this.items[index] = new IndexedItem(PriorityQueue.count++, item);
      this.percolate(index);
    };
    priorityProto.remove = function(item) {
      for (var i = 0; i < this.length; i++) {
        if (this.items[i].value === item) {
          this.removeAt(i);
          return true;
        }
      }
      return false;
    };
    PriorityQueue.count = 0;
    var VirtualTimeScheduler = Rx.VirtualTimeScheduler = (function(__super__) {
      function localNow() {
        return this.toDateTimeOffset(this.clock);
      }
      function scheduleNow(state, action) {
        return this.scheduleAbsoluteWithState(state, this.clock, action);
      }
      function scheduleRelative(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime), action);
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime - this.now()), action);
      }
      function invokeAction(scheduler, action) {
        action();
        return disposableEmpty;
      }
      inherits(VirtualTimeScheduler, __super__);
      function VirtualTimeScheduler(initialClock, comparer) {
        this.clock = initialClock;
        this.comparer = comparer;
        this.isEnabled = false;
        this.queue = new PriorityQueue(1024);
        __super__.call(this, localNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      }
      var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;
      VirtualTimeSchedulerPrototype.add = notImplemented;
      VirtualTimeSchedulerPrototype.toDateTimeOffset = notImplemented;
      VirtualTimeSchedulerPrototype.toRelative = notImplemented;
      VirtualTimeSchedulerPrototype.schedulePeriodicWithState = function(state, period, action) {
        var s = new SchedulePeriodicRecursive(this, state, period, action);
        return s.start();
      };
      VirtualTimeSchedulerPrototype.scheduleRelativeWithState = function(state, dueTime, action) {
        var runAt = this.add(this.clock, dueTime);
        return this.scheduleAbsoluteWithState(state, runAt, action);
      };
      VirtualTimeSchedulerPrototype.scheduleRelative = function(dueTime, action) {
        return this.scheduleRelativeWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.start = function() {
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
        }
      };
      VirtualTimeSchedulerPrototype.stop = function() {
        this.isEnabled = false;
      };
      VirtualTimeSchedulerPrototype.advanceTo = function(time) {
        var dueToClock = this.comparer(this.clock, time);
        if (this.comparer(this.clock, time) > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return ;
        }
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null && this.comparer(next.dueTime, time) <= 0) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
          this.clock = time;
        }
      };
      VirtualTimeSchedulerPrototype.advanceBy = function(time) {
        var dt = this.add(this.clock, time),
            dueToClock = this.comparer(this.clock, dt);
        if (dueToClock > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return ;
        }
        this.advanceTo(dt);
      };
      VirtualTimeSchedulerPrototype.sleep = function(time) {
        var dt = this.add(this.clock, time);
        if (this.comparer(this.clock, dt) >= 0) {
          throw new ArgumentOutOfRangeError();
        }
        this.clock = dt;
      };
      VirtualTimeSchedulerPrototype.getNext = function() {
        while (this.queue.length > 0) {
          var next = this.queue.peek();
          if (next.isCancelled()) {
            this.queue.dequeue();
          } else {
            return next;
          }
        }
        return null;
      };
      VirtualTimeSchedulerPrototype.scheduleAbsolute = function(dueTime, action) {
        return this.scheduleAbsoluteWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        var self = this;
        function run(scheduler, state1) {
          self.queue.remove(si);
          return action(scheduler, state1);
        }
        var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
        this.queue.enqueue(si);
        return si.disposable;
      };
      return VirtualTimeScheduler;
    }(Scheduler));
    Rx.HistoricalScheduler = (function(__super__) {
      inherits(HistoricalScheduler, __super__);
      function HistoricalScheduler(initialClock, comparer) {
        var clock = initialClock == null ? 0 : initialClock;
        var cmp = comparer || defaultSubComparer;
        __super__.call(this, clock, cmp);
      }
      var HistoricalSchedulerProto = HistoricalScheduler.prototype;
      HistoricalSchedulerProto.add = function(absolute, relative) {
        return absolute + relative;
      };
      HistoricalSchedulerProto.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      HistoricalSchedulerProto.toRelative = function(timeSpan) {
        return timeSpan;
      };
      return HistoricalScheduler;
    }(Rx.VirtualTimeScheduler));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.testing", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx.virtualtime", "exports"], function(Rx, exports) {
        root.Rx = factory(root, exports, Rx);
        return root.Rx;
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observer = Rx.Observer,
        Observable = Rx.Observable,
        Notification = Rx.Notification,
        VirtualTimeScheduler = Rx.VirtualTimeScheduler,
        Disposable = Rx.Disposable,
        disposableEmpty = Disposable.empty,
        disposableCreate = Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        inherits = Rx.internals.inherits,
        defaultComparer = Rx.internals.isEqual;
    function OnNextPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnNextPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'N') {
        return false;
      }
      return this.predicate(other.value);
    };
    function OnErrorPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnErrorPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'E') {
        return false;
      }
      return this.predicate(other.exception);
    };
    var ReactiveTest = Rx.ReactiveTest = {
      created: 100,
      subscribed: 200,
      disposed: 1000,
      onNext: function(ticks, value) {
        return typeof value === 'function' ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));
      },
      onError: function(ticks, error) {
        return typeof error === 'function' ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));
      },
      onCompleted: function(ticks) {
        return new Recorded(ticks, Notification.createOnCompleted());
      },
      subscribe: function(start, end) {
        return new Subscription(start, end);
      }
    };
    var Recorded = Rx.Recorded = function(time, value, comparer) {
      this.time = time;
      this.value = value;
      this.comparer = comparer || defaultComparer;
    };
    Recorded.prototype.equals = function(other) {
      return this.time === other.time && this.comparer(this.value, other.value);
    };
    Recorded.prototype.toString = function() {
      return this.value.toString() + '@' + this.time;
    };
    var Subscription = Rx.Subscription = function(start, end) {
      this.subscribe = start;
      this.unsubscribe = end || Number.MAX_VALUE;
    };
    Subscription.prototype.equals = function(other) {
      return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
    };
    Subscription.prototype.toString = function() {
      return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
    };
    var MockDisposable = Rx.MockDisposable = function(scheduler) {
      this.scheduler = scheduler;
      this.disposes = [];
      this.disposes.push(this.scheduler.clock);
    };
    MockDisposable.prototype.dispose = function() {
      this.disposes.push(this.scheduler.clock);
    };
    var MockObserver = (function(__super__) {
      inherits(MockObserver, __super__);
      function MockObserver(scheduler) {
        __super__.call(this);
        this.scheduler = scheduler;
        this.messages = [];
      }
      var MockObserverPrototype = MockObserver.prototype;
      MockObserverPrototype.onNext = function(value) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
      };
      MockObserverPrototype.onError = function(exception) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(exception)));
      };
      MockObserverPrototype.onCompleted = function() {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
      };
      return MockObserver;
    })(Observer);
    function MockPromise(scheduler, messages) {
      var self = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0,
          len = this.messages.length; i < len; i++) {
        var message = this.messages[i],
            notification = message.value;
        (function(innerNotification) {
          scheduler.scheduleAbsoluteWithState(null, message.time, function() {
            var obs = self.observers.slice(0);
            for (var j = 0,
                jLen = obs.length; j < jLen; j++) {
              innerNotification.accept(obs[j]);
            }
            return disposableEmpty;
          });
        })(notification);
      }
    }
    MockPromise.prototype.then = function(onResolved, onRejected) {
      var self = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var newPromise;
      var observer = Rx.Observer.create(function(x) {
        var retValue = onResolved(x);
        if (retValue && typeof retValue.then === 'function') {
          newPromise = retValue;
        } else {
          var ticks = self.scheduler.clock;
          newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
        }
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      }, function(err) {
        onRejected(err);
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      });
      this.observers.push(observer);
      return newPromise || new MockPromise(this.scheduler, this.messages);
    };
    var HotObservable = (function(__super__) {
      function subscribe(observer) {
        var observable = this;
        this.observers.push(observer);
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        return disposableCreate(function() {
          var idx = observable.observers.indexOf(observer);
          observable.observers.splice(idx, 1);
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        });
      }
      inherits(HotObservable, __super__);
      function HotObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        var message,
            notification,
            observable = this;
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
        this.observers = [];
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            scheduler.scheduleAbsoluteWithState(null, message.time, function() {
              var obs = observable.observers.slice(0);
              for (var j = 0,
                  jLen = obs.length; j < jLen; j++) {
                innerNotification.accept(obs[j]);
              }
              return disposableEmpty;
            });
          })(notification);
        }
      }
      return HotObservable;
    })(Observable);
    var ColdObservable = (function(__super__) {
      function subscribe(observer) {
        var message,
            notification,
            observable = this;
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        var d = new CompositeDisposable();
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            d.add(observable.scheduler.scheduleRelativeWithState(null, message.time, function() {
              innerNotification.accept(observer);
              return disposableEmpty;
            }));
          })(notification);
        }
        return disposableCreate(function() {
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
          d.dispose();
        });
      }
      inherits(ColdObservable, __super__);
      function ColdObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
      }
      return ColdObservable;
    })(Observable);
    Rx.TestScheduler = (function(__super__) {
      inherits(TestScheduler, __super__);
      function baseComparer(x, y) {
        return x > y ? 1 : (x < y ? -1 : 0);
      }
      function TestScheduler() {
        __super__.call(this, 0, baseComparer);
      }
      TestScheduler.prototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        dueTime <= this.clock && (dueTime = this.clock + 1);
        return __super__.prototype.scheduleAbsoluteWithState.call(this, state, dueTime, action);
      };
      TestScheduler.prototype.add = function(absolute, relative) {
        return absolute + relative;
      };
      TestScheduler.prototype.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      TestScheduler.prototype.toRelative = function(timeSpan) {
        return timeSpan;
      };
      TestScheduler.prototype.startWithTiming = function(create, created, subscribed, disposed) {
        var observer = this.createObserver(),
            source,
            subscription;
        this.scheduleAbsoluteWithState(null, created, function() {
          source = create();
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, subscribed, function() {
          subscription = source.subscribe(observer);
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, disposed, function() {
          subscription.dispose();
          return disposableEmpty;
        });
        this.start();
        return observer;
      };
      TestScheduler.prototype.startWithDispose = function(create, disposed) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, disposed);
      };
      TestScheduler.prototype.startWithCreate = function(create) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, ReactiveTest.disposed);
      };
      TestScheduler.prototype.createHotObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new HotObservable(this, args);
      };
      TestScheduler.prototype.createColdObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ColdObservable(this, args);
      };
      TestScheduler.prototype.createResolvedPromise = function(ticks, value) {
        return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
      };
      TestScheduler.prototype.createRejectedPromise = function(ticks, reason) {
        return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
      };
      TestScheduler.prototype.createObserver = function() {
        return new MockObserver(this);
      };
      return TestScheduler;
    })(VirtualTimeScheduler);
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/dist/rx.time", ["npm:rx@3.0.0/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'function': true,
      'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeSelf = objectTypes[typeof self] && self.Object && self,
        freeWindow = objectTypes[typeof window] && window && window.Object && window,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@3.0.0/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        observableThrow = Observable['throw'],
        observableFromArray = Observable.fromArray,
        timeoutScheduler = Rx.Scheduler['default'],
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        Subject = Rx.Subject,
        addRef = Rx.internals.addRef,
        normalizeTime = Rx.Scheduler.normalize,
        helpers = Rx.helpers,
        isPromise = helpers.isPromise,
        isFunction = helpers.isFunction,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function observableTimerDate(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithAbsolute(dueTime, function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerDateAndPeriod(dueTime, period, scheduler) {
      return new AnonymousObservable(function(observer) {
        var d = dueTime,
            p = normalizeTime(period);
        return scheduler.scheduleRecursiveWithAbsoluteAndState(0, d, function(count, self) {
          if (p > 0) {
            var now = scheduler.now();
            d = d + p;
            d <= now && (d = now + p);
          }
          observer.onNext(count);
          self(count + 1, d);
        });
      });
    }
    function observableTimerTimeSpan(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithRelative(normalizeTime(dueTime), function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
      return dueTime === period ? new AnonymousObservable(function(observer) {
        return scheduler.schedulePeriodicWithState(0, period, function(count) {
          observer.onNext(count);
          return count + 1;
        });
      }) : observableDefer(function() {
        return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);
      });
    }
    var observableinterval = Observable.interval = function(period, scheduler) {
      return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);
    };
    var observableTimer = Observable.timer = function(dueTime, periodOrScheduler, scheduler) {
      var period;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {
        period = periodOrScheduler;
      } else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
      }
      if (dueTime instanceof Date && period === undefined) {
        return observableTimerDate(dueTime.getTime(), scheduler);
      }
      if (dueTime instanceof Date && period !== undefined) {
        return observableTimerDateAndPeriod(dueTime.getTime(), periodOrScheduler, scheduler);
      }
      return period === undefined ? observableTimerTimeSpan(dueTime, scheduler) : observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
    };
    function observableDelayTimeSpan(source, dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        var active = false,
            cancelable = new SerialDisposable(),
            exception = null,
            q = [],
            running = false,
            subscription;
        subscription = source.materialize().timestamp(scheduler).subscribe(function(notification) {
          var d,
              shouldRun;
          if (notification.value.kind === 'E') {
            q = [];
            q.push(notification);
            exception = notification.value.exception;
            shouldRun = !running;
          } else {
            q.push({
              value: notification.value,
              timestamp: notification.timestamp + dueTime
            });
            shouldRun = !active;
            active = true;
          }
          if (shouldRun) {
            if (exception !== null) {
              observer.onError(exception);
            } else {
              d = new SingleAssignmentDisposable();
              cancelable.setDisposable(d);
              d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function(self) {
                var e,
                    recurseDueTime,
                    result,
                    shouldRecurse;
                if (exception !== null) {
                  return ;
                }
                running = true;
                do {
                  result = null;
                  if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                    result = q.shift().value;
                  }
                  if (result !== null) {
                    result.accept(observer);
                  }
                } while (result !== null);
                shouldRecurse = false;
                recurseDueTime = 0;
                if (q.length > 0) {
                  shouldRecurse = true;
                  recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
                } else {
                  active = false;
                }
                e = exception;
                running = false;
                if (e !== null) {
                  observer.onError(e);
                } else if (shouldRecurse) {
                  self(recurseDueTime);
                }
              }));
            }
          }
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    }
    function observableDelayDate(source, dueTime, scheduler) {
      return observableDefer(function() {
        return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);
      });
    }
    observableProto.delay = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return dueTime instanceof Date ? observableDelayDate(this, dueTime.getTime(), scheduler) : observableDelayTimeSpan(this, dueTime, scheduler);
    };
    observableProto.debounce = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var cancelable = new SerialDisposable(),
            hasvalue = false,
            value,
            id = 0;
        var subscription = source.subscribe(function(x) {
          hasvalue = true;
          value = x;
          id++;
          var currentId = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(scheduler.scheduleWithRelative(dueTime, function() {
            hasvalue && id === currentId && observer.onNext(value);
            hasvalue = false;
          }));
        }, function(e) {
          cancelable.dispose();
          observer.onError(e);
          hasvalue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasvalue && observer.onNext(value);
          observer.onCompleted();
          hasvalue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, this);
    };
    observableProto.throttle = function(dueTime, scheduler) {
      return this.debounce(dueTime, scheduler);
    };
    observableProto.windowWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      var source = this,
          timeShift;
      timeShiftOrScheduler == null && (timeShift = timeSpan);
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (typeof timeShiftOrScheduler === 'number') {
        timeShift = timeShiftOrScheduler;
      } else if (isScheduler(timeShiftOrScheduler)) {
        timeShift = timeSpan;
        scheduler = timeShiftOrScheduler;
      }
      return new AnonymousObservable(function(observer) {
        var groupDisposable,
            nextShift = timeShift,
            nextSpan = timeSpan,
            q = [],
            refCountDisposable,
            timerD = new SerialDisposable(),
            totalTime = 0;
        groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);
        function createTimer() {
          var m = new SingleAssignmentDisposable(),
              isSpan = false,
              isShift = false;
          timerD.setDisposable(m);
          if (nextSpan === nextShift) {
            isSpan = true;
            isShift = true;
          } else if (nextSpan < nextShift) {
            isSpan = true;
          } else {
            isShift = true;
          }
          var newTotalTime = isSpan ? nextSpan : nextShift,
              ts = newTotalTime - totalTime;
          totalTime = newTotalTime;
          if (isSpan) {
            nextSpan += timeShift;
          }
          if (isShift) {
            nextShift += timeShift;
          }
          m.setDisposable(scheduler.scheduleWithRelative(ts, function() {
            if (isShift) {
              var s = new Subject();
              q.push(s);
              observer.onNext(addRef(s, refCountDisposable));
            }
            isSpan && q.shift().onCompleted();
            createTimer();
          }));
        }
        ;
        q.push(new Subject());
        observer.onNext(addRef(q[0], refCountDisposable));
        createTimer();
        groupDisposable.add(source.subscribe(function(x) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onNext(x);
          }
        }, function(e) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onError(e);
          }
          observer.onError(e);
        }, function() {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onCompleted();
          }
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    observableProto.windowWithTimeOrCount = function(timeSpan, count, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var timerD = new SerialDisposable(),
            groupDisposable = new CompositeDisposable(timerD),
            refCountDisposable = new RefCountDisposable(groupDisposable),
            n = 0,
            windowId = 0,
            s = new Subject();
        function createTimer(id) {
          var m = new SingleAssignmentDisposable();
          timerD.setDisposable(m);
          m.setDisposable(scheduler.scheduleWithRelative(timeSpan, function() {
            if (id !== windowId) {
              return ;
            }
            n = 0;
            var newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
            createTimer(newId);
          }));
        }
        observer.onNext(addRef(s, refCountDisposable));
        createTimer(0);
        groupDisposable.add(source.subscribe(function(x) {
          var newId = 0,
              newWindow = false;
          s.onNext(x);
          if (++n === count) {
            newWindow = true;
            n = 0;
            newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
          }
          newWindow && createTimer(newId);
        }, function(e) {
          s.onError(e);
          observer.onError(e);
        }, function() {
          s.onCompleted();
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    function toArray(x) {
      return x.toArray();
    }
    observableProto.bufferWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);
    };
    function toArray(x) {
      return x.toArray();
    }
    observableProto.bufferWithTimeOrCount = function(timeSpan, count, scheduler) {
      return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);
    };
    observableProto.timeInterval = function(scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return observableDefer(function() {
        var last = scheduler.now();
        return source.map(function(x) {
          var now = scheduler.now(),
              span = now - last;
          last = now;
          return {
            value: x,
            interval: span
          };
        });
      });
    };
    observableProto.timestamp = function(scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return this.map(function(x) {
        return {
          value: x,
          timestamp: scheduler.now()
        };
      });
    };
    function sampleObservable(source, sampler) {
      return new AnonymousObservable(function(o) {
        var atEnd = false,
            value,
            hasValue = false;
        function sampleSubscribe() {
          if (hasValue) {
            hasValue = false;
            o.onNext(value);
          }
          atEnd && o.onCompleted();
        }
        var sourceSubscription = new SingleAssignmentDisposable();
        sourceSubscription.setDisposable(source.subscribe(function(newValue) {
          hasValue = true;
          value = newValue;
        }, function(e) {
          o.onError(e);
        }, function() {
          atEnd = true;
          sourceSubscription.dispose();
        }));
        return new CompositeDisposable(sourceSubscription, sampler.subscribe(sampleSubscribe, function(e) {
          o.onError(e);
        }, sampleSubscribe));
      }, source);
    }
    observableProto.sample = observableProto.throttleLatest = function(intervalOrSampler, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return typeof intervalOrSampler === 'number' ? sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : sampleObservable(this, intervalOrSampler);
    };
    observableProto.timeout = function(dueTime, other, scheduler) {
      (other == null || typeof other === 'string') && (other = observableThrow(new Error(other || 'Timeout')));
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(observer) {
        var id = 0,
            original = new SingleAssignmentDisposable(),
            subscription = new SerialDisposable(),
            switched = false,
            timer = new SerialDisposable();
        subscription.setDisposable(original);
        function createTimer() {
          var myId = id;
          timer.setDisposable(scheduler[schedulerMethod](dueTime, function() {
            if (id === myId) {
              isPromise(other) && (other = observableFromPromise(other));
              subscription.setDisposable(other.subscribe(observer));
            }
          }));
        }
        createTimer();
        original.setDisposable(source.subscribe(function(x) {
          if (!switched) {
            id++;
            observer.onNext(x);
            createTimer();
          }
        }, function(e) {
          if (!switched) {
            id++;
            observer.onError(e);
          }
        }, function() {
          if (!switched) {
            id++;
            observer.onCompleted();
          }
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    Observable.generateWithAbsoluteTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithAbsoluteAndState(initialState, scheduler.now(), function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return ;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    Observable.generateWithRelativeTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithRelativeAndState(initialState, 0, function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return ;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    observableProto.delaySubscription = function(dueTime, scheduler) {
      var scheduleMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var d = new SerialDisposable();
        d.setDisposable(scheduler[scheduleMethod](dueTime, function() {
          d.setDisposable(source.subscribe(o));
        }));
        return d;
      }, this);
    };
    observableProto.delayWithSelector = function(subscriptionDelay, delayDurationSelector) {
      var source = this,
          subDelay,
          selector;
      if (isFunction(subscriptionDelay)) {
        selector = subscriptionDelay;
      } else {
        subDelay = subscriptionDelay;
        selector = delayDurationSelector;
      }
      return new AnonymousObservable(function(observer) {
        var delays = new CompositeDisposable(),
            atEnd = false,
            subscription = new SerialDisposable();
        function start() {
          subscription.setDisposable(source.subscribe(function(x) {
            var delay = tryCatch(selector)(x);
            if (delay === errorObj) {
              return observer.onError(delay.e);
            }
            var d = new SingleAssignmentDisposable();
            delays.add(d);
            d.setDisposable(delay.subscribe(function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }, function(e) {
              observer.onError(e);
            }, function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }));
          }, function(e) {
            observer.onError(e);
          }, function() {
            atEnd = true;
            subscription.dispose();
            done();
          }));
        }
        function done() {
          atEnd && delays.length === 0 && observer.onCompleted();
        }
        if (!subDelay) {
          start();
        } else {
          subscription.setDisposable(subDelay.subscribe(start, function(e) {
            observer.onError(e);
          }, start));
        }
        return new CompositeDisposable(subscription, delays);
      }, this);
    };
    observableProto.timeoutWithSelector = function(firstTimeout, timeoutdurationSelector, other) {
      if (arguments.length === 1) {
        timeoutdurationSelector = firstTimeout;
        firstTimeout = observableNever();
      }
      other || (other = observableThrow(new Error('Timeout')));
      var source = this;
      return new AnonymousObservable(function(observer) {
        var subscription = new SerialDisposable(),
            timer = new SerialDisposable(),
            original = new SingleAssignmentDisposable();
        subscription.setDisposable(original);
        var id = 0,
            switched = false;
        function setTimer(timeout) {
          var myId = id;
          function timerWins() {
            return id === myId;
          }
          var d = new SingleAssignmentDisposable();
          timer.setDisposable(d);
          d.setDisposable(timeout.subscribe(function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
            d.dispose();
          }, function(e) {
            timerWins() && observer.onError(e);
          }, function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
          }));
        }
        ;
        setTimer(firstTimeout);
        function observerWins() {
          var res = !switched;
          if (res) {
            id++;
          }
          return res;
        }
        original.setDisposable(source.subscribe(function(x) {
          if (observerWins()) {
            observer.onNext(x);
            var timeout;
            try {
              timeout = timeoutdurationSelector(x);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
          }
        }, function(e) {
          observerWins() && observer.onError(e);
        }, function() {
          observerWins() && observer.onCompleted();
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    observableProto.debounceWithSelector = function(durationSelector) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var value,
            hasValue = false,
            cancelable = new SerialDisposable(),
            id = 0;
        var subscription = source.subscribe(function(x) {
          var throttle = tryCatch(durationSelector)(x);
          if (throttle === errorObj) {
            return o.onError(throttle.e);
          }
          isPromise(throttle) && (throttle = observableFromPromise(throttle));
          hasValue = true;
          value = x;
          id++;
          var currentid = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(throttle.subscribe(function() {
            hasValue && id === currentid && o.onNext(value);
            hasValue = false;
            d.dispose();
          }, function(e) {
            o.onError(e);
          }, function() {
            hasValue && id === currentid && o.onNext(value);
            hasValue = false;
            d.dispose();
          }));
        }, function(e) {
          cancelable.dispose();
          o.onError(e);
          hasValue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasValue && o.onNext(value);
          o.onCompleted();
          hasValue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    };
    observableProto.skipLastWithTime = function(duration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0) {
            var next = q.shift();
            if (now - next.interval <= duration) {
              o.onNext(next.value);
            }
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastBufferWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now(),
              res = [];
          while (q.length > 0) {
            var next = q.shift();
            now - next.interval <= duration && res.push(next.value);
          }
          o.onNext(res);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.skipWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var open = false;
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && observer.onNext(x);
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer)));
      }, source);
    };
    observableProto.skipUntilWithTime = function(startTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = startTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        var open = false;
        return new CompositeDisposable(scheduler[schedulerMethod](startTime, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        }));
      }, source);
    };
    observableProto.takeUntilWithTime = function(endTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = endTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler[schedulerMethod](endTime, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.throttleFirst = function(windowDuration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var duration = +windowDuration || 0;
      if (duration <= 0) {
        throw new RangeError('windowDuration cannot be less or equal zero.');
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var lastOnNext = 0;
        return source.subscribe(function(x) {
          var now = scheduler.now();
          if (lastOnNext === 0 || now - lastOnNext >= duration) {
            lastOnNext = now;
            o.onNext(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:base64-js@0.0.8/lib/b64", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

System.register("npm:ieee754@1.1.6/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:is-array@1.0.1/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var isArray = Array.isArray;
  var str = Object.prototype.toString;
  module.exports = isArray || function(val) {
    return !!val && '[object Array]' == str.call(val);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14/lib/adapter", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports.RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;
  module.exports.RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
  module.exports.RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;
  global.define = __define;
  return module.exports;
});

System.register("npm:eventemitter3@0.1.6/index", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function EventEmitter() {}
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype.listeners = function listeners(event) {
    if (!this._events || !this._events[event])
      return [];
    if (this._events[event].fn)
      return [this._events[event].fn];
    for (var i = 0,
        l = this._events[event].length,
        ee = new Array(l); i < l; i++) {
      ee[i] = this._events[event][i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    if (!this._events || !this._events[event])
      return false;
    var listeners = this._events[event],
        len = arguments.length,
        args,
        i;
    if ('function' === typeof listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
          j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    var listener = new EE(fn, context || this);
    if (!this._events)
      this._events = {};
    if (!this._events[event])
      this._events[event] = listener;
    else {
      if (!this._events[event].fn)
        this._events[event].push(listener);
      else
        this._events[event] = [this._events[event], listener];
    }
    return this;
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    var listener = new EE(fn, context || this, true);
    if (!this._events)
      this._events = {};
    if (!this._events[event])
      this._events[event] = listener;
    else {
      if (!this._events[event].fn)
        this._events[event].push(listener);
      else
        this._events[event] = [this._events[event], listener];
    }
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
    if (!this._events || !this._events[event])
      return this;
    var listeners = this._events[event],
        events = [];
    if (fn) {
      if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {
        events.push(listeners);
      }
      if (!listeners.fn)
        for (var i = 0,
            length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || (once && !listeners[i].once)) {
            events.push(listeners[i]);
          }
        }
    }
    if (events.length) {
      this._events[event] = events.length === 1 ? events[0] : events;
    } else {
      delete this._events[event];
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    if (!this._events)
      return this;
    if (event)
      delete this._events[event];
    else
      this._events = {};
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
    return this;
  };
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.EventEmitter2 = EventEmitter;
  EventEmitter.EventEmitter3 = EventEmitter;
  module.exports = EventEmitter;
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14/lib/socket", ["npm:peerjs@0.3.14/lib/util", "npm:eventemitter3@0.1.6", "github:jspm/nodelibs-buffer@0.1.0", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer, process) {
    var util = require("npm:peerjs@0.3.14/lib/util");
    var EventEmitter = require("npm:eventemitter3@0.1.6");
    function Socket(secure, host, port, path, key) {
      if (!(this instanceof Socket))
        return new Socket(secure, host, port, path, key);
      EventEmitter.call(this);
      this.disconnected = false;
      this._queue = [];
      var httpProtocol = secure ? 'https://' : 'http://';
      var wsProtocol = secure ? 'wss://' : 'ws://';
      this._httpUrl = httpProtocol + host + ':' + port + path + key;
      this._wsUrl = wsProtocol + host + ':' + port + path + 'peerjs?key=' + key;
    }
    util.inherits(Socket, EventEmitter);
    Socket.prototype.start = function(id, token) {
      this.id = id;
      this._httpUrl += '/' + id + '/' + token;
      this._wsUrl += '&id=' + id + '&token=' + token;
      this._startXhrStream();
      this._startWebSocket();
    };
    Socket.prototype._startWebSocket = function(id) {
      var self = this;
      if (this._socket) {
        return ;
      }
      this._socket = new WebSocket(this._wsUrl);
      this._socket.onmessage = function(event) {
        try {
          var data = JSON.parse(event.data);
        } catch (e) {
          util.log('Invalid server message', event.data);
          return ;
        }
        self.emit('message', data);
      };
      this._socket.onclose = function(event) {
        util.log('Socket closed.');
        self.disconnected = true;
        self.emit('disconnected');
      };
      this._socket.onopen = function() {
        if (self._timeout) {
          clearTimeout(self._timeout);
          setTimeout(function() {
            self._http.abort();
            self._http = null;
          }, 5000);
        }
        self._sendQueuedMessages();
        util.log('Socket open');
      };
    };
    Socket.prototype._startXhrStream = function(n) {
      try {
        var self = this;
        this._http = new XMLHttpRequest();
        this._http._index = 1;
        this._http._streamIndex = n || 0;
        this._http.open('post', this._httpUrl + '/id?i=' + this._http._streamIndex, true);
        this._http.onerror = function() {
          clearTimeout(self._timeout);
          self.emit('disconnected');
        };
        this._http.onreadystatechange = function() {
          if (this.readyState == 2 && this.old) {
            this.old.abort();
            delete this.old;
          } else if (this.readyState > 2 && this.status === 200 && this.responseText) {
            self._handleStream(this);
          }
        };
        this._http.send(null);
        this._setHTTPTimeout();
      } catch (e) {
        util.log('XMLHttpRequest not available; defaulting to WebSockets');
      }
    };
    Socket.prototype._handleStream = function(http) {
      var messages = http.responseText.split('\n');
      if (http._buffer) {
        while (http._buffer.length > 0) {
          var index = http._buffer.shift();
          var bufferedMessage = messages[index];
          try {
            bufferedMessage = JSON.parse(bufferedMessage);
          } catch (e) {
            http._buffer.shift(index);
            break;
          }
          this.emit('message', bufferedMessage);
        }
      }
      var message = messages[http._index];
      if (message) {
        http._index += 1;
        if (http._index === messages.length) {
          if (!http._buffer) {
            http._buffer = [];
          }
          http._buffer.push(http._index - 1);
        } else {
          try {
            message = JSON.parse(message);
          } catch (e) {
            util.log('Invalid server message', message);
            return ;
          }
          this.emit('message', message);
        }
      }
    };
    Socket.prototype._setHTTPTimeout = function() {
      var self = this;
      this._timeout = setTimeout(function() {
        var old = self._http;
        if (!self._wsOpen()) {
          self._startXhrStream(old._streamIndex + 1);
          self._http.old = old;
        } else {
          old.abort();
        }
      }, 25000);
    };
    Socket.prototype._wsOpen = function() {
      return this._socket && this._socket.readyState == 1;
    };
    Socket.prototype._sendQueuedMessages = function() {
      for (var i = 0,
          ii = this._queue.length; i < ii; i += 1) {
        this.send(this._queue[i]);
      }
    };
    Socket.prototype.send = function(data) {
      if (this.disconnected) {
        return ;
      }
      if (!this.id) {
        this._queue.push(data);
        return ;
      }
      if (!data.type) {
        this.emit('error', 'Invalid message');
        return ;
      }
      var message = JSON.stringify(data);
      if (this._wsOpen()) {
        this._socket.send(message);
      } else {
        var http = new XMLHttpRequest();
        var url = this._httpUrl + '/' + data.type.toLowerCase();
        http.open('post', url, true);
        http.setRequestHeader('Content-Type', 'application/json');
        http.send(message);
      }
    };
    Socket.prototype.close = function() {
      if (!this.disconnected && this._wsOpen()) {
        this._socket.close();
        this.disconnected = true;
      }
    };
    module.exports = Socket;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer, require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14/lib/negotiator", ["npm:peerjs@0.3.14/lib/util", "npm:peerjs@0.3.14/lib/adapter", "npm:peerjs@0.3.14/lib/adapter", "npm:peerjs@0.3.14/lib/adapter"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var util = require("npm:peerjs@0.3.14/lib/util");
  var RTCPeerConnection = require("npm:peerjs@0.3.14/lib/adapter").RTCPeerConnection;
  var RTCSessionDescription = require("npm:peerjs@0.3.14/lib/adapter").RTCSessionDescription;
  var RTCIceCandidate = require("npm:peerjs@0.3.14/lib/adapter").RTCIceCandidate;
  var Negotiator = {
    pcs: {
      data: {},
      media: {}
    },
    queue: []
  };
  Negotiator._idPrefix = 'pc_';
  Negotiator.startConnection = function(connection, options) {
    var pc = Negotiator._getPeerConnection(connection, options);
    if (connection.type === 'media' && options._stream) {
      pc.addStream(options._stream);
    }
    connection.pc = connection.peerConnection = pc;
    if (options.originator) {
      if (connection.type === 'data') {
        var config = {};
        if (!util.supports.sctp) {
          config = {reliable: options.reliable};
        }
        var dc = pc.createDataChannel(connection.label, config);
        connection.initialize(dc);
      }
      if (!util.supports.onnegotiationneeded) {
        Negotiator._makeOffer(connection);
      }
    } else {
      Negotiator.handleSDP('OFFER', connection, options.sdp);
    }
  };
  Negotiator._getPeerConnection = function(connection, options) {
    if (!Negotiator.pcs[connection.type]) {
      util.error(connection.type + ' is not a valid connection type. Maybe you overrode the `type` property somewhere.');
    }
    if (!Negotiator.pcs[connection.type][connection.peer]) {
      Negotiator.pcs[connection.type][connection.peer] = {};
    }
    var peerConnections = Negotiator.pcs[connection.type][connection.peer];
    var pc;
    if (options.pc) {
      pc = Negotiator.pcs[connection.type][connection.peer][options.pc];
    }
    if (!pc || pc.signalingState !== 'stable') {
      pc = Negotiator._startPeerConnection(connection);
    }
    return pc;
  };
  Negotiator._startPeerConnection = function(connection) {
    util.log('Creating RTCPeerConnection.');
    var id = Negotiator._idPrefix + util.randomToken();
    var optional = {};
    if (connection.type === 'data' && !util.supports.sctp) {
      optional = {optional: [{RtpDataChannels: true}]};
    } else if (connection.type === 'media') {
      optional = {optional: [{DtlsSrtpKeyAgreement: true}]};
    }
    var pc = new RTCPeerConnection(connection.provider.options.config, optional);
    Negotiator.pcs[connection.type][connection.peer][id] = pc;
    Negotiator._setupListeners(connection, pc, id);
    return pc;
  };
  Negotiator._setupListeners = function(connection, pc, pc_id) {
    var peerId = connection.peer;
    var connectionId = connection.id;
    var provider = connection.provider;
    util.log('Listening for ICE candidates.');
    pc.onicecandidate = function(evt) {
      if (evt.candidate) {
        util.log('Received ICE candidates for:', connection.peer);
        provider.socket.send({
          type: 'CANDIDATE',
          payload: {
            candidate: evt.candidate,
            type: connection.type,
            connectionId: connection.id
          },
          dst: peerId
        });
      }
    };
    pc.oniceconnectionstatechange = function() {
      switch (pc.iceConnectionState) {
        case 'disconnected':
        case 'failed':
          util.log('iceConnectionState is disconnected, closing connections to ' + peerId);
          connection.close();
          break;
        case 'completed':
          pc.onicecandidate = util.noop;
          break;
      }
    };
    pc.onicechange = pc.oniceconnectionstatechange;
    util.log('Listening for `negotiationneeded`');
    pc.onnegotiationneeded = function() {
      util.log('`negotiationneeded` triggered');
      if (pc.signalingState == 'stable') {
        Negotiator._makeOffer(connection);
      } else {
        util.log('onnegotiationneeded triggered when not stable. Is another connection being established?');
      }
    };
    util.log('Listening for data channel');
    pc.ondatachannel = function(evt) {
      util.log('Received data channel');
      var dc = evt.channel;
      var connection = provider.getConnection(peerId, connectionId);
      connection.initialize(dc);
    };
    util.log('Listening for remote stream');
    pc.onaddstream = function(evt) {
      util.log('Received remote stream');
      var stream = evt.stream;
      var connection = provider.getConnection(peerId, connectionId);
      if (connection.type === 'media') {
        connection.addStream(stream);
      }
    };
  };
  Negotiator.cleanup = function(connection) {
    util.log('Cleaning up PeerConnection to ' + connection.peer);
    var pc = connection.pc;
    if (!!pc && (pc.readyState !== 'closed' || pc.signalingState !== 'closed')) {
      pc.close();
      connection.pc = null;
    }
  };
  Negotiator._makeOffer = function(connection) {
    var pc = connection.pc;
    pc.createOffer(function(offer) {
      util.log('Created offer.');
      if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
        offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);
      }
      pc.setLocalDescription(offer, function() {
        util.log('Set localDescription: offer', 'for:', connection.peer);
        connection.provider.socket.send({
          type: 'OFFER',
          payload: {
            sdp: offer,
            type: connection.type,
            label: connection.label,
            connectionId: connection.id,
            reliable: connection.reliable,
            serialization: connection.serialization,
            metadata: connection.metadata,
            browser: util.browser
          },
          dst: connection.peer
        });
      }, function(err) {
        connection.provider.emitError('webrtc', err);
        util.log('Failed to setLocalDescription, ', err);
      });
    }, function(err) {
      connection.provider.emitError('webrtc', err);
      util.log('Failed to createOffer, ', err);
    }, connection.options.constraints);
  };
  Negotiator._makeAnswer = function(connection) {
    var pc = connection.pc;
    pc.createAnswer(function(answer) {
      util.log('Created answer.');
      if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
        answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);
      }
      pc.setLocalDescription(answer, function() {
        util.log('Set localDescription: answer', 'for:', connection.peer);
        connection.provider.socket.send({
          type: 'ANSWER',
          payload: {
            sdp: answer,
            type: connection.type,
            connectionId: connection.id,
            browser: util.browser
          },
          dst: connection.peer
        });
      }, function(err) {
        connection.provider.emitError('webrtc', err);
        util.log('Failed to setLocalDescription, ', err);
      });
    }, function(err) {
      connection.provider.emitError('webrtc', err);
      util.log('Failed to create answer, ', err);
    });
  };
  Negotiator.handleSDP = function(type, connection, sdp) {
    sdp = new RTCSessionDescription(sdp);
    var pc = connection.pc;
    util.log('Setting remote description', sdp);
    pc.setRemoteDescription(sdp, function() {
      util.log('Set remoteDescription:', type, 'for:', connection.peer);
      if (type === 'OFFER') {
        Negotiator._makeAnswer(connection);
      }
    }, function(err) {
      connection.provider.emitError('webrtc', err);
      util.log('Failed to setRemoteDescription, ', err);
    });
  };
  Negotiator.handleCandidate = function(connection, ice) {
    var candidate = ice.candidate;
    var sdpMLineIndex = ice.sdpMLineIndex;
    connection.pc.addIceCandidate(new RTCIceCandidate({
      sdpMLineIndex: sdpMLineIndex,
      candidate: candidate
    }));
    util.log('Added ICE candidate for:', connection.peer);
  };
  module.exports = Negotiator;
  global.define = __define;
  return module.exports;
});

System.register("github:michelle/reliable@master/lib/util", ["npm:js-binarypack@0.0.9"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var BinaryPack = require("npm:js-binarypack@0.0.9");
  var util = {
    debug: false,
    inherits: function(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    },
    extend: function(dest, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          dest[key] = source[key];
        }
      }
      return dest;
    },
    pack: BinaryPack.pack,
    unpack: BinaryPack.unpack,
    log: function() {
      if (util.debug) {
        var copy = [];
        for (var i = 0; i < arguments.length; i++) {
          copy[i] = arguments[i];
        }
        copy.unshift('Reliable: ');
        console.log.apply(console, copy);
      }
    },
    setZeroTimeout: (function(global) {
      var timeouts = [];
      var messageName = 'zero-timeout-message';
      function setZeroTimeoutPostMessage(fn) {
        timeouts.push(fn);
        global.postMessage(messageName, '*');
      }
      function handleMessage(event) {
        if (event.source == global && event.data == messageName) {
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (timeouts.length) {
            timeouts.shift()();
          }
        }
      }
      if (global.addEventListener) {
        global.addEventListener('message', handleMessage, true);
      } else if (global.attachEvent) {
        global.attachEvent('onmessage', handleMessage);
      }
      return setZeroTimeoutPostMessage;
    }(this)),
    blobToArrayBuffer: function(blob, cb) {
      var fr = new FileReader();
      fr.onload = function(evt) {
        cb(evt.target.result);
      };
      fr.readAsArrayBuffer(blob);
    },
    blobToBinaryString: function(blob, cb) {
      var fr = new FileReader();
      fr.onload = function(evt) {
        cb(evt.target.result);
      };
      fr.readAsBinaryString(blob);
    },
    binaryStringToArrayBuffer: function(binary) {
      var byteArray = new Uint8Array(binary.length);
      for (var i = 0; i < binary.length; i++) {
        byteArray[i] = binary.charCodeAt(i) & 0xff;
      }
      return byteArray.buffer;
    },
    randomToken: function() {
      return Math.random().toString(36).substr(2);
    }
  };
  module.exports = util;
  global.define = __define;
  return module.exports;
});

System.register("npm:adapterjs@0.11.1/publish/adapter.min", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var AdapterJS = AdapterJS || {};
  if ("undefined" != typeof exports && (module.exports = AdapterJS), AdapterJS.options = AdapterJS.options || {}, AdapterJS.VERSION = "0.11.1", AdapterJS.onwebrtcready = AdapterJS.onwebrtcready || function() {}, AdapterJS.webRTCReady = function(callback) {
    if ("function" != typeof callback)
      throw new Error("Callback provided is not a function");
    !0 === AdapterJS.onwebrtcreadyDone ? callback(null !== AdapterJS.WebRTCPlugin.plugin) : AdapterJS.onwebrtcready = callback;
  }, AdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {}, AdapterJS.WebRTCPlugin.pluginInfo = {
    prefix: "Tem",
    plugName: "TemWebRTCPlugin",
    pluginId: "plugin0",
    type: "application/x-temwebrtcplugin",
    onload: "__TemWebRTCReady0",
    portalLink: "http://skylink.io/plugin/",
    downloadLink: null,
    companyName: "Temasys"
  }, navigator.platform.match(/^Mac/i) ? AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = "http://bit.ly/1n77hco" : navigator.platform.match(/^Win/i) && (AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = "http://bit.ly/1kkS4FN"), AdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2), AdapterJS.WebRTCPlugin.plugin = null, AdapterJS.WebRTCPlugin.setLogLevel = null, AdapterJS.WebRTCPlugin.defineWebRTCInterface = null, AdapterJS.WebRTCPlugin.isPluginInstalled = null, AdapterJS.WebRTCPlugin.pluginInjectionInterval = null, AdapterJS.WebRTCPlugin.injectPlugin = null, AdapterJS.WebRTCPlugin.PLUGIN_STATES = {
    NONE: 0,
    INITIALIZING: 1,
    INJECTING: 2,
    INJECTED: 3,
    READY: 4
  }, AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE, AdapterJS.onwebrtcreadyDone = !1, AdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {
    NONE: "NONE",
    ERROR: "ERROR",
    WARNING: "WARNING",
    INFO: "INFO",
    VERBOSE: "VERBOSE",
    SENSITIVE: "SENSITIVE"
  }, AdapterJS.WebRTCPlugin.WaitForPluginReady = null, AdapterJS.WebRTCPlugin.callWhenPluginReady = null, __TemWebRTCReady0 = function() {
    "complete" === document.readyState ? (AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY, AdapterJS.maybeThroughWebRTCReady()) : AdapterJS.WebRTCPlugin.documentReadyInterval = setInterval(function() {
      "complete" === document.readyState && (clearInterval(AdapterJS.WebRTCPlugin.documentReadyInterval), AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY, AdapterJS.maybeThroughWebRTCReady());
    }, 100);
  }, AdapterJS.maybeThroughWebRTCReady = function() {
    AdapterJS.onwebrtcreadyDone || (AdapterJS.onwebrtcreadyDone = !0, "function" == typeof AdapterJS.onwebrtcready && AdapterJS.onwebrtcready(null !== AdapterJS.WebRTCPlugin.plugin));
  }, AdapterJS.TEXT = {
    PLUGIN: {
      REQUIRE_INSTALLATION: "This website requires you to install a WebRTC-enabling plugin to work on this browser.",
      NOT_SUPPORTED: "Your browser does not support WebRTC.",
      BUTTON: "Install Now"
    },
    REFRESH: {
      REQUIRE_REFRESH: "Please refresh page",
      BUTTON: "Refresh Page"
    }
  }, AdapterJS._iceConnectionStates = {
    starting: "starting",
    checking: "checking",
    connected: "connected",
    completed: "connected",
    done: "completed",
    disconnected: "disconnected",
    failed: "failed",
    closed: "closed"
  }, AdapterJS._iceConnectionFiredStates = [], AdapterJS.isDefined = null, AdapterJS.parseWebrtcDetectedBrowser = function() {
    var hasMatch,
        checkMatch = navigator.userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(checkMatch[1]) ? (hasMatch = /\brv[ :]+(\d+)/g.exec(navigator.userAgent) || [], webrtcDetectedBrowser = "IE", webrtcDetectedVersion = parseInt(hasMatch[1] || "0", 10)) : "Chrome" === checkMatch[1] && (hasMatch = navigator.userAgent.match(/\bOPR\/(\d+)/), null !== hasMatch && (webrtcDetectedBrowser = "opera", webrtcDetectedVersion = parseInt(hasMatch[1], 10))), navigator.userAgent.indexOf("Safari") && ("undefined" != typeof InstallTrigger ? webrtcDetectedBrowser = "firefox" : document.documentMode ? webrtcDetectedBrowser = "IE" : Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0 ? webrtcDetectedBrowser = "safari" : window.opera || navigator.userAgent.indexOf(" OPR/") >= 0 ? webrtcDetectedBrowser = "opera" : window.chrome && (webrtcDetectedBrowser = "chrome")), webrtcDetectedBrowser || (webrtcDetectedVersion = checkMatch[1]), !webrtcDetectedVersion)
      try {
        checkMatch = checkMatch[2] ? [checkMatch[1], checkMatch[2]] : [navigator.appName, navigator.appVersion, "-?"], null !== (hasMatch = navigator.userAgent.match(/version\/(\d+)/i)) && checkMatch.splice(1, 1, hasMatch[1]), webrtcDetectedVersion = parseInt(checkMatch[1], 10);
      } catch (error) {}
  }, AdapterJS.maybeFixConfiguration = function(pcConfig) {
    if (null !== pcConfig)
      for (var i = 0; i < pcConfig.iceServers.length; i++)
        pcConfig.iceServers[i].hasOwnProperty("urls") && (pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls, delete pcConfig.iceServers[i].urls);
  }, AdapterJS.addEvent = function(elem, evnt, func) {
    elem.addEventListener ? elem.addEventListener(evnt, func, !1) : elem.attachEvent ? elem.attachEvent("on" + evnt, func) : elem[evnt] = func;
  }, AdapterJS.renderNotificationBar = function(text, buttonText, buttonLink, openNewTab, displayRefreshBar) {
    if ("complete" === document.readyState) {
      var w = window,
          i = document.createElement("iframe");
      i.style.position = "fixed", i.style.top = "-41px", i.style.left = 0, i.style.right = 0, i.style.width = "100%", i.style.height = "40px", i.style.backgroundColor = "#ffffe1", i.style.border = "none", i.style.borderBottom = "1px solid #888888", i.style.zIndex = "9999999", "string" == typeof i.style.webkitTransition ? i.style.webkitTransition = "all .5s ease-out" : "string" == typeof i.style.transition && (i.style.transition = "all .5s ease-out"), document.body.appendChild(i), c = i.contentWindow ? i.contentWindow : i.contentDocument.document ? i.contentDocument.document : i.contentDocument, c.document.open(), c.document.write('<span style="display: inline-block; font-family: Helvetica, Arial,sans-serif; font-size: .9rem; padding: 4px; vertical-align: middle; cursor: default;">' + text + "</span>"), buttonText && buttonLink ? (c.document.write('<button id="okay">' + buttonText + "</button><button>Cancel</button>"), c.document.close(), AdapterJS.addEvent(c.document.getElementById("okay"), "click", function(e) {
        displayRefreshBar && AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION ? AdapterJS.TEXT.EXTENSION.REQUIRE_REFRESH : AdapterJS.TEXT.REFRESH.REQUIRE_REFRESH, AdapterJS.TEXT.REFRESH.BUTTON, "javascript:location.reload()"), window.open(buttonLink, openNewTab ? "_blank" : "_top"), e.preventDefault();
        try {
          event.cancelBubble = !0;
        } catch (error) {}
        setInterval(function() {
          isIE || navigator.plugins.refresh(!1), AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName, AdapterJS.WebRTCPlugin.defineWebRTCInterface, function() {});
        }, 500);
      })) : c.document.close(), AdapterJS.addEvent(c.document, "click", function() {
        w.document.body.removeChild(i);
      }), setTimeout(function() {
        "string" == typeof i.style.webkitTransform ? i.style.webkitTransform = "translateY(40px)" : "string" == typeof i.style.transform ? i.style.transform = "translateY(40px)" : i.style.top = "0px";
      }, 300);
    }
  }, webrtcDetectedType = null, webrtcDetectedDCSupport = null, checkMediaDataChannelSettings = function(peerBrowserAgent, peerBrowserVersion, callback, constraints) {
    if ("function" == typeof callback) {
      var beOfferer = !0,
          isLocalFirefox = "firefox" === webrtcDetectedBrowser,
          isLocalFirefoxInterop = "moz" === webrtcDetectedType && webrtcDetectedVersion > 30,
          isPeerFirefox = "firefox" === peerBrowserAgent;
      if (isLocalFirefox && isPeerFirefox || isLocalFirefoxInterop)
        try {
          delete constraints.mandatory.MozDontOfferDataChannel;
        } catch (error) {}
      else
        isLocalFirefox && !isPeerFirefox && (constraints.mandatory.MozDontOfferDataChannel = !0);
      if (!isLocalFirefox)
        for (var prop in constraints.mandatory)
          constraints.mandatory.hasOwnProperty(prop) && -1 !== prop.indexOf("Moz") && delete constraints.mandatory[prop];
      !isLocalFirefox || isPeerFirefox || isLocalFirefoxInterop || (beOfferer = !1), callback(beOfferer, constraints);
    }
  }, checkIceConnectionState = function(peerId, iceConnectionState, callback) {
    "function" == typeof callback && (peerId = peerId ? peerId : "peer", AdapterJS._iceConnectionFiredStates[peerId] && iceConnectionState !== AdapterJS._iceConnectionStates.disconnected && iceConnectionState !== AdapterJS._iceConnectionStates.failed && iceConnectionState !== AdapterJS._iceConnectionStates.closed || (AdapterJS._iceConnectionFiredStates[peerId] = []), iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState], AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) < 0 && (AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState), iceConnectionState === AdapterJS._iceConnectionStates.connected && setTimeout(function() {
      AdapterJS._iceConnectionFiredStates[peerId].push(AdapterJS._iceConnectionStates.done), callback(AdapterJS._iceConnectionStates.done);
    }, 1e3), callback(iceConnectionState)));
  }, createIceServer = null, createIceServers = null, RTCPeerConnection = null, RTCSessionDescription = "function" == typeof RTCSessionDescription ? RTCSessionDescription : null, RTCIceCandidate = "function" == typeof RTCIceCandidate ? RTCIceCandidate : null, getUserMedia = null, attachMediaStream = null, reattachMediaStream = null, webrtcDetectedBrowser = null, webrtcDetectedVersion = null, navigator.mozGetUserMedia)
    webrtcDetectedBrowser = "firefox", webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10), webrtcDetectedType = "moz", webrtcDetectedDCSupport = "SCTP", RTCPeerConnection = function(pcConfig, pcConstraints) {
      return AdapterJS.maybeFixConfiguration(pcConfig), new mozRTCPeerConnection(pcConfig, pcConstraints);
    }, RTCSessionDescription = mozRTCSessionDescription, window.RTCSessionDescription = RTCSessionDescription, RTCIceCandidate = mozRTCIceCandidate, window.RTCIceCandidate = RTCIceCandidate, window.getUserMedia = navigator.mozGetUserMedia.bind(navigator), navigator.getUserMedia = window.getUserMedia, MediaStreamTrack.getSources = function(successCb) {
      setTimeout(function() {
        var infos = [{
          kind: "audio",
          id: "default",
          label: "",
          facing: ""
        }, {
          kind: "video",
          id: "default",
          label: "",
          facing: ""
        }];
        successCb(infos);
      }, 0);
    }, createIceServer = function(url, username, password) {
      var iceServer = null,
          url_parts = url.split(":");
      if (0 === url_parts[0].indexOf("stun"))
        iceServer = {url: url};
      else if (0 === url_parts[0].indexOf("turn"))
        if (27 > webrtcDetectedVersion) {
          var turn_url_parts = url.split("?");
          (1 === turn_url_parts.length || 0 === turn_url_parts[1].indexOf("transport=udp")) && (iceServer = {
            url: turn_url_parts[0],
            credential: password,
            username: username
          });
        } else
          iceServer = {
            url: url,
            credential: password,
            username: username
          };
      return iceServer;
    }, createIceServers = function(urls, username, password) {
      var iceServers = [];
      for (i = 0; i < urls.length; i++) {
        var iceServer = createIceServer(urls[i], username, password);
        null !== iceServer && iceServers.push(iceServer);
      }
      return iceServers;
    }, attachMediaStream = function(element, stream) {
      return element.mozSrcObject = stream, null !== stream && element.play(), element;
    }, reattachMediaStream = function(to, from) {
      return to.mozSrcObject = from.mozSrcObject, to.play(), to;
    }, MediaStreamTrack.getSources = MediaStreamTrack.getSources || function(callback) {
      if (!callback)
        throw new TypeError("Failed to execute 'getSources' on 'MediaStreamTrack': 1 argument required, but only 0 present.");
      return callback([]);
    }, MediaStream.prototype.getVideoTracks || (MediaStream.prototype.getVideoTracks = function() {
      return [];
    }), MediaStream.prototype.getAudioTracks || (MediaStream.prototype.getAudioTracks = function() {
      return [];
    }), AdapterJS.maybeThroughWebRTCReady();
  else if (navigator.webkitGetUserMedia) {
    webrtcDetectedBrowser = "chrome", webrtcDetectedType = "webkit", webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
    var checkIfOpera = navigator.userAgent.match(/\bOPR\/(\d+)/);
    null !== checkIfOpera && (webrtcDetectedBrowser = "opera", webrtcDetectedVersion = parseInt(checkIfOpera[1], 10)), webrtcDetectedDCSupport = "chrome" === webrtcDetectedBrowser && webrtcDetectedVersion >= 31 || "opera" === webrtcDetectedBrowser && webrtcDetectedVersion >= 20 ? "SCTP" : "chrome" === webrtcDetectedBrowser && 30 > webrtcDetectedVersion && webrtcDetectedVersion > 24 ? "RTP" : "", createIceServer = function(url, username, password) {
      var iceServer = null,
          url_parts = url.split(":");
      return 0 === url_parts[0].indexOf("stun") ? iceServer = {url: url} : 0 === url_parts[0].indexOf("turn") && (iceServer = {
        url: url,
        credential: password,
        username: username
      }), iceServer;
    }, createIceServers = function(urls, username, password) {
      var iceServers = [];
      if (webrtcDetectedVersion >= 34)
        iceServers = {
          urls: urls,
          credential: password,
          username: username
        };
      else
        for (i = 0; i < urls.length; i++) {
          var iceServer = createIceServer(urls[i], username, password);
          null !== iceServer && iceServers.push(iceServer);
        }
      return iceServers;
    }, RTCPeerConnection = function(pcConfig, pcConstraints) {
      return 34 > webrtcDetectedVersion && AdapterJS.maybeFixConfiguration(pcConfig), new webkitRTCPeerConnection(pcConfig, pcConstraints);
    }, window.getUserMedia = navigator.webkitGetUserMedia.bind(navigator), navigator.getUserMedia = window.getUserMedia, attachMediaStream = function(element, stream) {
      return "undefined" != typeof element.srcObject ? element.srcObject = stream : "undefined" != typeof element.mozSrcObject ? element.mozSrcObject = stream : "undefined" != typeof element.src && (element.src = null === stream ? "" : URL.createObjectURL(stream)), element;
    }, reattachMediaStream = function(to, from) {
      return to.src = from.src, to;
    }, AdapterJS.maybeThroughWebRTCReady();
  } else
    ("object" != typeof console || "function" != typeof console.log) && (console = {} || console, console.log = function() {}, console.info = function() {}, console.error = function() {}, console.dir = function() {}, console.exception = function() {}, console.trace = function() {}, console.warn = function() {}, console.count = function() {}, console.debug = function() {}, console.count = function() {}, console.time = function() {}, console.timeEnd = function() {}, console.group = function() {}, console.groupCollapsed = function() {}, console.groupEnd = function() {}), webrtcDetectedType = "plugin", webrtcDetectedDCSupport = "plugin", AdapterJS.parseWebrtcDetectedBrowser(), isIE = "IE" === webrtcDetectedBrowser, AdapterJS.WebRTCPlugin.WaitForPluginReady = function() {
      for (; AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY; )
        ;
    }, AdapterJS.WebRTCPlugin.callWhenPluginReady = function(callback) {
      if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY)
        callback();
      else
        var checkPluginReadyState = setInterval(function() {
          AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY && (clearInterval(checkPluginReadyState), callback());
        }, 100);
    }, AdapterJS.WebRTCPlugin.setLogLevel = function(logLevel) {
      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {
        AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);
      });
    }, AdapterJS.WebRTCPlugin.injectPlugin = function() {
      if ("complete" === document.readyState && AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING) {
        if (AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING, "IE" === webrtcDetectedBrowser && 10 >= webrtcDetectedVersion) {
          var frag = document.createDocumentFragment();
          for (AdapterJS.WebRTCPlugin.plugin = document.createElement("div"), AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id="' + AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '" type="' + AdapterJS.WebRTCPlugin.pluginInfo.type + '" width="1" height="1"><param name="pluginId" value="' + AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '" /> <param name="windowless" value="false" /> <param name="pageId" value="' + AdapterJS.WebRTCPlugin.pageId + '" /> <param name="onload" value="' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '" />' + (AdapterJS.options.getAllCams ? '<param name="forceGetAllCams" value="True" />' : "") + "</object>"; AdapterJS.WebRTCPlugin.plugin.firstChild; )
            frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);
          document.body.appendChild(frag), AdapterJS.WebRTCPlugin.plugin = document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);
        } else
          AdapterJS.WebRTCPlugin.plugin = document.createElement("object"), AdapterJS.WebRTCPlugin.plugin.id = AdapterJS.WebRTCPlugin.pluginInfo.pluginId, isIE ? (AdapterJS.WebRTCPlugin.plugin.width = "1px", AdapterJS.WebRTCPlugin.plugin.height = "1px") : (AdapterJS.WebRTCPlugin.plugin.width = "0px", AdapterJS.WebRTCPlugin.plugin.height = "0px"), AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type, AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name="onload" value="' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '"><param name="pluginId" value="' + AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '"><param name="windowless" value="false" /> ' + (AdapterJS.options.getAllCams ? '<param name="forceGetAllCams" value="True" />' : "") + '<param name="pageId" value="' + AdapterJS.WebRTCPlugin.pageId + '">', document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);
        AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;
      }
    }, AdapterJS.WebRTCPlugin.isPluginInstalled = function(comName, plugName, installedCb, notInstalledCb) {
      if (isIE) {
        try {
          {
            new ActiveXObject(comName + "." + plugName);
          }
        } catch (e) {
          return void notInstalledCb();
        }
        installedCb();
      } else {
        for (var pluginArray = navigator.plugins,
            i = 0; i < pluginArray.length; i++)
          if (pluginArray[i].name.indexOf(plugName) >= 0)
            return void installedCb();
        notInstalledCb();
      }
    }, AdapterJS.WebRTCPlugin.defineWebRTCInterface = function() {
      AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING, AdapterJS.isDefined = function(variable) {
        return null !== variable && void 0 !== variable;
      }, createIceServer = function(url, username, password) {
        var iceServer = null,
            url_parts = url.split(":");
        return 0 === url_parts[0].indexOf("stun") ? iceServer = {
          url: url,
          hasCredentials: !1
        } : 0 === url_parts[0].indexOf("turn") && (iceServer = {
          url: url,
          hasCredentials: !0,
          credential: password,
          username: username
        }), iceServer;
      }, createIceServers = function(urls, username, password) {
        for (var iceServers = [],
            i = 0; i < urls.length; ++i)
          iceServers.push(createIceServer(urls[i], username, password));
        return iceServers;
      }, RTCSessionDescription = function(info) {
        return AdapterJS.WebRTCPlugin.WaitForPluginReady(), AdapterJS.WebRTCPlugin.plugin.ConstructSessionDescription(info.type, info.sdp);
      }, RTCPeerConnection = function(servers, constraints) {
        var iceServers = null;
        if (servers) {
          iceServers = servers.iceServers;
          for (var i = 0; i < iceServers.length; i++)
            iceServers[i].urls && !iceServers[i].url && (iceServers[i].url = iceServers[i].urls), iceServers[i].hasCredentials = AdapterJS.isDefined(iceServers[i].username) && AdapterJS.isDefined(iceServers[i].credential);
        }
        var mandatory = constraints && constraints.mandatory ? constraints.mandatory : null,
            optional = constraints && constraints.optional ? constraints.optional : null;
        return AdapterJS.WebRTCPlugin.WaitForPluginReady(), AdapterJS.WebRTCPlugin.plugin.PeerConnection(AdapterJS.WebRTCPlugin.pageId, iceServers, mandatory, optional);
      }, MediaStreamTrack = {}, MediaStreamTrack.getSources = function(callback) {
        AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {
          AdapterJS.WebRTCPlugin.plugin.GetSources(callback);
        });
      }, window.getUserMedia = function(constraints, successCallback, failureCallback) {
        constraints.audio = constraints.audio || !1, constraints.video = constraints.video || !1, AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {
          AdapterJS.WebRTCPlugin.plugin.getUserMedia(constraints, successCallback, failureCallback);
        });
      }, window.navigator.getUserMedia = window.getUserMedia, attachMediaStream = function(element, stream) {
        if (element && element.parentNode) {
          var streamId;
          if (null === stream ? streamId = "" : (stream.enableSoundTracks(!0), streamId = stream.id), "audio" !== element.nodeName.toLowerCase()) {
            var elementId = 0 === element.id.length ? Math.random().toString(36).slice(2) : element.id;
            if (element.isWebRTCPlugin && element.isWebRTCPlugin()) {
              for (var children = element.children,
                  i = 0; i !== children.length; ++i)
                if ("streamId" === children[i].name) {
                  children[i].value = streamId;
                  break;
                }
              element.setStreamId(streamId);
            } else {
              var frag = document.createDocumentFragment(),
                  temp = document.createElement("div"),
                  classHTML = "";
              for (element.className ? classHTML = 'class="' + element.className + '" ' : element.attributes && element.attributes["class"] && (classHTML = 'class="' + element.attributes["class"].value + '" '), temp.innerHTML = '<object id="' + elementId + '" ' + classHTML + 'type="' + AdapterJS.WebRTCPlugin.pluginInfo.type + '"><param name="pluginId" value="' + elementId + '" /> <param name="pageId" value="' + AdapterJS.WebRTCPlugin.pageId + '" /> <param name="windowless" value="true" /> <param name="streamId" value="' + streamId + '" /> </object>'; temp.firstChild; )
                frag.appendChild(temp.firstChild);
              var height = "",
                  width = "";
              if (element.getBoundingClientRect) {
                var rectObject = element.getBoundingClientRect();
                width = rectObject.width + "px", height = rectObject.height + "px";
              } else
                element.width && (width = element.width, height = element.height);
              element.parentNode.insertBefore(frag, element), frag = document.getElementById(elementId), frag.width = width, frag.height = height, element.parentNode.removeChild(element);
            }
            var newElement = document.getElementById(elementId);
            return newElement.onplaying = element.onplaying ? element.onplaying : function() {}, isIE && (newElement.attachEvent("onplaying", newElement.onplaying), newElement.onclick = element.onclick ? element.onclick : function() {}, newElement._TemOnClick = function(id) {
              var arg = {srcElement: document.getElementById(id)};
              newElement.onclick(arg);
            }), newElement;
          }
          return element;
        }
      }, reattachMediaStream = function(to, from) {
        for (var stream = null,
            children = from.children,
            i = 0; i !== children.length; ++i)
          if ("streamId" === children[i].name) {
            AdapterJS.WebRTCPlugin.WaitForPluginReady(), stream = AdapterJS.WebRTCPlugin.plugin.getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);
            break;
          }
        return null !== stream ? attachMediaStream(to, stream) : void 0;
      }, RTCIceCandidate = function(candidate) {
        return candidate.sdpMid || (candidate.sdpMid = ""), AdapterJS.WebRTCPlugin.WaitForPluginReady(), AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate);
      }, AdapterJS.addEvent(document, "readystatechange", AdapterJS.WebRTCPlugin.injectPlugin), AdapterJS.WebRTCPlugin.injectPlugin();
    }, AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb || function() {
      AdapterJS.addEvent(document, "readystatechange", AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv), AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();
    }, AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function() {
      if (!AdapterJS.options.hidePluginInstallPrompt) {
        var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;
        if (downloadLink) {
          var popupString;
          popupString = AdapterJS.WebRTCPlugin.pluginInfo.portalLink ? 'This website requires you to install the  <a href="' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink + '" target="_blank">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName + " WebRTC Plugin</a> to work on this browser." : AdapterJS.TEXT.PLUGIN.REQUIRE_INSTALLATION, AdapterJS.renderNotificationBar(popupString, AdapterJS.TEXT.PLUGIN.BUTTON, downloadLink);
        } else
          AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED);
      }
    }, AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName, AdapterJS.WebRTCPlugin.defineWebRTCInterface, AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);
  global.define = __define;
  return module.exports;
});

System.register("npm:crypt@0.0.1/crypt", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        crypt = {
          rotl: function(n, b) {
            return (n << b) | (n >>> (32 - b));
          },
          rotr: function(n, b) {
            return (n << (32 - b)) | (n >>> b);
          },
          endian: function(n) {
            if (n.constructor == Number) {
              return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
            }
            for (var i = 0; i < n.length; i++)
              n[i] = crypt.endian(n[i]);
            return n;
          },
          randomBytes: function(n) {
            for (var bytes = []; n > 0; n--)
              bytes.push(Math.floor(Math.random() * 256));
            return bytes;
          },
          bytesToWords: function(bytes) {
            for (var words = [],
                i = 0,
                b = 0; i < bytes.length; i++, b += 8)
              words[b >>> 5] |= bytes[i] << (24 - b % 32);
            return words;
          },
          wordsToBytes: function(words) {
            for (var bytes = [],
                b = 0; b < words.length * 32; b += 8)
              bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
            return bytes;
          },
          bytesToHex: function(bytes) {
            for (var hex = [],
                i = 0; i < bytes.length; i++) {
              hex.push((bytes[i] >>> 4).toString(16));
              hex.push((bytes[i] & 0xF).toString(16));
            }
            return hex.join('');
          },
          hexToBytes: function(hex) {
            for (var bytes = [],
                c = 0; c < hex.length; c += 2)
              bytes.push(parseInt(hex.substr(c, 2), 16));
            return bytes;
          },
          bytesToBase64: function(bytes) {
            for (var base64 = [],
                i = 0; i < bytes.length; i += 3) {
              var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
              for (var j = 0; j < 4; j++)
                if (i * 8 + j * 6 <= bytes.length * 8)
                  base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
                else
                  base64.push('=');
            }
            return base64.join('');
          },
          base64ToBytes: function(base64) {
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');
            for (var bytes = [],
                i = 0,
                imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0)
                continue;
              bytes.push(((base64map.indexOf(base64.charAt(i - 1)) & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2)) | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
            }
            return bytes;
          }
        };
    module.exports = crypt;
  })();
  global.define = __define;
  return module.exports;
});

System.register("npm:charenc@0.0.1/charenc", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var charenc = {
    utf8: {
      stringToBytes: function(str) {
        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
      },
      bytesToString: function(bytes) {
        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
      }
    },
    bin: {
      stringToBytes: function(str) {
        for (var bytes = [],
            i = 0; i < str.length; i++)
          bytes.push(str.charCodeAt(i) & 0xFF);
        return bytes;
      },
      bytesToString: function(bytes) {
        for (var str = [],
            i = 0; i < bytes.length; i++)
          str.push(String.fromCharCode(bytes[i]));
        return str.join('');
      }
    }
  };
  module.exports = charenc;
  global.define = __define;
  return module.exports;
});

System.register("npm:is-buffer@1.0.2/index", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    module.exports = function(obj) {
      return !!(obj != null && obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj));
    };
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/utils/connectToStores", ["npm:react@0.14.0-beta3", "npm:alt@0.17.1/utils/functions"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  var _react = require("npm:react@0.14.0-beta3");
  var _react2 = _interopRequireDefault(_react);
  var _functions = require("npm:alt@0.17.1/utils/functions");
  function connectToStores(Spec) {
    var Component = arguments[1] === undefined ? Spec : arguments[1];
    return (function() {
      if (!(0, _functions.isFunction)(Spec.getStores)) {
        throw new Error('connectToStores() expects the wrapped component to have a static getStores() method');
      }
      if (!(0, _functions.isFunction)(Spec.getPropsFromStores)) {
        throw new Error('connectToStores() expects the wrapped component to have a static getPropsFromStores() method');
      }
      var StoreConnection = _react2['default'].createClass({
        displayName: 'StoreConnection',
        getInitialState: function getInitialState() {
          return Spec.getPropsFromStores(this.props, this.context);
        },
        componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
          this.setState(Spec.getPropsFromStores(nextProps, this.context));
        },
        componentDidMount: function componentDidMount() {
          var _this = this;
          var stores = Spec.getStores(this.props, this.context);
          this.storeListeners = stores.map(function(store) {
            return store.listen(_this.onChange);
          });
          if (Spec.componentDidConnect) {
            Spec.componentDidConnect(this.props, this.context);
          }
        },
        componentWillUnmount: function componentWillUnmount() {
          this.storeListeners.forEach(function(unlisten) {
            return unlisten();
          });
        },
        onChange: function onChange() {
          this.setState(Spec.getPropsFromStores(this.props, this.context));
        },
        render: function render() {
          return _react2['default'].createElement(Component, (0, _functions.assign)({}, this.props, this.state));
        }
      });
      return StoreConnection;
    })();
  }
  exports['default'] = connectToStores;
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.register("npm:URIjs@1.16.0/src/punycode", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(root) {
      var freeExports = typeof exports == 'object' && exports;
      var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
      var freeGlobal = typeof global == 'object' && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var punycode,
          maxInt = 2147483647,
          base = 36,
          tMin = 1,
          tMax = 26,
          skew = 38,
          damp = 700,
          initialBias = 72,
          initialN = 128,
          delimiter = '-',
          regexPunycode = /^xn--/,
          regexNonASCII = /[^ -~]/,
          regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g,
          errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
          },
          baseMinusTMin = base - tMin,
          floor = Math.floor,
          stringFromCharCode = String.fromCharCode,
          key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        while (length--) {
          array[length] = fn(array[length]);
        }
        return array;
      }
      function mapDomain(string, fn) {
        return map(string.split(regexSeparators), fn).join('.');
      }
      function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = '';
          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }
          output += stringFromCharCode(value);
          return output;
        }).join('');
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            length,
            baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error('invalid-input');
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error('overflow');
            }
            i += digit * w;
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error('overflow');
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error('overflow');
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            inputLength,
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error('overflow');
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join('');
      }
      function toUnicode(domain) {
        return mapDomain(domain, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(domain) {
        return mapDomain(domain, function(string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      }
      punycode = {
        'version': '1.2.3',
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define(function() {
          return punycode;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    }(this));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:URIjs@1.16.0/src/IPv6", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      define(factory);
    } else {
      root.IPv6 = factory(root);
    }
  }(this, function(root) {
    'use strict';
    var _IPv6 = root && root.IPv6;
    function bestPresentation(address) {
      var _address = address.toLowerCase();
      var segments = _address.split(':');
      var length = segments.length;
      var total = 8;
      if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
        segments.shift();
        segments.shift();
      } else if (segments[0] === '' && segments[1] === '') {
        segments.shift();
      } else if (segments[length - 1] === '' && segments[length - 2] === '') {
        segments.pop();
      }
      length = segments.length;
      if (segments[length - 1].indexOf('.') !== -1) {
        total = 7;
      }
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (segments[pos] === '') {
          break;
        }
      }
      if (pos < total) {
        segments.splice(pos, 1, '0000');
        while (segments.length < total) {
          segments.splice(pos, 0, '0000');
        }
        length = segments.length;
      }
      var _segments;
      for (var i = 0; i < total; i++) {
        _segments = segments[i].split('');
        for (var j = 0; j < 3; j++) {
          if (_segments[0] === '0' && _segments.length > 1) {
            _segments.splice(0, 1);
          } else {
            break;
          }
        }
        segments[i] = _segments.join('');
      }
      var best = -1;
      var _best = 0;
      var _current = 0;
      var current = -1;
      var inzeroes = false;
      for (i = 0; i < total; i++) {
        if (inzeroes) {
          if (segments[i] === '0') {
            _current += 1;
          } else {
            inzeroes = false;
            if (_current > _best) {
              best = current;
              _best = _current;
            }
          }
        } else {
          if (segments[i] === '0') {
            inzeroes = true;
            current = i;
            _current = 1;
          }
        }
      }
      if (_current > _best) {
        best = current;
        _best = _current;
      }
      if (_best > 1) {
        segments.splice(best, _best, '');
      }
      length = segments.length;
      var result = '';
      if (segments[0] === '') {
        result = ':';
      }
      for (i = 0; i < length; i++) {
        result += segments[i];
        if (i === length - 1) {
          break;
        }
        result += ':';
      }
      if (segments[length - 1] === '') {
        result += ':';
      }
      return result;
    }
    function noConflict() {
      if (root.IPv6 === this) {
        root.IPv6 = _IPv6;
      }
      return this;
    }
    return {
      best: bestPresentation,
      noConflict: noConflict
    };
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:URIjs@1.16.0/src/SecondLevelDomains", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      define(factory);
    } else {
      root.SecondLevelDomains = factory(root);
    }
  }(this, function(root) {
    'use strict';
    var _SecondLevelDomains = root && root.SecondLevelDomains;
    var SLD = {
      list: {
        'ac': ' com gov mil net org ',
        'ae': ' ac co gov mil name net org pro sch ',
        'af': ' com edu gov net org ',
        'al': ' com edu gov mil net org ',
        'ao': ' co ed gv it og pb ',
        'ar': ' com edu gob gov int mil net org tur ',
        'at': ' ac co gv or ',
        'au': ' asn com csiro edu gov id net org ',
        'ba': ' co com edu gov mil net org rs unbi unmo unsa untz unze ',
        'bb': ' biz co com edu gov info net org store tv ',
        'bh': ' biz cc com edu gov info net org ',
        'bn': ' com edu gov net org ',
        'bo': ' com edu gob gov int mil net org tv ',
        'br': ' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
        'bs': ' com edu gov net org ',
        'bz': ' du et om ov rg ',
        'ca': ' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
        'ck': ' biz co edu gen gov info net org ',
        'cn': ' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
        'co': ' com edu gov mil net nom org ',
        'cr': ' ac c co ed fi go or sa ',
        'cy': ' ac biz com ekloges gov ltd name net org parliament press pro tm ',
        'do': ' art com edu gob gov mil net org sld web ',
        'dz': ' art asso com edu gov net org pol ',
        'ec': ' com edu fin gov info med mil net org pro ',
        'eg': ' com edu eun gov mil name net org sci ',
        'er': ' com edu gov ind mil net org rochest w ',
        'es': ' com edu gob nom org ',
        'et': ' biz com edu gov info name net org ',
        'fj': ' ac biz com info mil name net org pro ',
        'fk': ' ac co gov net nom org ',
        'fr': ' asso com f gouv nom prd presse tm ',
        'gg': ' co net org ',
        'gh': ' com edu gov mil org ',
        'gn': ' ac com gov net org ',
        'gr': ' com edu gov mil net org ',
        'gt': ' com edu gob ind mil net org ',
        'gu': ' com edu gov net org ',
        'hk': ' com edu gov idv net org ',
        'hu': ' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
        'id': ' ac co go mil net or sch web ',
        'il': ' ac co gov idf k12 muni net org ',
        'in': ' ac co edu ernet firm gen gov i ind mil net nic org res ',
        'iq': ' com edu gov i mil net org ',
        'ir': ' ac co dnssec gov i id net org sch ',
        'it': ' edu gov ',
        'je': ' co net org ',
        'jo': ' com edu gov mil name net org sch ',
        'jp': ' ac ad co ed go gr lg ne or ',
        'ke': ' ac co go info me mobi ne or sc ',
        'kh': ' com edu gov mil net org per ',
        'ki': ' biz com de edu gov info mob net org tel ',
        'km': ' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
        'kn': ' edu gov net org ',
        'kr': ' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
        'kw': ' com edu gov net org ',
        'ky': ' com edu gov net org ',
        'kz': ' com edu gov mil net org ',
        'lb': ' com edu gov net org ',
        'lk': ' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
        'lr': ' com edu gov net org ',
        'lv': ' asn com conf edu gov id mil net org ',
        'ly': ' com edu gov id med net org plc sch ',
        'ma': ' ac co gov m net org press ',
        'mc': ' asso tm ',
        'me': ' ac co edu gov its net org priv ',
        'mg': ' com edu gov mil nom org prd tm ',
        'mk': ' com edu gov inf name net org pro ',
        'ml': ' com edu gov net org presse ',
        'mn': ' edu gov org ',
        'mo': ' com edu gov net org ',
        'mt': ' com edu gov net org ',
        'mv': ' aero biz com coop edu gov info int mil museum name net org pro ',
        'mw': ' ac co com coop edu gov int museum net org ',
        'mx': ' com edu gob net org ',
        'my': ' com edu gov mil name net org sch ',
        'nf': ' arts com firm info net other per rec store web ',
        'ng': ' biz com edu gov mil mobi name net org sch ',
        'ni': ' ac co com edu gob mil net nom org ',
        'np': ' com edu gov mil net org ',
        'nr': ' biz com edu gov info net org ',
        'om': ' ac biz co com edu gov med mil museum net org pro sch ',
        'pe': ' com edu gob mil net nom org sld ',
        'ph': ' com edu gov i mil net ngo org ',
        'pk': ' biz com edu fam gob gok gon gop gos gov net org web ',
        'pl': ' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
        'pr': ' ac biz com edu est gov info isla name net org pro prof ',
        'ps': ' com edu gov net org plo sec ',
        'pw': ' belau co ed go ne or ',
        'ro': ' arts com firm info nom nt org rec store tm www ',
        'rs': ' ac co edu gov in org ',
        'sb': ' com edu gov net org ',
        'sc': ' com edu gov net org ',
        'sh': ' co com edu gov net nom org ',
        'sl': ' com edu gov net org ',
        'st': ' co com consulado edu embaixada gov mil net org principe saotome store ',
        'sv': ' com edu gob org red ',
        'sz': ' ac co org ',
        'tr': ' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
        'tt': ' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
        'tw': ' club com ebiz edu game gov idv mil net org ',
        'mu': ' ac co com gov net or org ',
        'mz': ' ac co edu gov org ',
        'na': ' co com ',
        'nz': ' ac co cri geek gen govt health iwi maori mil net org parliament school ',
        'pa': ' abo ac com edu gob ing med net nom org sld ',
        'pt': ' com edu gov int net nome org publ ',
        'py': ' com edu gov mil net org ',
        'qa': ' com edu gov mil net org ',
        're': ' asso com nom ',
        'ru': ' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
        'rw': ' ac co com edu gouv gov int mil net ',
        'sa': ' com edu gov med net org pub sch ',
        'sd': ' com edu gov info med net org tv ',
        'se': ' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
        'sg': ' com edu gov idn net org per ',
        'sn': ' art com edu gouv org perso univ ',
        'sy': ' com edu gov mil net news org ',
        'th': ' ac co go in mi net or ',
        'tj': ' ac biz co com edu go gov info int mil name net nic org test web ',
        'tn': ' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
        'tz': ' ac co go ne or ',
        'ua': ' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
        'ug': ' ac co go ne or org sc ',
        'uk': ' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
        'us': ' dni fed isa kids nsn ',
        'uy': ' com edu gub mil net org ',
        've': ' co com edu gob info mil net org web ',
        'vi': ' co com k12 net org ',
        'vn': ' ac biz com edu gov health info int name net org pro ',
        'ye': ' co com gov ltd me net org plc ',
        'yu': ' ac co edu gov org ',
        'za': ' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
        'zm': ' ac co com edu gov net org sch '
      },
      has: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return false;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') >= 0;
      },
      is: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return false;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset >= 0) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
      },
      get: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return null;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
          return null;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return null;
        }
        if (sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') < 0) {
          return null;
        }
        return domain.slice(sldOffset + 1);
      },
      noConflict: function() {
        if (root.SecondLevelDomains === this) {
          root.SecondLevelDomains = _SecondLevelDomains;
        }
        return this;
      }
    };
    return SLD;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:whatwg-fetch@0.9.0/fetch", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function() {
    'use strict';
    if (self.fetch) {
      return ;
    }
    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = name.toString();
      }
      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
      }
      return name.toLowerCase();
    }
    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = value.toString();
      }
      return value;
    }
    function Headers(headers) {
      this.map = {};
      if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
          this.append(name, value);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
          this.append(name, headers[name]);
        }, this);
      }
    }
    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var list = this.map[name];
      if (!list) {
        list = [];
        this.map[name] = list;
      }
      list.push(value);
    };
    Headers.prototype['delete'] = function(name) {
      delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function(name) {
      var values = this.map[normalizeName(name)];
      return values ? values[0] : null;
    };
    Headers.prototype.getAll = function(name) {
      return this.map[normalizeName(name)] || [];
    };
    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = [normalizeValue(value)];
    };
    Headers.prototype.forEach = function(callback, thisArg) {
      Object.getOwnPropertyNames(this.map).forEach(function(name) {
        this.map[name].forEach(function(value) {
          callback.call(thisArg, value, name, this);
        }, this);
      }, this);
    };
    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }
      body.bodyUsed = true;
    }
    function fileReaderReady(reader) {
      return new Promise(function(resolve, reject) {
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.onerror = function() {
          reject(reader.error);
        };
      });
    }
    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      reader.readAsArrayBuffer(blob);
      return fileReaderReady(reader);
    }
    function readBlobAsText(blob) {
      var reader = new FileReader();
      reader.readAsText(blob);
      return fileReaderReady(reader);
    }
    var support = {
      blob: 'FileReader' in self && 'Blob' in self && (function() {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      })(),
      formData: 'FormData' in self
    };
    function Body() {
      this.bodyUsed = false;
      this._initBody = function(body) {
        this._bodyInit = body;
        if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (!body) {
          this._bodyText = '';
        } else {
          throw new Error('unsupported BodyInit type');
        }
      };
      if (support.blob) {
        this.blob = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };
        this.arrayBuffer = function() {
          return this.blob().then(readBlobAsArrayBuffer);
        };
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as text');
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
      } else {
        this.text = function() {
          var rejected = consumed(this);
          return rejected ? rejected : Promise.resolve(this._bodyText);
        };
      }
      if (support.formData) {
        this.formData = function() {
          return this.text().then(decode);
        };
      }
      this.json = function() {
        return this.text().then(JSON.parse);
      };
      return this;
    }
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return (methods.indexOf(upcased) > -1) ? upcased : method;
    }
    function Request(url, options) {
      options = options || {};
      this.url = url;
      this.credentials = options.credentials || 'omit';
      this.headers = new Headers(options.headers);
      this.method = normalizeMethod(options.method || 'GET');
      this.mode = options.mode || null;
      this.referrer = null;
      if ((this.method === 'GET' || this.method === 'HEAD') && options.body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }
      this._initBody(options.body);
    }
    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }
    function headers(xhr) {
      var head = new Headers();
      var pairs = xhr.getAllResponseHeaders().trim().split('\n');
      pairs.forEach(function(header) {
        var split = header.trim().split(':');
        var key = split.shift().trim();
        var value = split.join(':').trim();
        head.append(key, value);
      });
      return head;
    }
    Body.call(Request.prototype);
    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }
      this._initBody(bodyInit);
      this.type = 'default';
      this.url = null;
      this.status = options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = options.statusText;
      this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
      this.url = options.url || '';
    }
    Body.call(Response.prototype);
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
    self.fetch = function(input, init) {
      var request;
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input;
      } else {
        request = new Request(input, init);
      }
      return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        function responseURL() {
          if ('responseURL' in xhr) {
            return xhr.responseURL;
          }
          if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
            return xhr.getResponseHeader('X-Request-URL');
          }
          return ;
        }
        xhr.onload = function() {
          var status = (xhr.status === 1223) ? 204 : xhr.status;
          if (status < 100 || status > 599) {
            reject(new TypeError('Network request failed'));
            return ;
          }
          var options = {
            status: status,
            statusText: xhr.statusText,
            headers: headers(xhr),
            url: responseURL()
          };
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };
        xhr.onerror = function() {
          reject(new TypeError('Network request failed'));
        };
        xhr.open(request.method, request.url, true);
        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        }
        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    };
    self.fetch.polyfill = true;
  })();
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/quoteAttributeValueForBrowser", ["npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var escapeTextContentForBrowser = require("npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser");
  function quoteAttributeValueForBrowser(value) {
    return '"' + escapeTextContentForBrowser(value) + '"';
  }
  module.exports = quoteAttributeValueForBrowser;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/warning", ["npm:fbjs@0.1.0-alpha.4/lib/emptyFunction", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
    var warning = emptyFunction;
    if (process.env.NODE_ENV !== 'production') {
      warning = function(condition, format) {
        for (var _len = arguments.length,
            args = Array(_len > 2 ? _len - 2 : 0),
            _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (format.indexOf('Failed Composite propType: ') === 0) {
          return ;
        }
        if (!condition) {
          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          });
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {}
        }
      };
    }
    module.exports = warning;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/camelizeStyleName", ["npm:fbjs@0.1.0-alpha.4/lib/camelize"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var camelize = require("npm:fbjs@0.1.0-alpha.4/lib/camelize");
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/hyphenateStyleName", ["npm:fbjs@0.1.0-alpha.4/lib/hyphenate"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var hyphenate = require("npm:fbjs@0.1.0-alpha.4/lib/hyphenate");
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/createArrayFromMixed", ["npm:fbjs@0.1.0-alpha.4/lib/toArray"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var toArray = require("npm:fbjs@0.1.0-alpha.4/lib/toArray");
  function hasArrayNature(obj) {
    return (!!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj && !('setInterval' in obj) && typeof obj.nodeType != 'number' && (Array.isArray(obj) || 'callee' in obj || 'item' in obj));
  }
  function createArrayFromMixed(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }
  module.exports = createArrayFromMixed;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactMultiChildUpdateTypes", ["npm:fbjs@0.1.0-alpha.4/lib/keyMirror"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var keyMirror = require("npm:fbjs@0.1.0-alpha.4/lib/keyMirror");
  var ReactMultiChildUpdateTypes = keyMirror({
    INSERT_MARKUP: null,
    MOVE_EXISTING: null,
    REMOVE_NODE: null,
    SET_MARKUP: null,
    TEXT_CONTENT: null
  });
  module.exports = ReactMultiChildUpdateTypes;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/EventPluginHub", ["npm:react@0.14.0-beta3/lib/EventPluginRegistry", "npm:react@0.14.0-beta3/lib/EventPluginUtils", "npm:react@0.14.0-beta3/lib/accumulateInto", "npm:react@0.14.0-beta3/lib/forEachAccumulated", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventPluginRegistry = require("npm:react@0.14.0-beta3/lib/EventPluginRegistry");
    var EventPluginUtils = require("npm:react@0.14.0-beta3/lib/EventPluginUtils");
    var accumulateInto = require("npm:react@0.14.0-beta3/lib/accumulateInto");
    var forEachAccumulated = require("npm:react@0.14.0-beta3/lib/forEachAccumulated");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function(event) {
      if (event) {
        var executeDispatch = EventPluginUtils.executeDispatch;
        var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
        if (PluginModule && PluginModule.executeDispatch) {
          executeDispatch = PluginModule.executeDispatch;
        }
        EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var InstanceHandle = null;
    function validateInstanceHandle() {
      var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
      process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
    }
    var EventPluginHub = {
      injection: {
        injectMount: EventPluginUtils.injection.injectMount,
        injectInstanceHandle: function(InjectedInstanceHandle) {
          InstanceHandle = InjectedInstanceHandle;
          if (process.env.NODE_ENV !== 'production') {
            validateInstanceHandle();
          }
        },
        getInstanceHandle: function() {
          if (process.env.NODE_ENV !== 'production') {
            validateInstanceHandle();
          }
          return InstanceHandle;
        },
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
      registrationNameModules: EventPluginRegistry.registrationNameModules,
      putListener: function(id, registrationName, listener) {
        !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[id] = listener;
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.didPutListener) {
          PluginModule.didPutListener(id, registrationName, listener);
        }
      },
      getListener: function(id, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        return bankForRegistrationName && bankForRegistrationName[id];
      },
      deleteListener: function(id, registrationName) {
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.willDeleteListener) {
          PluginModule.willDeleteListener(id, registrationName);
        }
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          delete bankForRegistrationName[id];
        }
      },
      deleteAllListeners: function(id) {
        for (var registrationName in listenerBank) {
          if (!listenerBank[registrationName][id]) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
          if (PluginModule && PluginModule.willDeleteListener) {
            PluginModule.willDeleteListener(id, registrationName);
          }
          delete listenerBank[registrationName][id];
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function(events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function() {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
        !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
      },
      __purge: function() {
        listenerBank = {};
      },
      __getListenerBank: function() {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactEmptyComponent", ["npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactInstanceMap", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactInstanceMap = require("npm:react@0.14.0-beta3/lib/ReactInstanceMap");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var component;
    var nullComponentIDsRegistry = {};
    var ReactEmptyComponentInjection = {injectEmptyComponent: function(emptyComponent) {
        component = ReactElement.createFactory(emptyComponent);
      }};
    var ReactEmptyComponentType = function() {};
    ReactEmptyComponentType.prototype.componentDidMount = function() {
      var internalInstance = ReactInstanceMap.get(this);
      if (!internalInstance) {
        return ;
      }
      registerNullComponentID(internalInstance._rootNodeID);
    };
    ReactEmptyComponentType.prototype.componentWillUnmount = function() {
      var internalInstance = ReactInstanceMap.get(this);
      if (!internalInstance) {
        return ;
      }
      deregisterNullComponentID(internalInstance._rootNodeID);
    };
    ReactEmptyComponentType.prototype.render = function() {
      !component ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to return null from a render, but no null placeholder component ' + 'was injected.') : invariant(false) : undefined;
      return component();
    };
    var emptyElement = ReactElement.createElement(ReactEmptyComponentType);
    function registerNullComponentID(id) {
      nullComponentIDsRegistry[id] = true;
    }
    function deregisterNullComponentID(id) {
      delete nullComponentIDsRegistry[id];
    }
    function isNullComponentID(id) {
      return !!nullComponentIDsRegistry[id];
    }
    var ReactEmptyComponent = {
      emptyElement: emptyElement,
      injection: ReactEmptyComponentInjection,
      isNullComponentID: isNullComponentID
    };
    module.exports = ReactEmptyComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactInstanceHandles", ["npm:react@0.14.0-beta3/lib/ReactRootIndex", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactRootIndex = require("npm:react@0.14.0-beta3/lib/ReactRootIndex");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var SEPARATOR = '.';
    var SEPARATOR_LENGTH = SEPARATOR.length;
    var MAX_TREE_DEPTH = 10000;
    function getReactRootIDString(index) {
      return SEPARATOR + index.toString(36);
    }
    function isBoundary(id, index) {
      return id.charAt(index) === SEPARATOR || index === id.length;
    }
    function isValidID(id) {
      return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
    }
    function isAncestorIDOf(ancestorID, descendantID) {
      return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
    }
    function getParentID(id) {
      return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
    }
    function getNextDescendantID(ancestorID, destinationID) {
      !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
      !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
      if (ancestorID === destinationID) {
        return ancestorID;
      }
      var start = ancestorID.length + SEPARATOR_LENGTH;
      var i;
      for (i = start; i < destinationID.length; i++) {
        if (isBoundary(destinationID, i)) {
          break;
        }
      }
      return destinationID.substr(0, i);
    }
    function getFirstCommonAncestorID(oneID, twoID) {
      var minLength = Math.min(oneID.length, twoID.length);
      if (minLength === 0) {
        return '';
      }
      var lastCommonMarkerIndex = 0;
      for (var i = 0; i <= minLength; i++) {
        if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
          lastCommonMarkerIndex = i;
        } else if (oneID.charAt(i) !== twoID.charAt(i)) {
          break;
        }
      }
      var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
      !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
      return longestCommonID;
    }
    function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
      start = start || '';
      stop = stop || '';
      !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
      var traverseUp = isAncestorIDOf(stop, start);
      !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
      var depth = 0;
      var traverse = traverseUp ? getParentID : getNextDescendantID;
      for (var id = start; ; id = traverse(id, stop)) {
        var ret;
        if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
          ret = cb(id, traverseUp, arg);
        }
        if (ret === false || id === stop) {
          break;
        }
        !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
      }
    }
    var ReactInstanceHandles = {
      createReactRootID: function() {
        return getReactRootIDString(ReactRootIndex.createReactRootIndex());
      },
      createReactID: function(rootID, name) {
        return rootID + name;
      },
      getReactRootIDFromNodeID: function(id) {
        if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
          var index = id.indexOf(SEPARATOR, 1);
          return index > -1 ? id.substr(0, index) : id;
        }
        return null;
      },
      traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
        var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
        if (ancestorID !== leaveID) {
          traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
        }
        if (ancestorID !== enterID) {
          traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
        }
      },
      traverseTwoPhase: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, false);
          traverseParentPath(targetID, '', cb, arg, false, true);
        }
      },
      traverseTwoPhaseSkipTarget: function(targetID, cb, arg) {
        if (targetID) {
          traverseParentPath('', targetID, cb, arg, true, true);
          traverseParentPath(targetID, '', cb, arg, true, true);
        }
      },
      traverseAncestors: function(targetID, cb, arg) {
        traverseParentPath('', targetID, cb, arg, true, false);
      },
      getFirstCommonAncestorID: getFirstCommonAncestorID,
      _getNextDescendantID: getNextDescendantID,
      isAncestorIDOf: isAncestorIDOf,
      SEPARATOR: SEPARATOR
    };
    module.exports = ReactInstanceHandles;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactMarkupChecksum", ["npm:react@0.14.0-beta3/lib/adler32"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var adler32 = require("npm:react@0.14.0-beta3/lib/adler32");
  var TAG_END = /\/?>/;
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function(markup) {
      var checksum = adler32(markup);
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    },
    canReuseMarkup: function(markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactRef", ["npm:react@0.14.0-beta3/lib/ReactOwner", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactOwner = require("npm:react@0.14.0-beta3/lib/ReactOwner");
    var ReactRef = {};
    function attachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(component.getPublicInstance());
      } else {
        ReactOwner.addComponentAsRefTo(component, ref, owner);
      }
    }
    function detachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(null);
      } else {
        ReactOwner.removeComponentAsRefFrom(component, ref, owner);
      }
    }
    ReactRef.attachRefs = function(instance, element) {
      var ref = element.ref;
      if (ref != null) {
        attachRef(ref, instance, element._owner);
      }
    };
    ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
      return nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref;
    };
    ReactRef.detachRefs = function(instance, element) {
      var ref = element.ref;
      if (ref != null) {
        detachRef(ref, instance, element._owner);
      }
    };
    module.exports = ReactRef;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/CallbackQueue", ["npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    function CallbackQueue() {
      this._callbacks = null;
      this._contexts = null;
    }
    assign(CallbackQueue.prototype, {
      enqueue: function(callback, context) {
        this._callbacks = this._callbacks || [];
        this._contexts = this._contexts || [];
        this._callbacks.push(callback);
        this._contexts.push(context);
      },
      notifyAll: function() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        if (callbacks) {
          !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0; i < callbacks.length; i++) {
            callbacks[i].call(contexts[i]);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      },
      reset: function() {
        this._callbacks = null;
        this._contexts = null;
      },
      destructor: function() {
        this.reset();
      }
    });
    PooledClass.addPoolingTo(CallbackQueue);
    module.exports = CallbackQueue;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/isTextNode", ["npm:fbjs@0.1.0-alpha.4/lib/isNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var isNode = require("npm:fbjs@0.1.0-alpha.4/lib/isNode");
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactCompositeComponent", ["npm:react@0.14.0-beta3/lib/ReactComponentEnvironment", "npm:react@0.14.0-beta3/lib/ReactCurrentOwner", "npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactInstanceMap", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocations", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames", "npm:react@0.14.0-beta3/lib/ReactReconciler", "npm:react@0.14.0-beta3/lib/ReactUpdateQueue", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/emptyObject", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:react@0.14.0-beta3/lib/shouldUpdateReactComponent", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponentEnvironment = require("npm:react@0.14.0-beta3/lib/ReactComponentEnvironment");
    var ReactCurrentOwner = require("npm:react@0.14.0-beta3/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactInstanceMap = require("npm:react@0.14.0-beta3/lib/ReactInstanceMap");
    var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
    var ReactPropTypeLocations = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocations");
    var ReactPropTypeLocationNames = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames");
    var ReactReconciler = require("npm:react@0.14.0-beta3/lib/ReactReconciler");
    var ReactUpdateQueue = require("npm:react@0.14.0-beta3/lib/ReactUpdateQueue");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var emptyObject = require("npm:fbjs@0.1.0-alpha.4/lib/emptyObject");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var shouldUpdateReactComponent = require("npm:react@0.14.0-beta3/lib/shouldUpdateReactComponent");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function getDeclarationErrorAddendum(component) {
      var owner = component._currentElement._owner || null;
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var nextMountID = 1;
    var ReactCompositeComponentMixin = {
      construct: function(element) {
        this._currentElement = element;
        this._rootNodeID = null;
        this._instance = null;
        this._pendingElement = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._renderedComponent = null;
        this._context = null;
        this._mountOrder = 0;
        this._topLevelWrapper = null;
        this._pendingCallbacks = null;
      },
      mountComponent: function(rootID, transaction, context) {
        this._context = context;
        this._mountOrder = nextMountID++;
        this._rootNodeID = rootID;
        var publicProps = this._processProps(this._currentElement.props);
        var publicContext = this._processContext(context);
        var Component = this._currentElement.type;
        var inst = new Component(publicProps, publicContext, ReactUpdateQueue);
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(inst.render != null, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render` in your ' + 'component or you may have accidentally tried to render an element ' + 'whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
        }
        inst.props = publicProps;
        inst.context = publicContext;
        inst.refs = emptyObject;
        inst.updater = ReactUpdateQueue;
        this._instance = inst;
        ReactInstanceMap.set(inst, this);
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
        }
        var initialState = inst.state;
        if (initialState === undefined) {
          inst.state = initialState = null;
        }
        !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        if (inst.componentWillMount) {
          inst.componentWillMount();
          if (this._pendingStateQueue) {
            inst.state = this._processPendingState(inst.props, inst.context);
          }
        }
        var renderedElement = this._renderValidatedComponent();
        this._renderedComponent = this._instantiateReactComponent(renderedElement);
        var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
        if (inst.componentDidMount) {
          transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
        }
        return markup;
      },
      unmountComponent: function() {
        var inst = this._instance;
        if (inst.componentWillUnmount) {
          inst.componentWillUnmount();
        }
        ReactReconciler.unmountComponent(this._renderedComponent);
        this._renderedComponent = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._pendingCallbacks = null;
        this._pendingElement = null;
        this._context = null;
        this._rootNodeID = null;
        this._topLevelWrapper = null;
        ReactInstanceMap.remove(inst);
      },
      _maskContext: function(context) {
        var maskedContext = null;
        var Component = this._currentElement.type;
        var contextTypes = Component.contextTypes;
        if (!contextTypes) {
          return emptyObject;
        }
        maskedContext = {};
        for (var contextName in contextTypes) {
          maskedContext[contextName] = context[contextName];
        }
        return maskedContext;
      },
      _processContext: function(context) {
        var maskedContext = this._maskContext(context);
        if (process.env.NODE_ENV !== 'production') {
          var Component = this._currentElement.type;
          if (Component.contextTypes) {
            this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
          }
        }
        return maskedContext;
      },
      _processChildContext: function(currentContext) {
        var Component = this._currentElement.type;
        var inst = this._instance;
        var childContext = inst.getChildContext && inst.getChildContext();
        if (childContext) {
          !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
          if (process.env.NODE_ENV !== 'production') {
            this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
          }
          for (var name in childContext) {
            !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
          }
          return assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _processProps: function(newProps) {
        if (process.env.NODE_ENV !== 'production') {
          var Component = this._currentElement.type;
          if (Component.propTypes) {
            this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
          }
        }
        return newProps;
      },
      _checkPropTypes: function(propTypes, props, location) {
        var componentName = this.getName();
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error;
            try {
              !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
              error = propTypes[propName](props, propName, componentName, location);
            } catch (ex) {
              error = ex;
            }
            if (error instanceof Error) {
              var addendum = getDeclarationErrorAddendum(this);
              if (location === ReactPropTypeLocations.prop) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
              } else {
                process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
              }
            }
          }
        }
      },
      receiveComponent: function(nextElement, transaction, nextContext) {
        var prevElement = this._currentElement;
        var prevContext = this._context;
        this._pendingElement = null;
        this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
      },
      performUpdateIfNecessary: function(transaction) {
        if (this._pendingElement != null) {
          ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
        }
        if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
          this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
        }
      },
      updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
        var inst = this._instance;
        var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
        var nextProps;
        if (prevParentElement === nextParentElement) {
          nextProps = nextParentElement.props;
        } else {
          nextProps = this._processProps(nextParentElement.props);
          if (inst.componentWillReceiveProps) {
            inst.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        var nextState = this._processPendingState(nextProps, nextContext);
        var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
        }
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
        } else {
          this._currentElement = nextParentElement;
          this._context = nextUnmaskedContext;
          inst.props = nextProps;
          inst.state = nextState;
          inst.context = nextContext;
        }
      },
      _processPendingState: function(props, context) {
        var inst = this._instance;
        var queue = this._pendingStateQueue;
        var replace = this._pendingReplaceState;
        this._pendingReplaceState = false;
        this._pendingStateQueue = null;
        if (!queue) {
          return inst.state;
        }
        if (replace && queue.length === 1) {
          return queue[0];
        }
        var nextState = assign({}, replace ? queue[0] : inst.state);
        for (var i = replace ? 1 : 0; i < queue.length; i++) {
          var partial = queue[i];
          assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
        }
        return nextState;
      },
      _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
        var inst = this._instance;
        var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
        var prevProps;
        var prevState;
        var prevContext;
        if (hasComponentDidUpdate) {
          prevProps = inst.props;
          prevState = inst.state;
          prevContext = inst.context;
        }
        if (inst.componentWillUpdate) {
          inst.componentWillUpdate(nextProps, nextState, nextContext);
        }
        this._currentElement = nextElement;
        this._context = unmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
        this._updateRenderedComponent(transaction, unmaskedContext);
        if (hasComponentDidUpdate) {
          transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
        }
      },
      _updateRenderedComponent: function(transaction, context) {
        var prevComponentInstance = this._renderedComponent;
        var prevRenderedElement = prevComponentInstance._currentElement;
        var nextRenderedElement = this._renderValidatedComponent();
        if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
          ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
        } else {
          var thisID = this._rootNodeID;
          var prevComponentID = prevComponentInstance._rootNodeID;
          ReactReconciler.unmountComponent(prevComponentInstance);
          this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
          var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
          this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
        }
      },
      _replaceNodeWithMarkupByID: function(prevComponentID, nextMarkup) {
        ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
      },
      _renderValidatedComponentWithoutOwnerOrContext: function() {
        var inst = this._instance;
        var renderedComponent = inst.render();
        if (process.env.NODE_ENV !== 'production') {
          if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
            renderedComponent = null;
          }
        }
        return renderedComponent;
      },
      _renderValidatedComponent: function() {
        var renderedComponent;
        ReactCurrentOwner.current = this;
        try {
          renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
        } finally {
          ReactCurrentOwner.current = null;
        }
        !(renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
        return renderedComponent;
      },
      attachRef: function(ref, component) {
        var inst = this.getPublicInstance();
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        refs[ref] = component.getPublicInstance();
      },
      detachRef: function(ref) {
        var refs = this.getPublicInstance().refs;
        delete refs[ref];
      },
      getName: function() {
        var type = this._currentElement.type;
        var constructor = this._instance && this._instance.constructor;
        return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
      },
      getPublicInstance: function() {
        return this._instance;
      },
      _instantiateReactComponent: null
    };
    ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
      mountComponent: 'mountComponent',
      updateComponent: 'updateComponent',
      _renderValidatedComponent: '_renderValidatedComponent'
    });
    var ReactCompositeComponent = {Mixin: ReactCompositeComponentMixin};
    module.exports = ReactCompositeComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/AutoFocusUtils", ["npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/findDOMNode", "npm:fbjs@0.1.0-alpha.4/lib/focusNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
  var findDOMNode = require("npm:react@0.14.0-beta3/lib/findDOMNode");
  var focusNode = require("npm:fbjs@0.1.0-alpha.4/lib/focusNode");
  var Mixin = {componentDidMount: function() {
      if (this.props.autoFocus) {
        focusNode(findDOMNode(this));
      }
    }};
  var AutoFocusUtils = {
    Mixin: Mixin,
    focusDOMComponent: function() {
      focusNode(ReactMount.getNode(this._rootNodeID));
    }
  };
  module.exports = AutoFocusUtils;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactPropTypes", ["npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactFragment", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames", "npm:fbjs@0.1.0-alpha.4/lib/emptyFunction", "npm:react@0.14.0-beta3/lib/getIteratorFn"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
  var ReactFragment = require("npm:react@0.14.0-beta3/lib/ReactFragment");
  var ReactPropTypeLocationNames = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames");
  var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
  var getIteratorFn = require("npm:react@0.14.0-beta3/lib/getIteratorFn");
  var ANONYMOUS = '<<anonymous>>';
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };
  function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location, propFullName) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        var preciseType = getPreciseType(propValue);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns(null));
  }
  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!ReactElement.isValidElement(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      return createChainableTypeChecker(function() {
        return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
      });
    }
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (propValue === expectedValues[i]) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }
  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      return createChainableTypeChecker(function() {
        return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
      });
    }
    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName) == null) {
          return null;
        }
      }
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }
  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }
  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || ReactElement.isValidElement(propValue)) {
          return true;
        }
        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          propValue = ReactFragment.extractIfFragment(propValue);
          for (var k in propValue) {
            if (!isNode(propValue[k])) {
              return false;
            }
          }
        }
        return true;
      default:
        return false;
    }
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      return 'object';
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }
  module.exports = ReactPropTypes;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactChildren", ["npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/ReactFragment", "npm:react@0.14.0-beta3/lib/traverseAllChildren", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
    var ReactFragment = require("npm:react@0.14.0-beta3/lib/ReactFragment");
    var traverseAllChildren = require("npm:react@0.14.0-beta3/lib/traverseAllChildren");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var twoArgumentPooler = PooledClass.twoArgumentPooler;
    var threeArgumentPooler = PooledClass.threeArgumentPooler;
    function ForEachBookKeeping(forEachFunction, forEachContext) {
      this.func = forEachFunction;
      this.context = forEachContext;
      this.count = 0;
    }
    PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
    function forEachSingleChild(traverseContext, child, name) {
      var bookKeeping = traverseContext;
      bookKeeping.func.call(bookKeeping.context, child, bookKeeping.count++);
    }
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      ForEachBookKeeping.release(traverseContext);
    }
    function MapBookKeeping(mapResult, mapFunction, mapContext) {
      this.result = mapResult;
      this.func = mapFunction;
      this.context = mapContext;
      this.count = 0;
    }
    PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
    function mapSingleChildIntoContext(traverseContext, child, name) {
      var bookKeeping = traverseContext;
      var mapResult = bookKeeping.result;
      var keyUnique = mapResult[name] === undefined;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'ReactChildren.map(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
      }
      if (keyUnique) {
        var mappedChild = bookKeeping.func.call(bookKeeping.context, child, bookKeeping.count++);
        mapResult[name] = mappedChild;
      }
    }
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var mapResult = {};
      var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      MapBookKeeping.release(traverseContext);
      return ReactFragment.create(mapResult);
    }
    function forEachSingleChildDummy(traverseContext, child, name) {
      return null;
    }
    function countChildren(children, context) {
      return traverseAllChildren(children, forEachSingleChildDummy, null);
    }
    var ReactChildren = {
      forEach: forEachChildren,
      map: mapChildren,
      count: countChildren
    };
    module.exports = ReactChildren;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactChildReconciler", ["npm:react@0.14.0-beta3/lib/ReactReconciler", "npm:react@0.14.0-beta3/lib/flattenChildren", "npm:react@0.14.0-beta3/lib/instantiateReactComponent", "npm:react@0.14.0-beta3/lib/shouldUpdateReactComponent", "npm:react@0.14.0-beta3/lib/traverseAllChildren", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactReconciler = require("npm:react@0.14.0-beta3/lib/ReactReconciler");
    var flattenChildren = require("npm:react@0.14.0-beta3/lib/flattenChildren");
    var instantiateReactComponent = require("npm:react@0.14.0-beta3/lib/instantiateReactComponent");
    var shouldUpdateReactComponent = require("npm:react@0.14.0-beta3/lib/shouldUpdateReactComponent");
    var traverseAllChildren = require("npm:react@0.14.0-beta3/lib/traverseAllChildren");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function instantiateChild(childInstances, child, name) {
      var keyUnique = childInstances[name] === undefined;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
      }
      if (child != null && keyUnique) {
        childInstances[name] = instantiateReactComponent(child, null);
      }
    }
    var ReactChildReconciler = {
      instantiateChildren: function(nestedChildNodes, transaction, context) {
        if (nestedChildNodes == null) {
          return null;
        }
        var childInstances = {};
        traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
        return childInstances;
      },
      updateChildren: function(prevChildren, nextNestedChildrenElements, transaction, context) {
        var nextChildren = flattenChildren(nextNestedChildrenElements);
        if (!nextChildren && !prevChildren) {
          return null;
        }
        var name;
        for (name in nextChildren) {
          if (!nextChildren.hasOwnProperty(name)) {
            continue;
          }
          var prevChild = prevChildren && prevChildren[name];
          var prevElement = prevChild && prevChild._currentElement;
          var nextElement = nextChildren[name];
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
            nextChildren[name] = prevChild;
          } else {
            if (prevChild) {
              ReactReconciler.unmountComponent(prevChild, name);
            }
            var nextChildInstance = instantiateReactComponent(nextElement, null);
            nextChildren[name] = nextChildInstance;
          }
        }
        for (name in prevChildren) {
          if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
            ReactReconciler.unmountComponent(prevChildren[name]);
          }
        }
        return nextChildren;
      },
      unmountChildren: function(renderedChildren) {
        for (var name in renderedChildren) {
          if (renderedChildren.hasOwnProperty(name)) {
            var renderedChild = renderedChildren[name];
            ReactReconciler.unmountComponent(renderedChild);
          }
        }
      }
    };
    module.exports = ReactChildReconciler;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/FallbackCompositionState", ["npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:react@0.14.0-beta3/lib/getTextContentAccessor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
  var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
  var getTextContentAccessor = require("npm:react@0.14.0-beta3/lib/getTextContentAccessor");
  function FallbackCompositionState(root) {
    this._root = root;
    this._startText = this.getText();
    this._fallbackText = null;
  }
  assign(FallbackCompositionState.prototype, {
    getText: function() {
      if ('value' in this._root) {
        return this._root.value;
      }
      return this._root[getTextContentAccessor()];
    },
    getData: function() {
      if (this._fallbackText) {
        return this._fallbackText;
      }
      var start;
      var startValue = this._startText;
      var startLength = startValue.length;
      var end;
      var endValue = this.getText();
      var endLength = endValue.length;
      for (start = 0; start < startLength; start++) {
        if (startValue[start] !== endValue[start]) {
          break;
        }
      }
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd; end++) {
        if (startValue[startLength - end] !== endValue[endLength - end]) {
          break;
        }
      }
      var sliceTail = end > 1 ? 1 - end : undefined;
      this._fallbackText = endValue.slice(start, sliceTail);
      return this._fallbackText;
    }
  });
  PooledClass.addPoolingTo(FallbackCompositionState);
  module.exports = FallbackCompositionState;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticCompositionEvent", ["npm:react@0.14.0-beta3/lib/SyntheticEvent"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("npm:react@0.14.0-beta3/lib/SyntheticEvent");
  var CompositionEventInterface = {data: null};
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ChangeEventPlugin", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:react@0.14.0-beta3/lib/EventPluginHub", "npm:react@0.14.0-beta3/lib/EventPropagators", "npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/SyntheticEvent", "npm:react@0.14.0-beta3/lib/isEventSupported", "npm:react@0.14.0-beta3/lib/isTextInputElement", "npm:fbjs@0.1.0-alpha.4/lib/keyOf", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.14.0-beta3/lib/EventPluginHub");
    var EventPropagators = require("npm:react@0.14.0-beta3/lib/EventPropagators");
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var SyntheticEvent = require("npm:react@0.14.0-beta3/lib/SyntheticEvent");
    var isEventSupported = require("npm:react@0.14.0-beta3/lib/isEventSupported");
    var isTextInputElement = require("npm:react@0.14.0-beta3/lib/isTextInputElement");
    var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {change: {
        phasedRegistrationNames: {
          bubbled: keyOf({onChange: null}),
          captured: keyOf({onChangeCapture: null})
        },
        dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
      }};
    var activeElement = null;
    var activeElementID = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, nativeEvent.target);
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    }
    function startWatchingForChangeEventIE8(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return ;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementID = null;
    }
    function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topChange) {
        return topLevelTargetID;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
    }
    var newValueProp = {
      get: function() {
        return activeElementValueProp.get.call(this);
      },
      set: function(val) {
        activeElementValue = '' + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetID) {
      activeElement = target;
      activeElementID = targetID;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
      Object.defineProperty(activeElement, 'value', newValueProp);
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return ;
      }
      delete activeElement.value;
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
      activeElement = null;
      activeElementID = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return ;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return ;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topInput) {
        return topLevelTargetID;
      }
    }
    function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topFocus) {
        stopWatchingForValueChange();
        startWatchingForValueChange(topLevelTarget, topLevelTargetID);
      } else if (topLevelType === topLevelTypes.topBlur) {
        stopWatchingForValueChange();
      }
    }
    function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementID;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
    }
    function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
      if (topLevelType === topLevelTypes.topClick) {
        return topLevelTargetID;
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
        var getTargetIDFunc,
            handleEventFunc;
        if (shouldUseChangeEvent(topLevelTarget)) {
          if (doesChangeEventBubble) {
            getTargetIDFunc = getTargetIDForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(topLevelTarget)) {
          if (isInputEventSupported) {
            getTargetIDFunc = getTargetIDForInputEvent;
          } else {
            getTargetIDFunc = getTargetIDForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(topLevelTarget)) {
          getTargetIDFunc = getTargetIDForClickEvent;
        }
        if (getTargetIDFunc) {
          var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
          if (targetID) {
            var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
            event.type = 'change';
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticUIEvent", ["npm:react@0.14.0-beta3/lib/SyntheticEvent", "npm:react@0.14.0-beta3/lib/getEventTarget"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticEvent = require("npm:react@0.14.0-beta3/lib/SyntheticEvent");
  var getEventTarget = require("npm:react@0.14.0-beta3/lib/getEventTarget");
  var UIEventInterface = {
    view: function(event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target != null && target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function(event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactEventListener", ["npm:fbjs@0.1.0-alpha.4/lib/EventListener", "npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/ReactInstanceHandles", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:react@0.14.0-beta3/lib/getEventTarget", "npm:fbjs@0.1.0-alpha.4/lib/getUnboundedScrollPosition", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventListener = require("npm:fbjs@0.1.0-alpha.4/lib/EventListener");
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
    var ReactInstanceHandles = require("npm:react@0.14.0-beta3/lib/ReactInstanceHandles");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var getEventTarget = require("npm:react@0.14.0-beta3/lib/getEventTarget");
    var getUnboundedScrollPosition = require("npm:fbjs@0.1.0-alpha.4/lib/getUnboundedScrollPosition");
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    function findParent(node) {
      var nodeID = ReactMount.getID(node);
      var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
      var container = ReactMount.findReactContainerForID(rootID);
      var parent = ReactMount.getFirstReactDOM(container);
      return parent;
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    assign(TopLevelCallbackBookKeeping.prototype, {destructor: function() {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      }});
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
        handleTopLevelWithPath(bookKeeping);
      } else {
        handleTopLevelWithoutPath(bookKeeping);
      }
    }
    function handleTopLevelWithoutPath(bookKeeping) {
      var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
      var ancestor = topLevelTarget;
      while (ancestor) {
        bookKeeping.ancestors.push(ancestor);
        ancestor = findParent(ancestor);
      }
      for (var i = 0; i < bookKeeping.ancestors.length; i++) {
        topLevelTarget = bookKeeping.ancestors[i];
        var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
      }
    }
    function handleTopLevelWithPath(bookKeeping) {
      var path = bookKeeping.nativeEvent.path;
      var currentNativeTarget = path[0];
      var eventsFired = 0;
      for (var i = 0; i < path.length; i++) {
        var currentPathElement = path[i];
        var currentPathElementID = ReactMount.getID(currentPathElement);
        if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
          currentNativeTarget = path[i + 1];
        }
        if (ReactMount.isRenderedByReact(currentPathElement)) {
          var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
          bookKeeping.ancestors.push(currentPathElement);
          var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
          eventsFired++;
          ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
          while (currentPathElementID !== newRootID) {
            i++;
            currentPathElement = path[i];
            currentPathElementID = ReactMount.getID(currentPathElement);
          }
        }
      }
      if (eventsFired === 0) {
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function(handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function(enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function() {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return null;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        var element = handle;
        if (!element) {
          return null;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function(refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
      },
      dispatchEvent: function(topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return ;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactComponent", ["npm:react@0.14.0-beta3/lib/ReactNoopUpdateQueue", "npm:fbjs@0.1.0-alpha.4/lib/emptyObject", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactNoopUpdateQueue = require("npm:react@0.14.0-beta3/lib/ReactNoopUpdateQueue");
    var emptyObject = require("npm:fbjs@0.1.0-alpha.4/lib/emptyObject");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function ReactComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    ReactComponent.prototype.setState = function(partialState, callback) {
      !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
      }
      this.updater.enqueueSetState(this, partialState);
      if (callback) {
        this.updater.enqueueCallback(this, callback);
      }
    };
    ReactComponent.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this);
      if (callback) {
        this.updater.enqueueCallback(this, callback);
      }
    };
    if (process.env.NODE_ENV !== 'production') {
      var deprecatedAPIs = {
        getDOMNode: ['getDOMNode', 'Use React.findDOMNode(component) instead.'],
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceProps: ['replaceProps', 'Instead, call React.render again at the top level.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
        setProps: ['setProps', 'Instead, call React.render again at the top level.']
      };
      var defineDeprecationWarning = function(methodName, info) {
        try {
          Object.defineProperty(ReactComponent.prototype, methodName, {get: function() {
              process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
              return undefined;
            }});
        } catch (x) {}
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    module.exports = ReactComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMSelection", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:react@0.14.0-beta3/lib/getNodeForCharacterOffset", "npm:react@0.14.0-beta3/lib/getTextContentAccessor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
  var getNodeForCharacterOffset = require("npm:react@0.14.0-beta3/lib/getNodeForCharacterOffset");
  var getTextContentAccessor = require("npm:react@0.14.0-beta3/lib/getTextContentAccessor");
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start,
        end;
    if (typeof offsets.end === 'undefined') {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return ;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticKeyboardEvent", ["npm:react@0.14.0-beta3/lib/SyntheticUIEvent", "npm:react@0.14.0-beta3/lib/getEventCharCode", "npm:react@0.14.0-beta3/lib/getEventKey", "npm:react@0.14.0-beta3/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("npm:react@0.14.0-beta3/lib/SyntheticUIEvent");
  var getEventCharCode = require("npm:react@0.14.0-beta3/lib/getEventCharCode");
  var getEventKey = require("npm:react@0.14.0-beta3/lib/getEventKey");
  var getEventModifierState = require("npm:react@0.14.0-beta3/lib/getEventModifierState");
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function(event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function(event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/performanceNow", ["npm:fbjs@0.1.0-alpha.4/lib/performance"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var performance = require("npm:fbjs@0.1.0-alpha.4/lib/performance");
  var curPerformance = performance;
  if (!curPerformance || !curPerformance.now) {
    curPerformance = Date;
  }
  var performanceNow = curPerformance.now.bind(curPerformance);
  module.exports = performanceNow;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactServerRendering", ["npm:react@0.14.0-beta3/lib/ReactDefaultBatchingStrategy", "npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactInstanceHandles", "npm:react@0.14.0-beta3/lib/ReactMarkupChecksum", "npm:react@0.14.0-beta3/lib/ReactServerBatchingStrategy", "npm:react@0.14.0-beta3/lib/ReactServerRenderingTransaction", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:fbjs@0.1.0-alpha.4/lib/emptyObject", "npm:react@0.14.0-beta3/lib/instantiateReactComponent", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactDefaultBatchingStrategy = require("npm:react@0.14.0-beta3/lib/ReactDefaultBatchingStrategy");
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactInstanceHandles = require("npm:react@0.14.0-beta3/lib/ReactInstanceHandles");
    var ReactMarkupChecksum = require("npm:react@0.14.0-beta3/lib/ReactMarkupChecksum");
    var ReactServerBatchingStrategy = require("npm:react@0.14.0-beta3/lib/ReactServerBatchingStrategy");
    var ReactServerRenderingTransaction = require("npm:react@0.14.0-beta3/lib/ReactServerRenderingTransaction");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var emptyObject = require("npm:fbjs@0.1.0-alpha.4/lib/emptyObject");
    var instantiateReactComponent = require("npm:react@0.14.0-beta3/lib/instantiateReactComponent");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    function renderToString(element) {
      !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
      var transaction;
      try {
        ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(false);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          var markup = componentInstance.mountComponent(id, transaction, emptyObject);
          return ReactMarkupChecksum.addChecksumToMarkup(markup);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
        ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      }
    }
    function renderToStaticMarkup(element) {
      !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
      var transaction;
      try {
        ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
        var id = ReactInstanceHandles.createReactRootID();
        transaction = ReactServerRenderingTransaction.getPooled(true);
        return transaction.perform(function() {
          var componentInstance = instantiateReactComponent(element, null);
          return componentInstance.mountComponent(id, transaction, emptyObject);
        }, null);
      } finally {
        ReactServerRenderingTransaction.release(transaction);
        ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      }
    }
    module.exports = {
      renderToString: renderToString,
      renderToStaticMarkup: renderToStaticMarkup
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMFactories", ["npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactElementValidator", "npm:fbjs@0.1.0-alpha.4/lib/mapObject", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.14.0-beta3/lib/ReactElementValidator");
    var mapObject = require("npm:fbjs@0.1.0-alpha.4/lib/mapObject");
    function createDOMFactory(tag) {
      if (process.env.NODE_ENV !== 'production') {
        return ReactElementValidator.createFactory(tag);
      }
      return ReactElement.createFactory(tag);
    }
    var ReactDOMFactories = mapObject({
      a: 'a',
      abbr: 'abbr',
      address: 'address',
      area: 'area',
      article: 'article',
      aside: 'aside',
      audio: 'audio',
      b: 'b',
      base: 'base',
      bdi: 'bdi',
      bdo: 'bdo',
      big: 'big',
      blockquote: 'blockquote',
      body: 'body',
      br: 'br',
      button: 'button',
      canvas: 'canvas',
      caption: 'caption',
      cite: 'cite',
      code: 'code',
      col: 'col',
      colgroup: 'colgroup',
      data: 'data',
      datalist: 'datalist',
      dd: 'dd',
      del: 'del',
      details: 'details',
      dfn: 'dfn',
      dialog: 'dialog',
      div: 'div',
      dl: 'dl',
      dt: 'dt',
      em: 'em',
      embed: 'embed',
      fieldset: 'fieldset',
      figcaption: 'figcaption',
      figure: 'figure',
      footer: 'footer',
      form: 'form',
      h1: 'h1',
      h2: 'h2',
      h3: 'h3',
      h4: 'h4',
      h5: 'h5',
      h6: 'h6',
      head: 'head',
      header: 'header',
      hgroup: 'hgroup',
      hr: 'hr',
      html: 'html',
      i: 'i',
      iframe: 'iframe',
      img: 'img',
      input: 'input',
      ins: 'ins',
      kbd: 'kbd',
      keygen: 'keygen',
      label: 'label',
      legend: 'legend',
      li: 'li',
      link: 'link',
      main: 'main',
      map: 'map',
      mark: 'mark',
      menu: 'menu',
      menuitem: 'menuitem',
      meta: 'meta',
      meter: 'meter',
      nav: 'nav',
      noscript: 'noscript',
      object: 'object',
      ol: 'ol',
      optgroup: 'optgroup',
      option: 'option',
      output: 'output',
      p: 'p',
      param: 'param',
      picture: 'picture',
      pre: 'pre',
      progress: 'progress',
      q: 'q',
      rp: 'rp',
      rt: 'rt',
      ruby: 'ruby',
      s: 's',
      samp: 'samp',
      script: 'script',
      section: 'section',
      select: 'select',
      small: 'small',
      source: 'source',
      span: 'span',
      strong: 'strong',
      style: 'style',
      sub: 'sub',
      summary: 'summary',
      sup: 'sup',
      table: 'table',
      tbody: 'tbody',
      td: 'td',
      textarea: 'textarea',
      tfoot: 'tfoot',
      th: 'th',
      thead: 'thead',
      time: 'time',
      title: 'title',
      tr: 'tr',
      track: 'track',
      u: 'u',
      ul: 'ul',
      'var': 'var',
      video: 'video',
      wbr: 'wbr',
      circle: 'circle',
      clipPath: 'clipPath',
      defs: 'defs',
      ellipse: 'ellipse',
      g: 'g',
      image: 'image',
      line: 'line',
      linearGradient: 'linearGradient',
      mask: 'mask',
      path: 'path',
      pattern: 'pattern',
      polygon: 'polygon',
      polyline: 'polyline',
      radialGradient: 'radialGradient',
      rect: 'rect',
      stop: 'stop',
      svg: 'svg',
      text: 'text',
      tspan: 'tspan'
    }, createDOMFactory);
    module.exports = ReactDOMFactories;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$", ["npm:core-js@0.9.18/library/modules/$.fw"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var global = typeof self != 'undefined' ? self : Function('return this')(),
      core = {},
      defineProperty = Object.defineProperty,
      hasOwnProperty = {}.hasOwnProperty,
      ceil = Math.ceil,
      floor = Math.floor,
      max = Math.max,
      min = Math.min;
  var DESC = !!function() {
    try {
      return defineProperty({}, 'a', {get: function() {
          return 2;
        }}).a == 2;
    } catch (e) {}
  }();
  var hide = createDefiner(1);
  function toInteger(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  }
  function desc(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  }
  function simpleSet(object, key, value) {
    object[key] = value;
    return object;
  }
  function createDefiner(bitmap) {
    return DESC ? function(object, key, value) {
      return $.setDesc(object, key, desc(bitmap, value));
    } : simpleSet;
  }
  function isObject(it) {
    return it !== null && (typeof it == 'object' || typeof it == 'function');
  }
  function isFunction(it) {
    return typeof it == 'function';
  }
  function assertDefined(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  }
  var $ = module.exports = require("npm:core-js@0.9.18/library/modules/$.fw")({
    g: global,
    core: core,
    html: global.document && document.documentElement,
    isObject: isObject,
    isFunction: isFunction,
    that: function() {
      return this;
    },
    toInteger: toInteger,
    toLength: function(it) {
      return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
    },
    toIndex: function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    },
    has: function(it, key) {
      return hasOwnProperty.call(it, key);
    },
    create: Object.create,
    getProto: Object.getPrototypeOf,
    DESC: DESC,
    desc: desc,
    getDesc: Object.getOwnPropertyDescriptor,
    setDesc: defineProperty,
    setDescs: Object.defineProperties,
    getKeys: Object.keys,
    getNames: Object.getOwnPropertyNames,
    getSymbols: Object.getOwnPropertySymbols,
    assertDefined: assertDefined,
    ES5Object: Object,
    toObject: function(it) {
      return $.ES5Object(assertDefined(it));
    },
    hide: hide,
    def: createDefiner(0),
    set: global.Symbol ? simpleSet : hide,
    each: [].forEach
  });
  if (typeof __e != 'undefined')
    __e = core;
  if (typeof __g != 'undefined')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/es6.object.statics-accept-primitives", ["npm:core-js@0.9.18/library/modules/$", "npm:core-js@0.9.18/library/modules/$.def", "npm:core-js@0.9.18/library/modules/$.get-names"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$"),
      $def = require("npm:core-js@0.9.18/library/modules/$.def"),
      isObject = $.isObject,
      toObject = $.toObject;
  $.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' + 'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(','), function(KEY, ID) {
    var fn = ($.core.Object || {})[KEY] || Object[KEY],
        forced = 0,
        method = {};
    method[KEY] = ID == 0 ? function freeze(it) {
      return isObject(it) ? fn(it) : it;
    } : ID == 1 ? function seal(it) {
      return isObject(it) ? fn(it) : it;
    } : ID == 2 ? function preventExtensions(it) {
      return isObject(it) ? fn(it) : it;
    } : ID == 3 ? function isFrozen(it) {
      return isObject(it) ? fn(it) : true;
    } : ID == 4 ? function isSealed(it) {
      return isObject(it) ? fn(it) : true;
    } : ID == 5 ? function isExtensible(it) {
      return isObject(it) ? fn(it) : false;
    } : ID == 6 ? function getOwnPropertyDescriptor(it, key) {
      return fn(toObject(it), key);
    } : ID == 7 ? function getPrototypeOf(it) {
      return fn(Object($.assertDefined(it)));
    } : ID == 8 ? function keys(it) {
      return fn(toObject(it));
    } : require("npm:core-js@0.9.18/library/modules/$.get-names").get;
    try {
      fn('z');
    } catch (e) {
      forced = 1;
    }
    $def($def.S + $def.F * forced, 'Object', method);
  });
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/core-js/object/create", ["npm:core-js@0.9.18/library/fn/object/create"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.18/library/fn/object/create"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/$.set-proto", ["npm:core-js@0.9.18/library/modules/$", "npm:core-js@0.9.18/library/modules/$.assert", "npm:core-js@0.9.18/library/modules/$.ctx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$"),
      assert = require("npm:core-js@0.9.18/library/modules/$.assert");
  function check(O, proto) {
    assert.obj(O);
    assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
  }
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(buggy, set) {
      try {
        set = require("npm:core-js@0.9.18/library/modules/$.ctx")(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
        set({}, []);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }() : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/core-js/object/define-property", ["npm:core-js@0.9.18/library/fn/object/define-property"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.18/library/fn/object/define-property"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3/lib/Dispatcher", ["npm:flux@2.0.3/lib/invariant"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var invariant = require("npm:flux@2.0.3/lib/invariant");
  var _lastID = 1;
  var _prefix = 'ID_';
  function Dispatcher() {
    this.$Dispatcher_callbacks = {};
    this.$Dispatcher_isPending = {};
    this.$Dispatcher_isHandled = {};
    this.$Dispatcher_isDispatching = false;
    this.$Dispatcher_pendingPayload = null;
  }
  Dispatcher.prototype.register = function(callback) {
    var id = _prefix + _lastID++;
    this.$Dispatcher_callbacks[id] = callback;
    return id;
  };
  Dispatcher.prototype.unregister = function(id) {
    invariant(this.$Dispatcher_callbacks[id], 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id);
    delete this.$Dispatcher_callbacks[id];
  };
  Dispatcher.prototype.waitFor = function(ids) {
    invariant(this.$Dispatcher_isDispatching, 'Dispatcher.waitFor(...): Must be invoked while dispatching.');
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this.$Dispatcher_isPending[id]) {
        invariant(this.$Dispatcher_isHandled[id], 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id);
        continue;
      }
      invariant(this.$Dispatcher_callbacks[id], 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id);
      this.$Dispatcher_invokeCallback(id);
    }
  };
  Dispatcher.prototype.dispatch = function(payload) {
    invariant(!this.$Dispatcher_isDispatching, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.');
    this.$Dispatcher_startDispatching(payload);
    try {
      for (var id in this.$Dispatcher_callbacks) {
        if (this.$Dispatcher_isPending[id]) {
          continue;
        }
        this.$Dispatcher_invokeCallback(id);
      }
    } finally {
      this.$Dispatcher_stopDispatching();
    }
  };
  Dispatcher.prototype.isDispatching = function() {
    return this.$Dispatcher_isDispatching;
  };
  Dispatcher.prototype.$Dispatcher_invokeCallback = function(id) {
    this.$Dispatcher_isPending[id] = true;
    this.$Dispatcher_callbacks[id](this.$Dispatcher_pendingPayload);
    this.$Dispatcher_isHandled[id] = true;
  };
  Dispatcher.prototype.$Dispatcher_startDispatching = function(payload) {
    for (var id in this.$Dispatcher_callbacks) {
      this.$Dispatcher_isPending[id] = false;
      this.$Dispatcher_isHandled[id] = false;
    }
    this.$Dispatcher_pendingPayload = payload;
    this.$Dispatcher_isDispatching = true;
  };
  Dispatcher.prototype.$Dispatcher_stopDispatching = function() {
    this.$Dispatcher_pendingPayload = null;
    this.$Dispatcher_isDispatching = false;
  };
  module.exports = Dispatcher;
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib/utils/StateFunctions", ["npm:alt@0.17.1/utils/functions"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  exports.setAppState = setAppState;
  exports.snapshot = snapshot;
  exports.saveInitialSnapshot = saveInitialSnapshot;
  exports.filterSnapshots = filterSnapshots;
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  var _utilsFunctions = require("npm:alt@0.17.1/utils/functions");
  var fn = _interopRequireWildcard(_utilsFunctions);
  function setAppState(instance, data, onStore) {
    var obj = instance.deserialize(data);
    fn.eachObject(function(key, value) {
      var store = instance.stores[key];
      if (store) {
        (function() {
          var config = store.StoreModel.config;
          var state = store.state;
          if (config.onDeserialize)
            obj[key] = config.onDeserialize(value) || value;
          fn.eachObject(function(k) {
            return delete state[k];
          }, [state]);
          fn.assign(state, obj[key]);
          onStore(store);
        })();
      }
    }, [obj]);
  }
  function snapshot(instance) {
    var storeNames = arguments[1] === undefined ? [] : arguments[1];
    var stores = storeNames.length ? storeNames : Object.keys(instance.stores);
    return stores.reduce(function(obj, storeHandle) {
      var storeName = storeHandle.displayName || storeHandle;
      var store = instance.stores[storeName];
      var config = store.StoreModel.config;
      store.lifecycle('snapshot');
      var customSnapshot = config.onSerialize && config.onSerialize(store.state);
      obj[storeName] = customSnapshot ? customSnapshot : store.getState();
      return obj;
    }, {});
  }
  function saveInitialSnapshot(instance, key) {
    var state = instance.deserialize(instance.serialize(instance.stores[key].state));
    instance._initSnapshot[key] = state;
    instance._lastSnapshot[key] = state;
  }
  function filterSnapshots(instance, state, stores) {
    return stores.reduce(function(obj, store) {
      var storeName = store.displayName || store;
      if (!state[storeName]) {
        throw new ReferenceError(storeName + ' is not a valid store');
      }
      obj[storeName] = state[storeName];
      return obj;
    }, {});
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:transmitter@1.0.2", ["npm:transmitter@1.0.2/dist/transmitter"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:transmitter@1.0.2/dist/transmitter");
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0/index", ["npm:rx@3.0.0/dist/rx", "npm:rx@3.0.0/dist/rx.aggregates", "npm:rx@3.0.0/dist/rx.async", "npm:rx@3.0.0/dist/rx.backpressure", "npm:rx@3.0.0/dist/rx.binding", "npm:rx@3.0.0/dist/rx.coincidence", "npm:rx@3.0.0/dist/rx.experimental", "npm:rx@3.0.0/dist/rx.joinpatterns", "npm:rx@3.0.0/dist/rx.sorting", "npm:rx@3.0.0/dist/rx.virtualtime", "npm:rx@3.0.0/dist/rx.testing", "npm:rx@3.0.0/dist/rx.time"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@3.0.0/dist/rx");
  require("npm:rx@3.0.0/dist/rx.aggregates");
  require("npm:rx@3.0.0/dist/rx.async");
  require("npm:rx@3.0.0/dist/rx.backpressure");
  require("npm:rx@3.0.0/dist/rx.binding");
  require("npm:rx@3.0.0/dist/rx.coincidence");
  require("npm:rx@3.0.0/dist/rx.experimental");
  require("npm:rx@3.0.0/dist/rx.joinpatterns");
  require("npm:rx@3.0.0/dist/rx.sorting");
  require("npm:rx@3.0.0/dist/rx.virtualtime");
  require("npm:rx@3.0.0/dist/rx.testing");
  require("npm:rx@3.0.0/dist/rx.time");
  module.exports = Rx;
  global.define = __define;
  return module.exports;
});

System.register("npm:base64-js@0.0.8", ["npm:base64-js@0.0.8/lib/b64"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:base64-js@0.0.8/lib/b64");
  global.define = __define;
  return module.exports;
});

System.register("npm:ieee754@1.1.6", ["npm:ieee754@1.1.6/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:ieee754@1.1.6/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:is-array@1.0.1", ["npm:is-array@1.0.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:is-array@1.0.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:eventemitter3@0.1.6", ["npm:eventemitter3@0.1.6/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:eventemitter3@0.1.6/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14/lib/mediaconnection", ["npm:peerjs@0.3.14/lib/util", "npm:eventemitter3@0.1.6", "npm:peerjs@0.3.14/lib/negotiator"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var util = require("npm:peerjs@0.3.14/lib/util");
  var EventEmitter = require("npm:eventemitter3@0.1.6");
  var Negotiator = require("npm:peerjs@0.3.14/lib/negotiator");
  function MediaConnection(peer, provider, options) {
    if (!(this instanceof MediaConnection))
      return new MediaConnection(peer, provider, options);
    EventEmitter.call(this);
    this.options = util.extend({}, options);
    this.open = false;
    this.type = 'media';
    this.peer = peer;
    this.provider = provider;
    this.metadata = this.options.metadata;
    this.localStream = this.options._stream;
    this.id = this.options.connectionId || MediaConnection._idPrefix + util.randomToken();
    if (this.localStream) {
      Negotiator.startConnection(this, {
        _stream: this.localStream,
        originator: true
      });
    }
  }
  ;
  util.inherits(MediaConnection, EventEmitter);
  MediaConnection._idPrefix = 'mc_';
  MediaConnection.prototype.addStream = function(remoteStream) {
    util.log('Receiving stream', remoteStream);
    this.remoteStream = remoteStream;
    this.emit('stream', remoteStream);
  };
  MediaConnection.prototype.handleMessage = function(message) {
    var payload = message.payload;
    switch (message.type) {
      case 'ANSWER':
        Negotiator.handleSDP(message.type, this, payload.sdp);
        this.open = true;
        break;
      case 'CANDIDATE':
        Negotiator.handleCandidate(this, payload.candidate);
        break;
      default:
        util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
        break;
    }
  };
  MediaConnection.prototype.answer = function(stream) {
    if (this.localStream) {
      util.warn('Local stream already exists on this MediaConnection. Are you answering a call twice?');
      return ;
    }
    this.options._payload._stream = stream;
    this.localStream = stream;
    Negotiator.startConnection(this, this.options._payload);
    var messages = this.provider._getMessages(this.id);
    for (var i = 0,
        ii = messages.length; i < ii; i += 1) {
      this.handleMessage(messages[i]);
    }
    this.open = true;
  };
  MediaConnection.prototype.close = function() {
    if (!this.open) {
      return ;
    }
    this.open = false;
    Negotiator.cleanup(this);
    this.emit('close');
  };
  module.exports = MediaConnection;
  global.define = __define;
  return module.exports;
});

System.register("github:michelle/reliable@master/lib/reliable", ["github:michelle/reliable@master/lib/util"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var util = require("github:michelle/reliable@master/lib/util");
  function Reliable(dc, debug) {
    if (!(this instanceof Reliable))
      return new Reliable(dc);
    this._dc = dc;
    util.debug = debug;
    this._outgoing = {};
    this._incoming = {};
    this._received = {};
    this._window = 1000;
    this._mtu = 500;
    this._interval = 0;
    this._count = 0;
    this._queue = [];
    this._setupDC();
  }
  ;
  Reliable.prototype.send = function(msg) {
    var bl = util.pack(msg);
    if (bl.size < this._mtu) {
      this._handleSend(['no', bl]);
      return ;
    }
    this._outgoing[this._count] = {
      ack: 0,
      chunks: this._chunk(bl)
    };
    if (util.debug) {
      this._outgoing[this._count].timer = new Date();
    }
    this._sendWindowedChunks(this._count);
    this._count += 1;
  };
  Reliable.prototype._setupInterval = function() {
    var self = this;
    this._timeout = setInterval(function() {
      var msg = self._queue.shift();
      if (msg._multiple) {
        for (var i = 0,
            ii = msg.length; i < ii; i += 1) {
          self._intervalSend(msg[i]);
        }
      } else {
        self._intervalSend(msg);
      }
    }, this._interval);
  };
  Reliable.prototype._intervalSend = function(msg) {
    var self = this;
    msg = util.pack(msg);
    util.blobToBinaryString(msg, function(str) {
      self._dc.send(str);
    });
    if (self._queue.length === 0) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }
  };
  Reliable.prototype._processAcks = function() {
    for (var id in this._outgoing) {
      if (this._outgoing.hasOwnProperty(id)) {
        this._sendWindowedChunks(id);
      }
    }
  };
  Reliable.prototype._handleSend = function(msg) {
    var push = true;
    for (var i = 0,
        ii = this._queue.length; i < ii; i += 1) {
      var item = this._queue[i];
      if (item === msg) {
        push = false;
      } else if (item._multiple && item.indexOf(msg) !== -1) {
        push = false;
      }
    }
    if (push) {
      this._queue.push(msg);
      if (!this._timeout) {
        this._setupInterval();
      }
    }
  };
  Reliable.prototype._setupDC = function() {
    var self = this;
    this._dc.onmessage = function(e) {
      var msg = e.data;
      var datatype = msg.constructor;
      if (datatype === String) {
        var ab = util.binaryStringToArrayBuffer(msg);
        msg = util.unpack(ab);
        self._handleMessage(msg);
      }
    };
  };
  Reliable.prototype._handleMessage = function(msg) {
    var id = msg[1];
    var idata = this._incoming[id];
    var odata = this._outgoing[id];
    var data;
    switch (msg[0]) {
      case 'no':
        var message = id;
        if (!!message) {
          this.onmessage(util.unpack(message));
        }
        break;
      case 'end':
        data = idata;
        this._received[id] = msg[2];
        if (!data) {
          break;
        }
        this._ack(id);
        break;
      case 'ack':
        data = odata;
        if (!!data) {
          var ack = msg[2];
          data.ack = Math.max(ack, data.ack);
          if (data.ack >= data.chunks.length) {
            util.log('Time: ', new Date() - data.timer);
            delete this._outgoing[id];
          } else {
            this._processAcks();
          }
        }
        break;
      case 'chunk':
        data = idata;
        if (!data) {
          var end = this._received[id];
          if (end === true) {
            break;
          }
          data = {
            ack: ['ack', id, 0],
            chunks: []
          };
          this._incoming[id] = data;
        }
        var n = msg[2];
        var chunk = msg[3];
        data.chunks[n] = new Uint8Array(chunk);
        if (n === data.ack[2]) {
          this._calculateNextAck(id);
        }
        this._ack(id);
        break;
      default:
        this._handleSend(msg);
        break;
    }
  };
  Reliable.prototype._chunk = function(bl) {
    var chunks = [];
    var size = bl.size;
    var start = 0;
    while (start < size) {
      var end = Math.min(size, start + this._mtu);
      var b = bl.slice(start, end);
      var chunk = {payload: b};
      chunks.push(chunk);
      start = end;
    }
    util.log('Created', chunks.length, 'chunks.');
    return chunks;
  };
  Reliable.prototype._ack = function(id) {
    var ack = this._incoming[id].ack;
    if (this._received[id] === ack[2]) {
      this._complete(id);
      this._received[id] = true;
    }
    this._handleSend(ack);
  };
  Reliable.prototype._calculateNextAck = function(id) {
    var data = this._incoming[id];
    var chunks = data.chunks;
    for (var i = 0,
        ii = chunks.length; i < ii; i += 1) {
      if (chunks[i] === undefined) {
        data.ack[2] = i;
        return ;
      }
    }
    data.ack[2] = chunks.length;
  };
  Reliable.prototype._sendWindowedChunks = function(id) {
    util.log('sendWindowedChunks for: ', id);
    var data = this._outgoing[id];
    var ch = data.chunks;
    var chunks = [];
    var limit = Math.min(data.ack + this._window, ch.length);
    for (var i = data.ack; i < limit; i += 1) {
      if (!ch[i].sent || i === data.ack) {
        ch[i].sent = true;
        chunks.push(['chunk', id, i, ch[i].payload]);
      }
    }
    if (data.ack + this._window >= ch.length) {
      chunks.push(['end', id, ch.length]);
    }
    chunks._multiple = true;
    this._handleSend(chunks);
  };
  Reliable.prototype._complete = function(id) {
    util.log('Completed called for', id);
    var self = this;
    var chunks = this._incoming[id].chunks;
    var bl = new Blob(chunks);
    util.blobToArrayBuffer(bl, function(ab) {
      self.onmessage(util.unpack(ab));
    });
    delete this._incoming[id];
  };
  Reliable.higherBandwidthSDP = function(sdp) {
    var version = navigator.appVersion.match(/Chrome\/(.*?) /);
    if (version) {
      version = parseInt(version[1].split('.').shift());
      if (version < 31) {
        var parts = sdp.split('b=AS:30');
        var replace = 'b=AS:102400';
        if (parts.length > 1) {
          return parts[0] + replace + parts[1];
        }
      }
    }
    return sdp;
  };
  Reliable.prototype.onmessage = function(msg) {};
  module.exports.Reliable = Reliable;
  global.define = __define;
  return module.exports;
});

System.register("npm:adapterjs@0.11.1", ["npm:adapterjs@0.11.1/publish/adapter.min"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:adapterjs@0.11.1/publish/adapter.min");
  global.define = __define;
  return module.exports;
});

System.register("npm:crypt@0.0.1", ["npm:crypt@0.0.1/crypt"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:crypt@0.0.1/crypt");
  global.define = __define;
  return module.exports;
});

System.register("npm:charenc@0.0.1", ["npm:charenc@0.0.1/charenc"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:charenc@0.0.1/charenc");
  global.define = __define;
  return module.exports;
});

System.register("npm:is-buffer@1.0.2", ["npm:is-buffer@1.0.2/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:is-buffer@1.0.2/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:URIjs@1.16.0/src/URI", ["npm:URIjs@1.16.0/src/punycode", "npm:URIjs@1.16.0/src/IPv6", "npm:URIjs@1.16.0/src/SecondLevelDomains"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory(require("npm:URIjs@1.16.0/src/punycode"), require("npm:URIjs@1.16.0/src/IPv6"), require("npm:URIjs@1.16.0/src/SecondLevelDomains"));
    } else if (typeof define === 'function' && define.amd) {
      define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory);
    } else {
      root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
    }
  }(this, function(punycode, IPv6, SLD, root) {
    'use strict';
    var _URI = root && root.URI;
    function URI(url, base) {
      var _urlSupplied = arguments.length >= 1;
      var _baseSupplied = arguments.length >= 2;
      if (!(this instanceof URI)) {
        if (_urlSupplied) {
          if (_baseSupplied) {
            return new URI(url, base);
          }
          return new URI(url);
        }
        return new URI();
      }
      if (url === undefined) {
        if (_urlSupplied) {
          throw new TypeError('undefined is not a valid argument for URI');
        }
        if (typeof location !== 'undefined') {
          url = location.href + '';
        } else {
          url = '';
        }
      }
      this.href(url);
      if (base !== undefined) {
        return this.absoluteTo(base);
      }
      return this;
    }
    URI.version = '1.16.0';
    var p = URI.prototype;
    var hasOwn = Object.prototype.hasOwnProperty;
    function escapeRegEx(string) {
      return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    }
    function getType(value) {
      if (value === undefined) {
        return 'Undefined';
      }
      return String(Object.prototype.toString.call(value)).slice(8, -1);
    }
    function isArray(obj) {
      return getType(obj) === 'Array';
    }
    function filterArrayValues(data, value) {
      var lookup = {};
      var i,
          length;
      if (getType(value) === 'RegExp') {
        lookup = null;
      } else if (isArray(value)) {
        for (i = 0, length = value.length; i < length; i++) {
          lookup[value[i]] = true;
        }
      } else {
        lookup[value] = true;
      }
      for (i = 0, length = data.length; i < length; i++) {
        var _match = lookup && lookup[data[i]] !== undefined || !lookup && value.test(data[i]);
        if (_match) {
          data.splice(i, 1);
          length--;
          i--;
        }
      }
      return data;
    }
    function arrayContains(list, value) {
      var i,
          length;
      if (isArray(value)) {
        for (i = 0, length = value.length; i < length; i++) {
          if (!arrayContains(list, value[i])) {
            return false;
          }
        }
        return true;
      }
      var _type = getType(value);
      for (i = 0, length = list.length; i < length; i++) {
        if (_type === 'RegExp') {
          if (typeof list[i] === 'string' && list[i].match(value)) {
            return true;
          }
        } else if (list[i] === value) {
          return true;
        }
      }
      return false;
    }
    function arraysEqual(one, two) {
      if (!isArray(one) || !isArray(two)) {
        return false;
      }
      if (one.length !== two.length) {
        return false;
      }
      one.sort();
      two.sort();
      for (var i = 0,
          l = one.length; i < l; i++) {
        if (one[i] !== two[i]) {
          return false;
        }
      }
      return true;
    }
    URI._parts = function() {
      return {
        protocol: null,
        username: null,
        password: null,
        hostname: null,
        urn: null,
        port: null,
        path: null,
        query: null,
        fragment: null,
        duplicateQueryParameters: URI.duplicateQueryParameters,
        escapeQuerySpace: URI.escapeQuerySpace
      };
    };
    URI.duplicateQueryParameters = false;
    URI.escapeQuerySpace = true;
    URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
    URI.idn_expression = /[^a-z0-9\.-]/i;
    URI.punycode_expression = /(xn--)/i;
    URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
    URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
    URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
    URI.findUri = {
      start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
      end: /[\s\r\n]|$/,
      trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
    };
    URI.defaultPorts = {
      http: '80',
      https: '443',
      ftp: '21',
      gopher: '70',
      ws: '80',
      wss: '443'
    };
    URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
    URI.domAttributes = {
      'a': 'href',
      'blockquote': 'cite',
      'link': 'href',
      'base': 'href',
      'script': 'src',
      'form': 'action',
      'img': 'src',
      'area': 'href',
      'iframe': 'src',
      'embed': 'src',
      'source': 'src',
      'track': 'src',
      'input': 'src',
      'audio': 'src',
      'video': 'src'
    };
    URI.getDomAttribute = function(node) {
      if (!node || !node.nodeName) {
        return undefined;
      }
      var nodeName = node.nodeName.toLowerCase();
      if (nodeName === 'input' && node.type !== 'image') {
        return undefined;
      }
      return URI.domAttributes[nodeName];
    };
    function escapeForDumbFirefox36(value) {
      return escape(value);
    }
    function strictEncodeURIComponent(string) {
      return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, '%2A');
    }
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
    URI.iso8859 = function() {
      URI.encode = escape;
      URI.decode = unescape;
    };
    URI.unicode = function() {
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
    };
    URI.characters = {
      pathname: {
        encode: {
          expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
          map: {
            '%24': '$',
            '%26': '&',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '=',
            '%3A': ':',
            '%40': '@'
          }
        },
        decode: {
          expression: /[\/\?#]/g,
          map: {
            '/': '%2F',
            '?': '%3F',
            '#': '%23'
          }
        }
      },
      reserved: {encode: {
          expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
          map: {
            '%3A': ':',
            '%2F': '/',
            '%3F': '?',
            '%23': '#',
            '%5B': '[',
            '%5D': ']',
            '%40': '@',
            '%21': '!',
            '%24': '$',
            '%26': '&',
            '%27': '\'',
            '%28': '(',
            '%29': ')',
            '%2A': '*',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '='
          }
        }},
      urnpath: {
        encode: {
          expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
          map: {
            '%21': '!',
            '%24': '$',
            '%27': '\'',
            '%28': '(',
            '%29': ')',
            '%2A': '*',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '=',
            '%40': '@'
          }
        },
        decode: {
          expression: /[\/\?#:]/g,
          map: {
            '/': '%2F',
            '?': '%3F',
            '#': '%23',
            ':': '%3A'
          }
        }
      }
    };
    URI.encodeQuery = function(string, escapeQuerySpace) {
      var escaped = URI.encode(string + '');
      if (escapeQuerySpace === undefined) {
        escapeQuerySpace = URI.escapeQuerySpace;
      }
      return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
    };
    URI.decodeQuery = function(string, escapeQuerySpace) {
      string += '';
      if (escapeQuerySpace === undefined) {
        escapeQuerySpace = URI.escapeQuerySpace;
      }
      try {
        return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
      } catch (e) {
        return string;
      }
    };
    var _parts = {
      'encode': 'encode',
      'decode': 'decode'
    };
    var _part;
    var generateAccessor = function(_group, _part) {
      return function(string) {
        try {
          return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
            return URI.characters[_group][_part].map[c];
          });
        } catch (e) {
          return string;
        }
      };
    };
    for (_part in _parts) {
      URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
      URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
    }
    var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
      return function(string) {
        var actualCodingFunc;
        if (!_innerCodingFuncName) {
          actualCodingFunc = URI[_codingFuncName];
        } else {
          actualCodingFunc = function(string) {
            return URI[_codingFuncName](URI[_innerCodingFuncName](string));
          };
        }
        var segments = (string + '').split(_sep);
        for (var i = 0,
            length = segments.length; i < length; i++) {
          segments[i] = actualCodingFunc(segments[i]);
        }
        return segments.join(_sep);
      };
    };
    URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
    URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
    URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
    URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');
    URI.encodeReserved = generateAccessor('reserved', 'encode');
    URI.parse = function(string, parts) {
      var pos;
      if (!parts) {
        parts = {};
      }
      pos = string.indexOf('#');
      if (pos > -1) {
        parts.fragment = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      pos = string.indexOf('?');
      if (pos > -1) {
        parts.query = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      if (string.substring(0, 2) === '//') {
        parts.protocol = null;
        string = string.substring(2);
        string = URI.parseAuthority(string, parts);
      } else {
        pos = string.indexOf(':');
        if (pos > -1) {
          parts.protocol = string.substring(0, pos) || null;
          if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
            parts.protocol = undefined;
          } else if (string.substring(pos + 1, pos + 3) === '//') {
            string = string.substring(pos + 3);
            string = URI.parseAuthority(string, parts);
          } else {
            string = string.substring(pos + 1);
            parts.urn = true;
          }
        }
      }
      parts.path = string;
      return parts;
    };
    URI.parseHost = function(string, parts) {
      string = string.replace(/\\/g, '/');
      var pos = string.indexOf('/');
      var bracketPos;
      var t;
      if (pos === -1) {
        pos = string.length;
      }
      if (string.charAt(0) === '[') {
        bracketPos = string.indexOf(']');
        parts.hostname = string.substring(1, bracketPos) || null;
        parts.port = string.substring(bracketPos + 2, pos) || null;
        if (parts.port === '/') {
          parts.port = null;
        }
      } else {
        var firstColon = string.indexOf(':');
        var firstSlash = string.indexOf('/');
        var nextColon = string.indexOf(':', firstColon + 1);
        if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
          parts.hostname = string.substring(0, pos) || null;
          parts.port = null;
        } else {
          t = string.substring(0, pos).split(':');
          parts.hostname = t[0] || null;
          parts.port = t[1] || null;
        }
      }
      if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
        pos++;
        string = '/' + string;
      }
      return string.substring(pos) || '/';
    };
    URI.parseAuthority = function(string, parts) {
      string = URI.parseUserinfo(string, parts);
      return URI.parseHost(string, parts);
    };
    URI.parseUserinfo = function(string, parts) {
      var firstSlash = string.indexOf('/');
      var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
      var t;
      if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
        t = string.substring(0, pos).split(':');
        parts.username = t[0] ? URI.decode(t[0]) : null;
        t.shift();
        parts.password = t[0] ? URI.decode(t.join(':')) : null;
        string = string.substring(pos + 1);
      } else {
        parts.username = null;
        parts.password = null;
      }
      return string;
    };
    URI.parseQuery = function(string, escapeQuerySpace) {
      if (!string) {
        return {};
      }
      string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');
      if (!string) {
        return {};
      }
      var items = {};
      var splits = string.split('&');
      var length = splits.length;
      var v,
          name,
          value;
      for (var i = 0; i < length; i++) {
        v = splits[i].split('=');
        name = URI.decodeQuery(v.shift(), escapeQuerySpace);
        value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;
        if (hasOwn.call(items, name)) {
          if (typeof items[name] === 'string' || items[name] === null) {
            items[name] = [items[name]];
          }
          items[name].push(value);
        } else {
          items[name] = value;
        }
      }
      return items;
    };
    URI.build = function(parts) {
      var t = '';
      if (parts.protocol) {
        t += parts.protocol + ':';
      }
      if (!parts.urn && (t || parts.hostname)) {
        t += '//';
      }
      t += (URI.buildAuthority(parts) || '');
      if (typeof parts.path === 'string') {
        if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
          t += '/';
        }
        t += parts.path;
      }
      if (typeof parts.query === 'string' && parts.query) {
        t += '?' + parts.query;
      }
      if (typeof parts.fragment === 'string' && parts.fragment) {
        t += '#' + parts.fragment;
      }
      return t;
    };
    URI.buildHost = function(parts) {
      var t = '';
      if (!parts.hostname) {
        return '';
      } else if (URI.ip6_expression.test(parts.hostname)) {
        t += '[' + parts.hostname + ']';
      } else {
        t += parts.hostname;
      }
      if (parts.port) {
        t += ':' + parts.port;
      }
      return t;
    };
    URI.buildAuthority = function(parts) {
      return URI.buildUserinfo(parts) + URI.buildHost(parts);
    };
    URI.buildUserinfo = function(parts) {
      var t = '';
      if (parts.username) {
        t += URI.encode(parts.username);
        if (parts.password) {
          t += ':' + URI.encode(parts.password);
        }
        t += '@';
      }
      return t;
    };
    URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
      var t = '';
      var unique,
          key,
          i,
          length;
      for (key in data) {
        if (hasOwn.call(data, key) && key) {
          if (isArray(data[key])) {
            unique = {};
            for (i = 0, length = data[key].length; i < length; i++) {
              if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
                t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                if (duplicateQueryParameters !== true) {
                  unique[data[key][i] + ''] = true;
                }
              }
            }
          } else if (data[key] !== undefined) {
            t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
          }
        }
      }
      return t.substring(1);
    };
    URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
      return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
    };
    URI.addQuery = function(data, name, value) {
      if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            URI.addQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === 'string') {
        if (data[name] === undefined) {
          data[name] = value;
          return ;
        } else if (typeof data[name] === 'string') {
          data[name] = [data[name]];
        }
        if (!isArray(value)) {
          value = [value];
        }
        data[name] = (data[name] || []).concat(value);
      } else {
        throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
      }
    };
    URI.removeQuery = function(data, name, value) {
      var i,
          length,
          key;
      if (isArray(name)) {
        for (i = 0, length = name.length; i < length; i++) {
          data[name[i]] = undefined;
        }
      } else if (getType(name) === 'RegExp') {
        for (key in data) {
          if (name.test(key)) {
            data[key] = undefined;
          }
        }
      } else if (typeof name === 'object') {
        for (key in name) {
          if (hasOwn.call(name, key)) {
            URI.removeQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === 'string') {
        if (value !== undefined) {
          if (getType(value) === 'RegExp') {
            if (!isArray(data[name]) && value.test(data[name])) {
              data[name] = undefined;
            } else {
              data[name] = filterArrayValues(data[name], value);
            }
          } else if (data[name] === value) {
            data[name] = undefined;
          } else if (isArray(data[name])) {
            data[name] = filterArrayValues(data[name], value);
          }
        } else {
          data[name] = undefined;
        }
      } else {
        throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
      }
    };
    URI.hasQuery = function(data, name, value, withinArray) {
      if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            if (!URI.hasQuery(data, key, name[key])) {
              return false;
            }
          }
        }
        return true;
      } else if (typeof name !== 'string') {
        throw new TypeError('URI.hasQuery() accepts an object, string as the name parameter');
      }
      switch (getType(value)) {
        case 'Undefined':
          return name in data;
        case 'Boolean':
          var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
          return value === _booly;
        case 'Function':
          return !!value(data[name], name, data);
        case 'Array':
          if (!isArray(data[name])) {
            return false;
          }
          var op = withinArray ? arrayContains : arraysEqual;
          return op(data[name], value);
        case 'RegExp':
          if (!isArray(data[name])) {
            return Boolean(data[name] && data[name].match(value));
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value);
        case 'Number':
          value = String(value);
        case 'String':
          if (!isArray(data[name])) {
            return data[name] === value;
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value);
        default:
          throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
      }
    };
    URI.commonPath = function(one, two) {
      var length = Math.min(one.length, two.length);
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (one.charAt(pos) !== two.charAt(pos)) {
          pos--;
          break;
        }
      }
      if (pos < 1) {
        return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
      }
      if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
        pos = one.substring(0, pos).lastIndexOf('/');
      }
      return one.substring(0, pos + 1);
    };
    URI.withinString = function(string, callback, options) {
      options || (options = {});
      var _start = options.start || URI.findUri.start;
      var _end = options.end || URI.findUri.end;
      var _trim = options.trim || URI.findUri.trim;
      var _attributeOpen = /[a-z0-9-]=["']?$/i;
      _start.lastIndex = 0;
      while (true) {
        var match = _start.exec(string);
        if (!match) {
          break;
        }
        var start = match.index;
        if (options.ignoreHtml) {
          var attributeOpen = string.slice(Math.max(start - 3, 0), start);
          if (attributeOpen && _attributeOpen.test(attributeOpen)) {
            continue;
          }
        }
        var end = start + string.slice(start).search(_end);
        var slice = string.slice(start, end).replace(_trim, '');
        if (options.ignore && options.ignore.test(slice)) {
          continue;
        }
        end = start + slice.length;
        var result = callback(slice, start, end, string);
        string = string.slice(0, start) + result + string.slice(end);
        _start.lastIndex = start + result.length;
      }
      _start.lastIndex = 0;
      return string;
    };
    URI.ensureValidHostname = function(v) {
      if (v.match(URI.invalid_hostname_characters)) {
        if (!punycode) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
        }
        if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
      }
    };
    URI.noConflict = function(removeAll) {
      if (removeAll) {
        var unconflicted = {URI: this.noConflict()};
        if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
          unconflicted.URITemplate = root.URITemplate.noConflict();
        }
        if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
          unconflicted.IPv6 = root.IPv6.noConflict();
        }
        if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
          unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
        }
        return unconflicted;
      } else if (root.URI === this) {
        root.URI = _URI;
      }
      return this;
    };
    p.build = function(deferBuild) {
      if (deferBuild === true) {
        this._deferred_build = true;
      } else if (deferBuild === undefined || this._deferred_build) {
        this._string = URI.build(this._parts);
        this._deferred_build = false;
      }
      return this;
    };
    p.clone = function() {
      return new URI(this);
    };
    p.valueOf = p.toString = function() {
      return this.build(false)._string;
    };
    function generateSimpleAccessor(_part) {
      return function(v, build) {
        if (v === undefined) {
          return this._parts[_part] || '';
        } else {
          this._parts[_part] = v || null;
          this.build(!build);
          return this;
        }
      };
    }
    function generatePrefixAccessor(_part, _key) {
      return function(v, build) {
        if (v === undefined) {
          return this._parts[_part] || '';
        } else {
          if (v !== null) {
            v = v + '';
            if (v.charAt(0) === _key) {
              v = v.substring(1);
            }
          }
          this._parts[_part] = v;
          this.build(!build);
          return this;
        }
      };
    }
    p.protocol = generateSimpleAccessor('protocol');
    p.username = generateSimpleAccessor('username');
    p.password = generateSimpleAccessor('password');
    p.hostname = generateSimpleAccessor('hostname');
    p.port = generateSimpleAccessor('port');
    p.query = generatePrefixAccessor('query', '?');
    p.fragment = generatePrefixAccessor('fragment', '#');
    p.search = function(v, build) {
      var t = this.query(v, build);
      return typeof t === 'string' && t.length ? ('?' + t) : t;
    };
    p.hash = function(v, build) {
      var t = this.fragment(v, build);
      return typeof t === 'string' && t.length ? ('#' + t) : t;
    };
    p.pathname = function(v, build) {
      if (v === undefined || v === true) {
        var res = this._parts.path || (this._parts.hostname ? '/' : '');
        return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
      } else {
        if (this._parts.urn) {
          this._parts.path = v ? URI.recodeUrnPath(v) : '';
        } else {
          this._parts.path = v ? URI.recodePath(v) : '/';
        }
        this.build(!build);
        return this;
      }
    };
    p.path = p.pathname;
    p.href = function(href, build) {
      var key;
      if (href === undefined) {
        return this.toString();
      }
      this._string = '';
      this._parts = URI._parts();
      var _URI = href instanceof URI;
      var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
      if (href.nodeName) {
        var attribute = URI.getDomAttribute(href);
        href = href[attribute] || '';
        _object = false;
      }
      if (!_URI && _object && href.pathname !== undefined) {
        href = href.toString();
      }
      if (typeof href === 'string' || href instanceof String) {
        this._parts = URI.parse(String(href), this._parts);
      } else if (_URI || _object) {
        var src = _URI ? href._parts : href;
        for (key in src) {
          if (hasOwn.call(this._parts, key)) {
            this._parts[key] = src[key];
          }
        }
      } else {
        throw new TypeError('invalid input');
      }
      this.build(!build);
      return this;
    };
    p.is = function(what) {
      var ip = false;
      var ip4 = false;
      var ip6 = false;
      var name = false;
      var sld = false;
      var idn = false;
      var punycode = false;
      var relative = !this._parts.urn;
      if (this._parts.hostname) {
        relative = false;
        ip4 = URI.ip4_expression.test(this._parts.hostname);
        ip6 = URI.ip6_expression.test(this._parts.hostname);
        ip = ip4 || ip6;
        name = !ip;
        sld = name && SLD && SLD.has(this._parts.hostname);
        idn = name && URI.idn_expression.test(this._parts.hostname);
        punycode = name && URI.punycode_expression.test(this._parts.hostname);
      }
      switch (what.toLowerCase()) {
        case 'relative':
          return relative;
        case 'absolute':
          return !relative;
        case 'domain':
        case 'name':
          return name;
        case 'sld':
          return sld;
        case 'ip':
          return ip;
        case 'ip4':
        case 'ipv4':
        case 'inet4':
          return ip4;
        case 'ip6':
        case 'ipv6':
        case 'inet6':
          return ip6;
        case 'idn':
          return idn;
        case 'url':
          return !this._parts.urn;
        case 'urn':
          return !!this._parts.urn;
        case 'punycode':
          return punycode;
      }
      return null;
    };
    var _protocol = p.protocol;
    var _port = p.port;
    var _hostname = p.hostname;
    p.protocol = function(v, build) {
      if (v !== undefined) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, '');
          if (!v.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
          }
        }
      }
      return _protocol.call(this, v, build);
    };
    p.scheme = p.protocol;
    p.port = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v !== undefined) {
        if (v === 0) {
          v = null;
        }
        if (v) {
          v += '';
          if (v.charAt(0) === ':') {
            v = v.substring(1);
          }
          if (v.match(/[^0-9]/)) {
            throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
          }
        }
      }
      return _port.call(this, v, build);
    };
    p.hostname = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v !== undefined) {
        var x = {};
        var res = URI.parseHost(v, x);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        v = x.hostname;
      }
      return _hostname.call(this, v, build);
    };
    p.host = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        return this._parts.hostname ? URI.buildHost(this._parts) : '';
      } else {
        var res = URI.parseHost(v, this._parts);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p.authority = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
      } else {
        var res = URI.parseAuthority(v, this._parts);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p.userinfo = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        if (!this._parts.username) {
          return '';
        }
        var t = URI.buildUserinfo(this._parts);
        return t.substring(0, t.length - 1);
      } else {
        if (v[v.length - 1] !== '@') {
          v += '@';
        }
        URI.parseUserinfo(v, this._parts);
        this.build(!build);
        return this;
      }
    };
    p.resource = function(v, build) {
      var parts;
      if (v === undefined) {
        return this.path() + this.search() + this.hash();
      }
      parts = URI.parse(v);
      this._parts.path = parts.path;
      this._parts.query = parts.query;
      this._parts.fragment = parts.fragment;
      this.build(!build);
      return this;
    };
    p.subdomain = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var end = this._parts.hostname.length - this.domain().length - 1;
        return this._parts.hostname.substring(0, end) || '';
      } else {
        var e = this._parts.hostname.length - this.domain().length;
        var sub = this._parts.hostname.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(sub));
        if (v && v.charAt(v.length - 1) !== '.') {
          v += '.';
        }
        if (v) {
          URI.ensureValidHostname(v);
        }
        this._parts.hostname = this._parts.hostname.replace(replace, v);
        this.build(!build);
        return this;
      }
    };
    p.domain = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (typeof v === 'boolean') {
        build = v;
        v = undefined;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var t = this._parts.hostname.match(/\./g);
        if (t && t.length < 2) {
          return this._parts.hostname;
        }
        var end = this._parts.hostname.length - this.tld(build).length - 1;
        end = this._parts.hostname.lastIndexOf('.', end - 1) + 1;
        return this._parts.hostname.substring(end) || '';
      } else {
        if (!v) {
          throw new TypeError('cannot set domain empty');
        }
        URI.ensureValidHostname(v);
        if (!this._parts.hostname || this.is('IP')) {
          this._parts.hostname = v;
        } else {
          var replace = new RegExp(escapeRegEx(this.domain()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.tld = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (typeof v === 'boolean') {
        build = v;
        v = undefined;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var pos = this._parts.hostname.lastIndexOf('.');
        var tld = this._parts.hostname.substring(pos + 1);
        if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
          return SLD.get(this._parts.hostname) || tld;
        }
        return tld;
      } else {
        var replace;
        if (!v) {
          throw new TypeError('cannot set TLD empty');
        } else if (v.match(/[^a-zA-Z0-9-]/)) {
          if (SLD && SLD.is(v)) {
            replace = new RegExp(escapeRegEx(this.tld()) + '$');
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          } else {
            throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
          }
        } else if (!this._parts.hostname || this.is('IP')) {
          throw new ReferenceError('cannot set TLD on non-domain host');
        } else {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.directory = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path && !this._parts.hostname) {
          return '';
        }
        if (this._parts.path === '/') {
          return '/';
        }
        var end = this._parts.path.length - this.filename().length - 1;
        var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');
        return v ? URI.decodePath(res) : res;
      } else {
        var e = this._parts.path.length - this.filename().length;
        var directory = this._parts.path.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(directory));
        if (!this.is('relative')) {
          if (!v) {
            v = '/';
          }
          if (v.charAt(0) !== '/') {
            v = '/' + v;
          }
        }
        if (v && v.charAt(v.length - 1) !== '/') {
          v += '/';
        }
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
        this.build(!build);
        return this;
      }
    };
    p.filename = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
          return '';
        }
        var pos = this._parts.path.lastIndexOf('/');
        var res = this._parts.path.substring(pos + 1);
        return v ? URI.decodePathSegment(res) : res;
      } else {
        var mutatedDirectory = false;
        if (v.charAt(0) === '/') {
          v = v.substring(1);
        }
        if (v.match(/\.?\//)) {
          mutatedDirectory = true;
        }
        var replace = new RegExp(escapeRegEx(this.filename()) + '$');
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
        if (mutatedDirectory) {
          this.normalizePath(build);
        } else {
          this.build(!build);
        }
        return this;
      }
    };
    p.suffix = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
          return '';
        }
        var filename = this.filename();
        var pos = filename.lastIndexOf('.');
        var s,
            res;
        if (pos === -1) {
          return '';
        }
        s = filename.substring(pos + 1);
        res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
        return v ? URI.decodePathSegment(res) : res;
      } else {
        if (v.charAt(0) === '.') {
          v = v.substring(1);
        }
        var suffix = this.suffix();
        var replace;
        if (!suffix) {
          if (!v) {
            return this;
          }
          this._parts.path += '.' + URI.recodePath(v);
        } else if (!v) {
          replace = new RegExp(escapeRegEx('.' + suffix) + '$');
        } else {
          replace = new RegExp(escapeRegEx(suffix) + '$');
        }
        if (replace) {
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.segment = function(segment, v, build) {
      var separator = this._parts.urn ? ':' : '/';
      var path = this.path();
      var absolute = path.substring(0, 1) === '/';
      var segments = path.split(separator);
      if (segment !== undefined && typeof segment !== 'number') {
        build = v;
        v = segment;
        segment = undefined;
      }
      if (segment !== undefined && typeof segment !== 'number') {
        throw new Error('Bad segment "' + segment + '", must be 0-based integer');
      }
      if (absolute) {
        segments.shift();
      }
      if (segment < 0) {
        segment = Math.max(segments.length + segment, 0);
      }
      if (v === undefined) {
        return segment === undefined ? segments : segments[segment];
      } else if (segment === null || segments[segment] === undefined) {
        if (isArray(v)) {
          segments = [];
          for (var i = 0,
              l = v.length; i < l; i++) {
            if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
              continue;
            }
            if (segments.length && !segments[segments.length - 1].length) {
              segments.pop();
            }
            segments.push(v[i]);
          }
        } else if (v || typeof v === 'string') {
          if (segments[segments.length - 1] === '') {
            segments[segments.length - 1] = v;
          } else {
            segments.push(v);
          }
        }
      } else {
        if (v) {
          segments[segment] = v;
        } else {
          segments.splice(segment, 1);
        }
      }
      if (absolute) {
        segments.unshift('');
      }
      return this.path(segments.join(separator), build);
    };
    p.segmentCoded = function(segment, v, build) {
      var segments,
          i,
          l;
      if (typeof segment !== 'number') {
        build = v;
        v = segment;
        segment = undefined;
      }
      if (v === undefined) {
        segments = this.segment(segment, v, build);
        if (!isArray(segments)) {
          segments = segments !== undefined ? URI.decode(segments) : undefined;
        } else {
          for (i = 0, l = segments.length; i < l; i++) {
            segments[i] = URI.decode(segments[i]);
          }
        }
        return segments;
      }
      if (!isArray(v)) {
        v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
      } else {
        for (i = 0, l = v.length; i < l; i++) {
          v[i] = URI.encode(v[i]);
        }
      }
      return this.segment(segment, v, build);
    };
    var q = p.query;
    p.query = function(v, build) {
      if (v === true) {
        return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      } else if (typeof v === 'function') {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        var result = v.call(this, data);
        this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else if (v !== undefined && typeof v !== 'string') {
        this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else {
        return q.call(this, v, build);
      }
    };
    p.setQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      if (typeof name === 'string' || name instanceof String) {
        data[name] = value !== undefined ? value : null;
      } else if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            data[key] = name[key];
          }
        }
      } else {
        throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
      }
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.addQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI.addQuery(data, name, value === undefined ? null : value);
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.removeQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI.removeQuery(data, name, value);
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.hasQuery = function(name, value, withinArray) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      return URI.hasQuery(data, name, value, withinArray);
    };
    p.setSearch = p.setQuery;
    p.addSearch = p.addQuery;
    p.removeSearch = p.removeQuery;
    p.hasSearch = p.hasQuery;
    p.normalize = function() {
      if (this._parts.urn) {
        return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      }
      return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
    };
    p.normalizeProtocol = function(build) {
      if (typeof this._parts.protocol === 'string') {
        this._parts.protocol = this._parts.protocol.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p.normalizeHostname = function(build) {
      if (this._parts.hostname) {
        if (this.is('IDN') && punycode) {
          this._parts.hostname = punycode.toASCII(this._parts.hostname);
        } else if (this.is('IPv6') && IPv6) {
          this._parts.hostname = IPv6.best(this._parts.hostname);
        }
        this._parts.hostname = this._parts.hostname.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p.normalizePort = function(build) {
      if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
        this._parts.port = null;
        this.build(!build);
      }
      return this;
    };
    p.normalizePath = function(build) {
      var _path = this._parts.path;
      if (!_path) {
        return this;
      }
      if (this._parts.urn) {
        this._parts.path = URI.recodeUrnPath(this._parts.path);
        this.build(!build);
        return this;
      }
      if (this._parts.path === '/') {
        return this;
      }
      var _was_relative;
      var _leadingParents = '';
      var _parent,
          _pos;
      if (_path.charAt(0) !== '/') {
        _was_relative = true;
        _path = '/' + _path;
      }
      if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
        _path += '/';
      }
      _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, '/').replace(/\/{2,}/g, '/');
      if (_was_relative) {
        _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
        if (_leadingParents) {
          _leadingParents = _leadingParents[0];
        }
      }
      while (true) {
        _parent = _path.indexOf('/..');
        if (_parent === -1) {
          break;
        } else if (_parent === 0) {
          _path = _path.substring(3);
          continue;
        }
        _pos = _path.substring(0, _parent).lastIndexOf('/');
        if (_pos === -1) {
          _pos = _parent;
        }
        _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
      }
      if (_was_relative && this.is('relative')) {
        _path = _leadingParents + _path.substring(1);
      }
      _path = URI.recodePath(_path);
      this._parts.path = _path;
      this.build(!build);
      return this;
    };
    p.normalizePathname = p.normalizePath;
    p.normalizeQuery = function(build) {
      if (typeof this._parts.query === 'string') {
        if (!this._parts.query.length) {
          this._parts.query = null;
        } else {
          this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
        }
        this.build(!build);
      }
      return this;
    };
    p.normalizeFragment = function(build) {
      if (!this._parts.fragment) {
        this._parts.fragment = null;
        this.build(!build);
      }
      return this;
    };
    p.normalizeSearch = p.normalizeQuery;
    p.normalizeHash = p.normalizeFragment;
    p.iso8859 = function() {
      var e = URI.encode;
      var d = URI.decode;
      URI.encode = escape;
      URI.decode = decodeURIComponent;
      try {
        this.normalize();
      } finally {
        URI.encode = e;
        URI.decode = d;
      }
      return this;
    };
    p.unicode = function() {
      var e = URI.encode;
      var d = URI.decode;
      URI.encode = strictEncodeURIComponent;
      URI.decode = unescape;
      try {
        this.normalize();
      } finally {
        URI.encode = e;
        URI.decode = d;
      }
      return this;
    };
    p.readable = function() {
      var uri = this.clone();
      uri.username('').password('').normalize();
      var t = '';
      if (uri._parts.protocol) {
        t += uri._parts.protocol + '://';
      }
      if (uri._parts.hostname) {
        if (uri.is('punycode') && punycode) {
          t += punycode.toUnicode(uri._parts.hostname);
          if (uri._parts.port) {
            t += ':' + uri._parts.port;
          }
        } else {
          t += uri.host();
        }
      }
      if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
        t += '/';
      }
      t += uri.path(true);
      if (uri._parts.query) {
        var q = '';
        for (var i = 0,
            qp = uri._parts.query.split('&'),
            l = qp.length; i < l; i++) {
          var kv = (qp[i] || '').split('=');
          q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, '%26');
          if (kv[1] !== undefined) {
            q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, '%26');
          }
        }
        t += '?' + q.substring(1);
      }
      t += URI.decodeQuery(uri.hash(), true);
      return t;
    };
    p.absoluteTo = function(base) {
      var resolved = this.clone();
      var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
      var basedir,
          i,
          p;
      if (this._parts.urn) {
        throw new Error('URNs do not have any generally defined hierarchical components');
      }
      if (!(base instanceof URI)) {
        base = new URI(base);
      }
      if (!resolved._parts.protocol) {
        resolved._parts.protocol = base._parts.protocol;
      }
      if (this._parts.hostname) {
        return resolved;
      }
      for (i = 0; (p = properties[i]); i++) {
        resolved._parts[p] = base._parts[p];
      }
      if (!resolved._parts.path) {
        resolved._parts.path = base._parts.path;
        if (!resolved._parts.query) {
          resolved._parts.query = base._parts.query;
        }
      } else if (resolved._parts.path.substring(-2) === '..') {
        resolved._parts.path += '/';
      }
      if (resolved.path().charAt(0) !== '/') {
        basedir = base.directory();
        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
        resolved.normalizePath();
      }
      resolved.build();
      return resolved;
    };
    p.relativeTo = function(base) {
      var relative = this.clone().normalize();
      var relativeParts,
          baseParts,
          common,
          relativePath,
          basePath;
      if (relative._parts.urn) {
        throw new Error('URNs do not have any generally defined hierarchical components');
      }
      base = new URI(base).normalize();
      relativeParts = relative._parts;
      baseParts = base._parts;
      relativePath = relative.path();
      basePath = base.path();
      if (relativePath.charAt(0) !== '/') {
        throw new Error('URI is already relative');
      }
      if (basePath.charAt(0) !== '/') {
        throw new Error('Cannot calculate a URI relative to another relative URI');
      }
      if (relativeParts.protocol === baseParts.protocol) {
        relativeParts.protocol = null;
      }
      if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
        return relative.build();
      }
      if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
        return relative.build();
      }
      if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
        relativeParts.hostname = null;
        relativeParts.port = null;
      } else {
        return relative.build();
      }
      if (relativePath === basePath) {
        relativeParts.path = '';
        return relative.build();
      }
      common = URI.commonPath(relativePath, basePath);
      if (!common) {
        return relative.build();
      }
      var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, '').replace(/.*?\//g, '../');
      relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';
      return relative.build();
    };
    p.equals = function(uri) {
      var one = this.clone();
      var two = new URI(uri);
      var one_map = {};
      var two_map = {};
      var checked = {};
      var one_query,
          two_query,
          key;
      one.normalize();
      two.normalize();
      if (one.toString() === two.toString()) {
        return true;
      }
      one_query = one.query();
      two_query = two.query();
      one.query('');
      two.query('');
      if (one.toString() !== two.toString()) {
        return false;
      }
      if (one_query.length !== two_query.length) {
        return false;
      }
      one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
      two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
      for (key in one_map) {
        if (hasOwn.call(one_map, key)) {
          if (!isArray(one_map[key])) {
            if (one_map[key] !== two_map[key]) {
              return false;
            }
          } else if (!arraysEqual(one_map[key], two_map[key])) {
            return false;
          }
          checked[key] = true;
        }
      }
      for (key in two_map) {
        if (hasOwn.call(two_map, key)) {
          if (!checked[key]) {
            return false;
          }
        }
      }
      return true;
    };
    p.duplicateQueryParameters = function(v) {
      this._parts.duplicateQueryParameters = !!v;
      return this;
    };
    p.escapeQuerySpace = function(v) {
      this._parts.escapeQuerySpace = !!v;
      return this;
    };
    return URI;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:whatwg-fetch@0.9.0", ["npm:whatwg-fetch@0.9.0/fetch"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:whatwg-fetch@0.9.0/fetch");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1/index", ["npm:process@0.10.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1");
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/CSSPropertyOperations", ["npm:react@0.14.0-beta3/lib/CSSProperty", "npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:fbjs@0.1.0-alpha.4/lib/camelizeStyleName", "npm:react@0.14.0-beta3/lib/dangerousStyleValue", "npm:fbjs@0.1.0-alpha.4/lib/hyphenateStyleName", "npm:react@0.14.0-beta3/lib/memoizeStringOnly", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CSSProperty = require("npm:react@0.14.0-beta3/lib/CSSProperty");
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var camelizeStyleName = require("npm:fbjs@0.1.0-alpha.4/lib/camelizeStyleName");
    var dangerousStyleValue = require("npm:react@0.14.0-beta3/lib/dangerousStyleValue");
    var hyphenateStyleName = require("npm:fbjs@0.1.0-alpha.4/lib/hyphenateStyleName");
    var memoizeStringOnly = require("npm:react@0.14.0-beta3/lib/memoizeStringOnly");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var processStyleName = memoizeStringOnly(function(styleName) {
      return hyphenateStyleName(styleName);
    });
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if (process.env.NODE_ENV !== 'production') {
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
      var badStyleValueWithSemicolonPattern = /;\s*$/;
      var warnedStyleNames = {};
      var warnedStyleValues = {};
      var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return ;
        }
        warnedStyleNames[name] = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
      };
      var warnBadVendoredStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return ;
        }
        warnedStyleNames[name] = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
      };
      var warnStyleValueWithSemicolon = function(name, value) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
          return ;
        }
        warnedStyleValues[value] = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
      };
      var warnValidStyle = function(name, value) {
        if (name.indexOf('-') > -1) {
          warnHyphenatedStyleName(name);
        } else if (badVendoredStyleNamePattern.test(name)) {
          warnBadVendoredStyleName(name);
        } else if (badStyleValueWithSemicolonPattern.test(value)) {
          warnStyleValueWithSemicolon(name, value);
        }
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function(styles) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var styleValue = styles[styleName];
          if (process.env.NODE_ENV !== 'production') {
            warnValidStyle(styleName, styleValue);
          }
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function(node, styles) {
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if (process.env.NODE_ENV !== 'production') {
            warnValidStyle(styleName, styles[styleName]);
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName]);
          if (styleName === 'float') {
            styleName = styleFloatAccessor;
          }
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/createNodesFromMarkup", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:fbjs@0.1.0-alpha.4/lib/createArrayFromMixed", "npm:fbjs@0.1.0-alpha.4/lib/getMarkupWrap", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var createArrayFromMixed = require("npm:fbjs@0.1.0-alpha.4/lib/createArrayFromMixed");
    var getMarkupWrap = require("npm:fbjs@0.1.0-alpha.4/lib/getMarkupWrap");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
        createArrayFromMixed(scripts).forEach(handleScript);
      }
      var nodes = createArrayFromMixed(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:react@0.14.0-beta3/lib/EventPluginHub", "npm:react@0.14.0-beta3/lib/EventPluginRegistry", "npm:react@0.14.0-beta3/lib/ReactEventEmitterMixin", "npm:react@0.14.0-beta3/lib/ViewportMetrics", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:react@0.14.0-beta3/lib/isEventSupported", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
    var EventPluginHub = require("npm:react@0.14.0-beta3/lib/EventPluginHub");
    var EventPluginRegistry = require("npm:react@0.14.0-beta3/lib/EventPluginRegistry");
    var ReactEventEmitterMixin = require("npm:react@0.14.0-beta3/lib/ReactEventEmitterMixin");
    var ViewportMetrics = require("npm:react@0.14.0-beta3/lib/ViewportMetrics");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var isEventSupported = require("npm:react@0.14.0-beta3/lib/isEventSupported");
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topAbort: 'abort',
      topBlur: 'blur',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPause: 'pause',
      topPaste: 'paste',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topSeeking: 'seeking',
      topSeeked: 'seeked',
      topScroll: 'scroll',
      topSelectionChange: 'selectionchange',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTextInput: 'textInput',
      topTimeUpdate: 'timeupdate',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting',
      topWheel: 'wheel'
    };
    var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: {injectReactEventListener: function(ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        }},
      setEnabled: function(enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function() {
        return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
      },
      listenTo: function(registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        var topLevelTypes = EventConstants.topLevelTypes;
        for (var i = 0; i < dependencies.length; i++) {
          var dependency = dependencies[i];
          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
            if (dependency === topLevelTypes.topWheel) {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === topLevelTypes.topScroll) {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
              }
              isListening[topLevelTypes.topBlur] = true;
              isListening[topLevelTypes.topFocus] = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      ensureScrollValueMonitoring: function() {
        if (!isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      },
      eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
      registrationNameModules: EventPluginHub.registrationNameModules,
      putListener: EventPluginHub.putListener,
      getListener: EventPluginHub.getListener,
      deleteListener: EventPluginHub.deleteListener,
      deleteAllListeners: EventPluginHub.deleteAllListeners
    });
    module.exports = ReactBrowserEventEmitter;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactReconciler", ["npm:react@0.14.0-beta3/lib/ReactRef"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactRef = require("npm:react@0.14.0-beta3/lib/ReactRef");
  function attachRefs() {
    ReactRef.attachRefs(this, this._currentElement);
  }
  var ReactReconciler = {
    mountComponent: function(internalInstance, rootID, transaction, context) {
      var markup = internalInstance.mountComponent(rootID, transaction, context);
      if (internalInstance._currentElement.ref != null) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }
      return markup;
    },
    unmountComponent: function(internalInstance) {
      ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
      internalInstance.unmountComponent();
    },
    receiveComponent: function(internalInstance, nextElement, transaction, context) {
      var prevElement = internalInstance._currentElement;
      if (nextElement === prevElement && nextElement._owner != null) {
        return ;
      }
      var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
      if (refsChanged) {
        ReactRef.detachRefs(internalInstance, prevElement);
      }
      internalInstance.receiveComponent(nextElement, transaction, context);
      if (refsChanged) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }
    },
    performUpdateIfNecessary: function(internalInstance, transaction) {
      internalInstance.performUpdateIfNecessary(transaction);
    }
  };
  module.exports = ReactReconciler;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactUpdates", ["npm:react@0.14.0-beta3/lib/CallbackQueue", "npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:react@0.14.0-beta3/lib/ReactReconciler", "npm:react@0.14.0-beta3/lib/Transaction", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CallbackQueue = require("npm:react@0.14.0-beta3/lib/CallbackQueue");
    var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
    var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
    var ReactReconciler = require("npm:react@0.14.0-beta3/lib/ReactReconciler");
    var Transaction = require("npm:react@0.14.0-beta3/lib/Transaction");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var dirtyComponents = [];
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
    }
    var NESTED_UPDATES = {
      initialize: function() {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function() {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function() {
        this.callbackQueue.reset();
      },
      close: function() {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled();
    }
    assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
      getTransactionWrappers: function() {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function() {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function(method, scope, a) {
        return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b, c, d, e) {
      ensureInjected();
      batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
    }
    function mountOrderComparator(c1, c2) {
      return c1._mountOrder - c2._mountOrder;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
      dirtyComponents.sort(mountOrderComparator);
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        var callbacks = component._pendingCallbacks;
        component._pendingCallbacks = null;
        ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
        if (callbacks) {
          for (var j = 0; j < callbacks.length; j++) {
            transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
          }
        }
      }
    }
    var flushBatchedUpdates = function() {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    };
    flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
    function enqueueUpdate(component) {
      ensureInjected();
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component);
        return ;
      }
      dirtyComponents.push(component);
    }
    function asap(callback, context) {
      !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function(ReconcileTransaction) {
        !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function(_batchingStrategy) {
        !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
        !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
        !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/containsNode", ["npm:fbjs@0.1.0-alpha.4/lib/isTextNode"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var isTextNode = require("npm:fbjs@0.1.0-alpha.4/lib/isTextNode");
  function containsNode(_x, _x2) {
    var _again = true;
    _function: while (_again) {
      var outerNode = _x,
          innerNode = _x2;
      _again = false;
      if (!outerNode || !innerNode) {
        return false;
      } else if (outerNode === innerNode) {
        return true;
      } else if (isTextNode(outerNode)) {
        return false;
      } else if (isTextNode(innerNode)) {
        _x = outerNode;
        _x2 = innerNode.parentNode;
        _again = true;
        continue _function;
      } else if (outerNode.contains) {
        return outerNode.contains(innerNode);
      } else if (outerNode.compareDocumentPosition) {
        return !!(outerNode.compareDocumentPosition(innerNode) & 16);
      } else {
        return false;
      }
    }
  }
  module.exports = containsNode;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/instantiateReactComponent", ["npm:react@0.14.0-beta3/lib/ReactCompositeComponent", "npm:react@0.14.0-beta3/lib/ReactEmptyComponent", "npm:react@0.14.0-beta3/lib/ReactNativeComponent", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCompositeComponent = require("npm:react@0.14.0-beta3/lib/ReactCompositeComponent");
    var ReactEmptyComponent = require("npm:react@0.14.0-beta3/lib/ReactEmptyComponent");
    var ReactNativeComponent = require("npm:react@0.14.0-beta3/lib/ReactNativeComponent");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var ReactCompositeComponentWrapper = function() {};
    assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {_instantiateReactComponent: instantiateReactComponent});
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    function isInternalComponentType(type) {
      return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
    }
    function instantiateReactComponent(node) {
      var instance;
      if (node === null || node === false) {
        node = ReactEmptyComponent.emptyElement;
      }
      if (typeof node === 'object') {
        var element = node;
        !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
        if (typeof element.type === 'string') {
          instance = ReactNativeComponent.createInternalComponent(element);
        } else if (isInternalComponentType(element.type)) {
          instance = new element.type(element);
        } else {
          instance = new ReactCompositeComponentWrapper();
        }
      } else if (typeof node === 'string' || typeof node === 'number') {
        instance = ReactNativeComponent.createInstanceForText(node);
      } else {
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
      }
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
      }
      instance.construct(node);
      instance._mountIndex = 0;
      instance._mountImage = null;
      if (process.env.NODE_ENV !== 'production') {
        instance._isOwnerNecessary = false;
        instance._warnedAboutRefsInRender = false;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (Object.preventExtensions) {
          Object.preventExtensions(instance);
        }
      }
      return instance;
    }
    module.exports = instantiateReactComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/LinkedValueUtils", ["npm:react@0.14.0-beta3/lib/ReactPropTypes", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocations", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactPropTypes = require("npm:react@0.14.0-beta3/lib/ReactPropTypes");
    var ReactPropTypeLocations = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocations");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var hasReadOnlyValue = {
      'button': true,
      'checkbox': true,
      'image': true,
      'hidden': true,
      'radio': true,
      'reset': true,
      'submit': true
    };
    function _assertSingleLink(inputProps) {
      !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
    }
    function _assertValueLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
    }
    function _assertCheckedLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
    }
    var propTypes = {
      value: function(props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      checked: function(props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      onChange: ReactPropTypes.func
    };
    var loggedTypeFailures = {};
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var LinkedValueUtils = {
      checkPropTypes: function(tagName, props, owner) {
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum(owner);
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
          }
        }
      },
      getValue: function(inputProps) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.value;
        }
        return inputProps.value;
      },
      getChecked: function(inputProps) {
        if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.value;
        }
        return inputProps.checked;
      },
      executeOnChange: function(inputProps, event) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.requestChange(event.target.value);
        } else if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.requestChange(event.target.checked);
        } else if (inputProps.onChange) {
          return inputProps.onChange.call(undefined, event);
        }
      }
    };
    module.exports = LinkedValueUtils;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMOption", ["npm:react@0.14.0-beta3/lib/ReactChildren", "npm:react@0.14.0-beta3/lib/ReactDOMSelect", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactChildren = require("npm:react@0.14.0-beta3/lib/ReactChildren");
    var ReactDOMSelect = require("npm:react@0.14.0-beta3/lib/ReactDOMSelect");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var valueContextKey = ReactDOMSelect.valueContextKey;
    var ReactDOMOption = {
      mountWrapper: function(inst, props, context) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
        }
        var selectValue = context[valueContextKey];
        var selected = null;
        if (selectValue != null) {
          selected = false;
          if (Array.isArray(selectValue)) {
            for (var i = 0; i < selectValue.length; i++) {
              if ('' + selectValue[i] === '' + props.value) {
                selected = true;
                break;
              }
            }
          } else {
            selected = '' + selectValue === '' + props.value;
          }
        }
        inst._wrapperState = {selected: selected};
      },
      getNativeProps: function(inst, props, context) {
        var nativeProps = assign({
          selected: undefined,
          children: undefined
        }, props);
        if (inst._wrapperState.selected != null) {
          nativeProps.selected = inst._wrapperState.selected;
        }
        var content = '';
        ReactChildren.forEach(props.children, function(child) {
          if (child == null) {
            return ;
          }
          if (typeof child === 'string' || typeof child === 'number') {
            content += child;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
          }
        });
        nativeProps.children = content;
        return nativeProps;
      }
    };
    module.exports = ReactDOMOption;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactMultiChild", ["npm:react@0.14.0-beta3/lib/ReactComponentEnvironment", "npm:react@0.14.0-beta3/lib/ReactMultiChildUpdateTypes", "npm:react@0.14.0-beta3/lib/ReactReconciler", "npm:react@0.14.0-beta3/lib/ReactChildReconciler", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponentEnvironment = require("npm:react@0.14.0-beta3/lib/ReactComponentEnvironment");
    var ReactMultiChildUpdateTypes = require("npm:react@0.14.0-beta3/lib/ReactMultiChildUpdateTypes");
    var ReactReconciler = require("npm:react@0.14.0-beta3/lib/ReactReconciler");
    var ReactChildReconciler = require("npm:react@0.14.0-beta3/lib/ReactChildReconciler");
    var updateDepth = 0;
    var updateQueue = [];
    var markupQueue = [];
    function enqueueInsertMarkup(parentID, markup, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
        markupIndex: markupQueue.push(markup) - 1,
        content: null,
        fromIndex: null,
        toIndex: toIndex
      });
    }
    function enqueueMove(parentID, fromIndex, toIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
        markupIndex: null,
        content: null,
        fromIndex: fromIndex,
        toIndex: toIndex
      });
    }
    function enqueueRemove(parentID, fromIndex) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.REMOVE_NODE,
        markupIndex: null,
        content: null,
        fromIndex: fromIndex,
        toIndex: null
      });
    }
    function enqueueSetMarkup(parentID, markup) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.SET_MARKUP,
        markupIndex: null,
        content: markup,
        fromIndex: null,
        toIndex: null
      });
    }
    function enqueueTextContent(parentID, textContent) {
      updateQueue.push({
        parentID: parentID,
        parentNode: null,
        type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
        markupIndex: null,
        content: textContent,
        fromIndex: null,
        toIndex: null
      });
    }
    function processQueue() {
      if (updateQueue.length) {
        ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
        clearQueue();
      }
    }
    function clearQueue() {
      updateQueue.length = 0;
      markupQueue.length = 0;
    }
    var ReactMultiChild = {Mixin: {
        mountChildren: function(nestedChildren, transaction, context) {
          var children = ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          this._renderedChildren = children;
          var mountImages = [];
          var index = 0;
          for (var name in children) {
            if (children.hasOwnProperty(name)) {
              var child = children[name];
              var rootID = this._rootNodeID + name;
              var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
              child._mountIndex = index;
              mountImages.push(mountImage);
              index++;
            }
          }
          return mountImages;
        },
        updateTextContent: function(nextContent) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            ReactChildReconciler.unmountChildren(prevChildren);
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChild(prevChildren[name]);
              }
            }
            this.setTextContent(nextContent);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        updateMarkup: function(nextMarkup) {
          updateDepth++;
          var errorThrown = true;
          try {
            var prevChildren = this._renderedChildren;
            ReactChildReconciler.unmountChildren(prevChildren);
            for (var name in prevChildren) {
              if (prevChildren.hasOwnProperty(name)) {
                this._unmountChildByName(prevChildren[name], name);
              }
            }
            this.setMarkup(nextMarkup);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        updateChildren: function(nextNestedChildrenElements, transaction, context) {
          updateDepth++;
          var errorThrown = true;
          try {
            this._updateChildren(nextNestedChildrenElements, transaction, context);
            errorThrown = false;
          } finally {
            updateDepth--;
            if (!updateDepth) {
              if (errorThrown) {
                clearQueue();
              } else {
                processQueue();
              }
            }
          }
        },
        _updateChildren: function(nextNestedChildrenElements, transaction, context) {
          var prevChildren = this._renderedChildren;
          var nextChildren = ReactChildReconciler.updateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
          this._renderedChildren = nextChildren;
          if (!nextChildren && !prevChildren) {
            return ;
          }
          var name;
          var lastIndex = 0;
          var nextIndex = 0;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var nextChild = nextChildren[name];
            if (prevChild === nextChild) {
              this.moveChild(prevChild, nextIndex, lastIndex);
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
                this._unmountChild(prevChild);
              }
              this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
            }
            nextIndex++;
          }
          for (name in prevChildren) {
            if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
              this._unmountChild(prevChildren[name]);
            }
          }
        },
        unmountChildren: function() {
          var renderedChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(renderedChildren);
          this._renderedChildren = null;
        },
        moveChild: function(child, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
          }
        },
        createChild: function(child, mountImage) {
          enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
        },
        removeChild: function(child) {
          enqueueRemove(this._rootNodeID, child._mountIndex);
        },
        setTextContent: function(textContent) {
          enqueueTextContent(this._rootNodeID, textContent);
        },
        setMarkup: function(markup) {
          enqueueSetMarkup(this._rootNodeID, markup);
        },
        _mountChildByNameAtIndex: function(child, name, index, transaction, context) {
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index;
          this.createChild(child, mountImage);
        },
        _unmountChild: function(child) {
          this.removeChild(child);
          child._mountIndex = null;
        }
      }};
    module.exports = ReactMultiChild;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/BeforeInputEventPlugin", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:react@0.14.0-beta3/lib/EventPropagators", "npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:react@0.14.0-beta3/lib/FallbackCompositionState", "npm:react@0.14.0-beta3/lib/SyntheticCompositionEvent", "npm:react@0.14.0-beta3/lib/SyntheticInputEvent", "npm:fbjs@0.1.0-alpha.4/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
  var EventPropagators = require("npm:react@0.14.0-beta3/lib/EventPropagators");
  var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
  var FallbackCompositionState = require("npm:react@0.14.0-beta3/lib/FallbackCompositionState");
  var SyntheticCompositionEvent = require("npm:react@0.14.0-beta3/lib/SyntheticCompositionEvent");
  var SyntheticInputEvent = require("npm:react@0.14.0-beta3/lib/SyntheticInputEvent");
  var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }
  var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
  var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
  function isPresto() {
    var opera = window.opera;
    return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var topLevelTypes = EventConstants.topLevelTypes;
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: keyOf({onBeforeInput: null}),
        captured: keyOf({onBeforeInputCapture: null})
      },
      dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionEnd: null}),
        captured: keyOf({onCompositionEndCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionStart: null}),
        captured: keyOf({onCompositionStartCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: keyOf({onCompositionUpdate: null}),
        captured: keyOf({onCompositionUpdateCapture: null})
      },
      dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
    }
  };
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
  }
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionStart:
        return eventTypes.compositionStart;
      case topLevelTypes.topCompositionEnd:
        return eventTypes.compositionEnd;
      case topLevelTypes.topCompositionUpdate:
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
  }
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topKeyUp:
        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
      case topLevelTypes.topKeyDown:
        return nativeEvent.keyCode !== START_KEYCODE;
      case topLevelTypes.topKeyPress:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topBlur:
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }
  var currentComposition = null;
  function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var eventType;
    var fallbackData;
    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }
    if (!eventType) {
      return null;
    }
    if (useFallbackCompositionData) {
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          fallbackData = currentComposition.getData();
        }
      }
    }
    var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
    if (fallbackData) {
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case topLevelTypes.topCompositionEnd:
        return getDataFromCustomEvent(nativeEvent);
      case topLevelTypes.topKeyPress:
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case topLevelTypes.topTextInput:
        var chars = nativeEvent.data;
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }
        return chars;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    if (currentComposition) {
      if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = currentComposition.getData();
        FallbackCompositionState.release(currentComposition);
        currentComposition = null;
        return chars;
      }
      return null;
    }
    switch (topLevelType) {
      case topLevelTypes.topPaste:
        return null;
      case topLevelTypes.topKeyPress:
        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
          return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case topLevelTypes.topCompositionEnd:
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var chars;
    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }
    if (!chars) {
      return null;
    }
    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
    event.data = chars;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
    }
  };
  module.exports = BeforeInputEventPlugin;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SyntheticMouseEvent", ["npm:react@0.14.0-beta3/lib/SyntheticUIEvent", "npm:react@0.14.0-beta3/lib/ViewportMetrics", "npm:react@0.14.0-beta3/lib/getEventModifierState"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var SyntheticUIEvent = require("npm:react@0.14.0-beta3/lib/SyntheticUIEvent");
  var ViewportMetrics = require("npm:react@0.14.0-beta3/lib/ViewportMetrics");
  var getEventModifierState = require("npm:react@0.14.0-beta3/lib/getEventModifierState");
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function(event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function(event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function(event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function(event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactClass", ["npm:react@0.14.0-beta3/lib/ReactComponent", "npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactErrorUtils", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocations", "npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames", "npm:react@0.14.0-beta3/lib/ReactNoopUpdateQueue", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/emptyObject", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/keyMirror", "npm:fbjs@0.1.0-alpha.4/lib/keyOf", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactComponent = require("npm:react@0.14.0-beta3/lib/ReactComponent");
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactErrorUtils = require("npm:react@0.14.0-beta3/lib/ReactErrorUtils");
    var ReactPropTypeLocations = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocations");
    var ReactPropTypeLocationNames = require("npm:react@0.14.0-beta3/lib/ReactPropTypeLocationNames");
    var ReactNoopUpdateQueue = require("npm:react@0.14.0-beta3/lib/ReactNoopUpdateQueue");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var emptyObject = require("npm:fbjs@0.1.0-alpha.4/lib/emptyObject");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var keyMirror = require("npm:fbjs@0.1.0-alpha.4/lib/keyMirror");
    var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var MIXINS_KEY = keyOf({mixins: null});
    var SpecPolicy = keyMirror({
      DEFINE_ONCE: null,
      DEFINE_MANY: null,
      OVERRIDE_BASE: null,
      DEFINE_MANY_MERGED: null
    });
    var injectedMixins = [];
    var warnedSetProps = false;
    function warnSetProps() {
      if (!warnedSetProps) {
        warnedSetProps = true;
        process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call React.render again at the top level.') : undefined;
      }
    }
    var ReactClassInterface = {
      mixins: SpecPolicy.DEFINE_MANY,
      statics: SpecPolicy.DEFINE_MANY,
      propTypes: SpecPolicy.DEFINE_MANY,
      contextTypes: SpecPolicy.DEFINE_MANY,
      childContextTypes: SpecPolicy.DEFINE_MANY,
      getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
      getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
      getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
      render: SpecPolicy.DEFINE_ONCE,
      componentWillMount: SpecPolicy.DEFINE_MANY,
      componentDidMount: SpecPolicy.DEFINE_MANY,
      componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
      shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
      componentWillUpdate: SpecPolicy.DEFINE_MANY,
      componentDidUpdate: SpecPolicy.DEFINE_MANY,
      componentWillUnmount: SpecPolicy.DEFINE_MANY,
      updateComponent: SpecPolicy.OVERRIDE_BASE
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
        }
        Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
      },
      contextTypes: function(Constructor, contextTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
        }
        Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
      },
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        if (process.env.NODE_ENV !== 'production') {
          validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
        }
        Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      }
    };
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
        }
      }
    }
    function validateMethodOverride(proto, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
      if (ReactClassMixin.hasOwnProperty(name)) {
        !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
      }
      if (proto.hasOwnProperty(name)) {
        !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
      }
    }
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        return ;
      }
      !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
      !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
      var proto = Constructor.prototype;
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }
      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        if (name === MIXINS_KEY) {
          continue;
        }
        var property = spec[name];
        validateMethodOverride(proto, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isAlreadyDefined = proto.hasOwnProperty(name);
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined;
          if (shouldAutoBind) {
            if (!proto.__reactAutoBindMap) {
              proto.__reactAutoBindMap = {};
            }
            proto.__reactAutoBindMap[name] = property;
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];
              !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
              if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
              if (process.env.NODE_ENV !== 'production') {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return ;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }
        var isReserved = (name in RESERVED_SPEC_KEYS);
        !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
        var isInherited = (name in Constructor);
        !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
        Constructor[name] = property;
      }
    }
    function mergeIntoWithNoDuplicateKeys(one, two) {
      !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
          one[key] = two[key];
        }
      }
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);
      if (process.env.NODE_ENV !== 'production') {
        boundMethod.__reactBoundContext = component;
        boundMethod.__reactBoundMethod = method;
        boundMethod.__reactBoundArguments = null;
        var componentName = component.constructor.displayName;
        var _bind = boundMethod.bind;
        boundMethod.bind = function(newThis) {
          for (var _len = arguments.length,
              args = Array(_len > 1 ? _len - 1 : 0),
              _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (newThis !== component && newThis !== null) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
          } else if (!args.length) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
            return boundMethod;
          }
          var reboundMethod = _bind.apply(boundMethod, arguments);
          reboundMethod.__reactBoundContext = component;
          reboundMethod.__reactBoundMethod = method;
          reboundMethod.__reactBoundArguments = args;
          return reboundMethod;
        };
      }
      return boundMethod;
    }
    function bindAutoBindMethods(component) {
      for (var autoBindKey in component.__reactAutoBindMap) {
        if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
          var method = component.__reactAutoBindMap[autoBindKey];
          component[autoBindKey] = bindAutoBindMethod(component, ReactErrorUtils.guard(method, component.constructor.displayName + '.' + autoBindKey));
        }
      }
    }
    var ReactClassMixin = {
      replaceState: function(newState, callback) {
        this.updater.enqueueReplaceState(this, newState);
        if (callback) {
          this.updater.enqueueCallback(this, callback);
        }
      },
      isMounted: function() {
        return this.updater.isMounted(this);
      },
      setProps: function(partialProps, callback) {
        if (process.env.NODE_ENV !== 'production') {
          warnSetProps();
        }
        this.updater.enqueueSetProps(this, partialProps);
        if (callback) {
          this.updater.enqueueCallback(this, callback);
        }
      },
      replaceProps: function(newProps, callback) {
        if (process.env.NODE_ENV !== 'production') {
          warnSetProps();
        }
        this.updater.enqueueReplaceProps(this, newProps);
        if (callback) {
          this.updater.enqueueCallback(this, callback);
        }
      }
    };
    var ReactClassComponent = function() {};
    assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
    var ReactClass = {
      createClass: function(spec) {
        var Constructor = function(props, context, updater) {
          if (process.env.NODE_ENV !== 'production') {
            process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
          }
          if (this.__reactAutoBindMap) {
            bindAutoBindMethods(this);
          }
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
          this.state = null;
          var initialState = this.getInitialState ? this.getInitialState() : null;
          if (process.env.NODE_ENV !== 'production') {
            if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
              initialState = null;
            }
          }
          !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
          this.state = initialState;
        };
        Constructor.prototype = new ReactClassComponent();
        Constructor.prototype.constructor = Constructor;
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        if (process.env.NODE_ENV !== 'production') {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps.isReactClassApproved = {};
          }
          if (Constructor.prototype.getInitialState) {
            Constructor.prototype.getInitialState.isReactClassApproved = {};
          }
        }
        !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
          process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
        }
        for (var methodName in ReactClassInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        return Constructor;
      },
      injection: {injectMixin: function(mixin) {
          injectedMixins.push(mixin);
        }}
    };
    module.exports = ReactClass;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactInputSelection", ["npm:react@0.14.0-beta3/lib/ReactDOMSelection", "npm:fbjs@0.1.0-alpha.4/lib/containsNode", "npm:fbjs@0.1.0-alpha.4/lib/focusNode", "npm:fbjs@0.1.0-alpha.4/lib/getActiveElement"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactDOMSelection = require("npm:react@0.14.0-beta3/lib/ReactDOMSelection");
  var containsNode = require("npm:fbjs@0.1.0-alpha.4/lib/containsNode");
  var focusNode = require("npm:fbjs@0.1.0-alpha.4/lib/focusNode");
  var getActiveElement = require("npm:fbjs@0.1.0-alpha.4/lib/getActiveElement");
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function() {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function(priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function(input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function(input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (typeof end === 'undefined') {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/SimpleEventPlugin", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:fbjs@0.1.0-alpha.4/lib/EventListener", "npm:react@0.14.0-beta3/lib/EventPluginUtils", "npm:react@0.14.0-beta3/lib/EventPropagators", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/SyntheticClipboardEvent", "npm:react@0.14.0-beta3/lib/SyntheticEvent", "npm:react@0.14.0-beta3/lib/SyntheticFocusEvent", "npm:react@0.14.0-beta3/lib/SyntheticKeyboardEvent", "npm:react@0.14.0-beta3/lib/SyntheticMouseEvent", "npm:react@0.14.0-beta3/lib/SyntheticDragEvent", "npm:react@0.14.0-beta3/lib/SyntheticTouchEvent", "npm:react@0.14.0-beta3/lib/SyntheticUIEvent", "npm:react@0.14.0-beta3/lib/SyntheticWheelEvent", "npm:fbjs@0.1.0-alpha.4/lib/emptyFunction", "npm:react@0.14.0-beta3/lib/getEventCharCode", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/keyOf", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
    var EventListener = require("npm:fbjs@0.1.0-alpha.4/lib/EventListener");
    var EventPluginUtils = require("npm:react@0.14.0-beta3/lib/EventPluginUtils");
    var EventPropagators = require("npm:react@0.14.0-beta3/lib/EventPropagators");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var SyntheticClipboardEvent = require("npm:react@0.14.0-beta3/lib/SyntheticClipboardEvent");
    var SyntheticEvent = require("npm:react@0.14.0-beta3/lib/SyntheticEvent");
    var SyntheticFocusEvent = require("npm:react@0.14.0-beta3/lib/SyntheticFocusEvent");
    var SyntheticKeyboardEvent = require("npm:react@0.14.0-beta3/lib/SyntheticKeyboardEvent");
    var SyntheticMouseEvent = require("npm:react@0.14.0-beta3/lib/SyntheticMouseEvent");
    var SyntheticDragEvent = require("npm:react@0.14.0-beta3/lib/SyntheticDragEvent");
    var SyntheticTouchEvent = require("npm:react@0.14.0-beta3/lib/SyntheticTouchEvent");
    var SyntheticUIEvent = require("npm:react@0.14.0-beta3/lib/SyntheticUIEvent");
    var SyntheticWheelEvent = require("npm:react@0.14.0-beta3/lib/SyntheticWheelEvent");
    var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
    var getEventCharCode = require("npm:react@0.14.0-beta3/lib/getEventCharCode");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var topLevelTypes = EventConstants.topLevelTypes;
    var eventTypes = {
      abort: {phasedRegistrationNames: {
          bubbled: keyOf({onAbort: true}),
          captured: keyOf({onAbortCapture: true})
        }},
      blur: {phasedRegistrationNames: {
          bubbled: keyOf({onBlur: true}),
          captured: keyOf({onBlurCapture: true})
        }},
      canPlay: {phasedRegistrationNames: {
          bubbled: keyOf({onCanPlay: true}),
          captured: keyOf({onCanPlayCapture: true})
        }},
      canPlayThrough: {phasedRegistrationNames: {
          bubbled: keyOf({onCanPlayThrough: true}),
          captured: keyOf({onCanPlayThroughCapture: true})
        }},
      click: {phasedRegistrationNames: {
          bubbled: keyOf({onClick: true}),
          captured: keyOf({onClickCapture: true})
        }},
      contextMenu: {phasedRegistrationNames: {
          bubbled: keyOf({onContextMenu: true}),
          captured: keyOf({onContextMenuCapture: true})
        }},
      copy: {phasedRegistrationNames: {
          bubbled: keyOf({onCopy: true}),
          captured: keyOf({onCopyCapture: true})
        }},
      cut: {phasedRegistrationNames: {
          bubbled: keyOf({onCut: true}),
          captured: keyOf({onCutCapture: true})
        }},
      doubleClick: {phasedRegistrationNames: {
          bubbled: keyOf({onDoubleClick: true}),
          captured: keyOf({onDoubleClickCapture: true})
        }},
      drag: {phasedRegistrationNames: {
          bubbled: keyOf({onDrag: true}),
          captured: keyOf({onDragCapture: true})
        }},
      dragEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnd: true}),
          captured: keyOf({onDragEndCapture: true})
        }},
      dragEnter: {phasedRegistrationNames: {
          bubbled: keyOf({onDragEnter: true}),
          captured: keyOf({onDragEnterCapture: true})
        }},
      dragExit: {phasedRegistrationNames: {
          bubbled: keyOf({onDragExit: true}),
          captured: keyOf({onDragExitCapture: true})
        }},
      dragLeave: {phasedRegistrationNames: {
          bubbled: keyOf({onDragLeave: true}),
          captured: keyOf({onDragLeaveCapture: true})
        }},
      dragOver: {phasedRegistrationNames: {
          bubbled: keyOf({onDragOver: true}),
          captured: keyOf({onDragOverCapture: true})
        }},
      dragStart: {phasedRegistrationNames: {
          bubbled: keyOf({onDragStart: true}),
          captured: keyOf({onDragStartCapture: true})
        }},
      drop: {phasedRegistrationNames: {
          bubbled: keyOf({onDrop: true}),
          captured: keyOf({onDropCapture: true})
        }},
      durationChange: {phasedRegistrationNames: {
          bubbled: keyOf({onDurationChange: true}),
          captured: keyOf({onDurationChangeCapture: true})
        }},
      emptied: {phasedRegistrationNames: {
          bubbled: keyOf({onEmptied: true}),
          captured: keyOf({onEmptiedCapture: true})
        }},
      encrypted: {phasedRegistrationNames: {
          bubbled: keyOf({onEncrypted: true}),
          captured: keyOf({onEncryptedCapture: true})
        }},
      ended: {phasedRegistrationNames: {
          bubbled: keyOf({onEnded: true}),
          captured: keyOf({onEndedCapture: true})
        }},
      error: {phasedRegistrationNames: {
          bubbled: keyOf({onError: true}),
          captured: keyOf({onErrorCapture: true})
        }},
      focus: {phasedRegistrationNames: {
          bubbled: keyOf({onFocus: true}),
          captured: keyOf({onFocusCapture: true})
        }},
      input: {phasedRegistrationNames: {
          bubbled: keyOf({onInput: true}),
          captured: keyOf({onInputCapture: true})
        }},
      keyDown: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyDown: true}),
          captured: keyOf({onKeyDownCapture: true})
        }},
      keyPress: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyPress: true}),
          captured: keyOf({onKeyPressCapture: true})
        }},
      keyUp: {phasedRegistrationNames: {
          bubbled: keyOf({onKeyUp: true}),
          captured: keyOf({onKeyUpCapture: true})
        }},
      load: {phasedRegistrationNames: {
          bubbled: keyOf({onLoad: true}),
          captured: keyOf({onLoadCapture: true})
        }},
      loadedData: {phasedRegistrationNames: {
          bubbled: keyOf({onLoadedData: true}),
          captured: keyOf({onLoadedDataCapture: true})
        }},
      loadedMetadata: {phasedRegistrationNames: {
          bubbled: keyOf({onLoadedMetadata: true}),
          captured: keyOf({onLoadedMetadataCapture: true})
        }},
      loadStart: {phasedRegistrationNames: {
          bubbled: keyOf({onLoadStart: true}),
          captured: keyOf({onLoadStartCapture: true})
        }},
      mouseDown: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseDown: true}),
          captured: keyOf({onMouseDownCapture: true})
        }},
      mouseMove: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseMove: true}),
          captured: keyOf({onMouseMoveCapture: true})
        }},
      mouseOut: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOut: true}),
          captured: keyOf({onMouseOutCapture: true})
        }},
      mouseOver: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseOver: true}),
          captured: keyOf({onMouseOverCapture: true})
        }},
      mouseUp: {phasedRegistrationNames: {
          bubbled: keyOf({onMouseUp: true}),
          captured: keyOf({onMouseUpCapture: true})
        }},
      paste: {phasedRegistrationNames: {
          bubbled: keyOf({onPaste: true}),
          captured: keyOf({onPasteCapture: true})
        }},
      pause: {phasedRegistrationNames: {
          bubbled: keyOf({onPause: true}),
          captured: keyOf({onPauseCapture: true})
        }},
      play: {phasedRegistrationNames: {
          bubbled: keyOf({onPlay: true}),
          captured: keyOf({onPlayCapture: true})
        }},
      playing: {phasedRegistrationNames: {
          bubbled: keyOf({onPlaying: true}),
          captured: keyOf({onPlayingCapture: true})
        }},
      progress: {phasedRegistrationNames: {
          bubbled: keyOf({onProgress: true}),
          captured: keyOf({onProgressCapture: true})
        }},
      rateChange: {phasedRegistrationNames: {
          bubbled: keyOf({onRateChange: true}),
          captured: keyOf({onRateChangeCapture: true})
        }},
      reset: {phasedRegistrationNames: {
          bubbled: keyOf({onReset: true}),
          captured: keyOf({onResetCapture: true})
        }},
      scroll: {phasedRegistrationNames: {
          bubbled: keyOf({onScroll: true}),
          captured: keyOf({onScrollCapture: true})
        }},
      seeked: {phasedRegistrationNames: {
          bubbled: keyOf({onSeeked: true}),
          captured: keyOf({onSeekedCapture: true})
        }},
      seeking: {phasedRegistrationNames: {
          bubbled: keyOf({onSeeking: true}),
          captured: keyOf({onSeekingCapture: true})
        }},
      stalled: {phasedRegistrationNames: {
          bubbled: keyOf({onStalled: true}),
          captured: keyOf({onStalledCapture: true})
        }},
      submit: {phasedRegistrationNames: {
          bubbled: keyOf({onSubmit: true}),
          captured: keyOf({onSubmitCapture: true})
        }},
      suspend: {phasedRegistrationNames: {
          bubbled: keyOf({onSuspend: true}),
          captured: keyOf({onSuspendCapture: true})
        }},
      timeUpdate: {phasedRegistrationNames: {
          bubbled: keyOf({onTimeUpdate: true}),
          captured: keyOf({onTimeUpdateCapture: true})
        }},
      touchCancel: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchCancel: true}),
          captured: keyOf({onTouchCancelCapture: true})
        }},
      touchEnd: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchEnd: true}),
          captured: keyOf({onTouchEndCapture: true})
        }},
      touchMove: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchMove: true}),
          captured: keyOf({onTouchMoveCapture: true})
        }},
      touchStart: {phasedRegistrationNames: {
          bubbled: keyOf({onTouchStart: true}),
          captured: keyOf({onTouchStartCapture: true})
        }},
      volumeChange: {phasedRegistrationNames: {
          bubbled: keyOf({onVolumeChange: true}),
          captured: keyOf({onVolumeChangeCapture: true})
        }},
      waiting: {phasedRegistrationNames: {
          bubbled: keyOf({onWaiting: true}),
          captured: keyOf({onWaitingCapture: true})
        }},
      wheel: {phasedRegistrationNames: {
          bubbled: keyOf({onWheel: true}),
          captured: keyOf({onWheelCapture: true})
        }}
    };
    var topLevelEventsToDispatchConfig = {
      topAbort: eventTypes.abort,
      topBlur: eventTypes.blur,
      topCanPlay: eventTypes.canPlay,
      topCanPlayThrough: eventTypes.canPlayThrough,
      topClick: eventTypes.click,
      topContextMenu: eventTypes.contextMenu,
      topCopy: eventTypes.copy,
      topCut: eventTypes.cut,
      topDoubleClick: eventTypes.doubleClick,
      topDrag: eventTypes.drag,
      topDragEnd: eventTypes.dragEnd,
      topDragEnter: eventTypes.dragEnter,
      topDragExit: eventTypes.dragExit,
      topDragLeave: eventTypes.dragLeave,
      topDragOver: eventTypes.dragOver,
      topDragStart: eventTypes.dragStart,
      topDrop: eventTypes.drop,
      topDurationChange: eventTypes.durationChange,
      topEmptied: eventTypes.emptied,
      topEncrypted: eventTypes.encrypted,
      topEnded: eventTypes.ended,
      topError: eventTypes.error,
      topFocus: eventTypes.focus,
      topInput: eventTypes.input,
      topKeyDown: eventTypes.keyDown,
      topKeyPress: eventTypes.keyPress,
      topKeyUp: eventTypes.keyUp,
      topLoad: eventTypes.load,
      topLoadedData: eventTypes.loadedData,
      topLoadedMetadata: eventTypes.loadedMetadata,
      topLoadStart: eventTypes.loadStart,
      topMouseDown: eventTypes.mouseDown,
      topMouseMove: eventTypes.mouseMove,
      topMouseOut: eventTypes.mouseOut,
      topMouseOver: eventTypes.mouseOver,
      topMouseUp: eventTypes.mouseUp,
      topPause: eventTypes.pause,
      topPaste: eventTypes.paste,
      topPlay: eventTypes.play,
      topPlaying: eventTypes.playing,
      topProgress: eventTypes.progress,
      topRateChange: eventTypes.rateChange,
      topReset: eventTypes.reset,
      topSeeked: eventTypes.seeked,
      topSeeking: eventTypes.seeking,
      topScroll: eventTypes.scroll,
      topStalled: eventTypes.stalled,
      topSubmit: eventTypes.submit,
      topSuspend: eventTypes.suspend,
      topTimeUpdate: eventTypes.timeUpdate,
      topTouchCancel: eventTypes.touchCancel,
      topTouchEnd: eventTypes.touchEnd,
      topTouchMove: eventTypes.touchMove,
      topTouchStart: eventTypes.touchStart,
      topVolumeChange: eventTypes.volumeChange,
      topWaiting: eventTypes.waiting,
      topWheel: eventTypes.wheel
    };
    for (var type in topLevelEventsToDispatchConfig) {
      topLevelEventsToDispatchConfig[type].dependencies = [type];
    }
    var ON_CLICK_KEY = keyOf({onClick: null});
    var onClickListeners = {};
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      executeDispatch: function(event, listener, domID) {
        var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
        process.env.NODE_ENV !== 'production' ? warning(typeof returnValue !== 'boolean', 'Returning `false` from an event handler is deprecated and will be ' + 'ignored in a future release. Instead, manually call ' + 'e.stopPropagation() or e.preventDefault(), as appropriate.') : undefined;
        if (returnValue === false) {
          event.stopPropagation();
          event.preventDefault();
        }
      },
      extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case topLevelTypes.topAbort:
          case topLevelTypes.topCanPlay:
          case topLevelTypes.topCanPlayThrough:
          case topLevelTypes.topDurationChange:
          case topLevelTypes.topEmptied:
          case topLevelTypes.topEncrypted:
          case topLevelTypes.topEnded:
          case topLevelTypes.topError:
          case topLevelTypes.topInput:
          case topLevelTypes.topLoad:
          case topLevelTypes.topLoadedData:
          case topLevelTypes.topLoadedMetadata:
          case topLevelTypes.topLoadStart:
          case topLevelTypes.topPause:
          case topLevelTypes.topPlay:
          case topLevelTypes.topPlaying:
          case topLevelTypes.topProgress:
          case topLevelTypes.topRateChange:
          case topLevelTypes.topReset:
          case topLevelTypes.topSeeked:
          case topLevelTypes.topSeeking:
          case topLevelTypes.topStalled:
          case topLevelTypes.topSubmit:
          case topLevelTypes.topSuspend:
          case topLevelTypes.topTimeUpdate:
          case topLevelTypes.topVolumeChange:
          case topLevelTypes.topWaiting:
            EventConstructor = SyntheticEvent;
            break;
          case topLevelTypes.topKeyPress:
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case topLevelTypes.topKeyDown:
          case topLevelTypes.topKeyUp:
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case topLevelTypes.topBlur:
          case topLevelTypes.topFocus:
            EventConstructor = SyntheticFocusEvent;
            break;
          case topLevelTypes.topClick:
            if (nativeEvent.button === 2) {
              return null;
            }
          case topLevelTypes.topContextMenu:
          case topLevelTypes.topDoubleClick:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topMouseMove:
          case topLevelTypes.topMouseOut:
          case topLevelTypes.topMouseOver:
          case topLevelTypes.topMouseUp:
            EventConstructor = SyntheticMouseEvent;
            break;
          case topLevelTypes.topDrag:
          case topLevelTypes.topDragEnd:
          case topLevelTypes.topDragEnter:
          case topLevelTypes.topDragExit:
          case topLevelTypes.topDragLeave:
          case topLevelTypes.topDragOver:
          case topLevelTypes.topDragStart:
          case topLevelTypes.topDrop:
            EventConstructor = SyntheticDragEvent;
            break;
          case topLevelTypes.topTouchCancel:
          case topLevelTypes.topTouchEnd:
          case topLevelTypes.topTouchMove:
          case topLevelTypes.topTouchStart:
            EventConstructor = SyntheticTouchEvent;
            break;
          case topLevelTypes.topScroll:
            EventConstructor = SyntheticUIEvent;
            break;
          case topLevelTypes.topWheel:
            EventConstructor = SyntheticWheelEvent;
            break;
          case topLevelTypes.topCopy:
          case topLevelTypes.topCut:
          case topLevelTypes.topPaste:
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
        var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      },
      didPutListener: function(id, registrationName, listener) {
        if (registrationName === ON_CLICK_KEY) {
          var node = ReactMount.getNode(id);
          if (!onClickListeners[id]) {
            onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
          }
        }
      },
      willDeleteListener: function(id, registrationName) {
        if (registrationName === ON_CLICK_KEY) {
          onClickListeners[id].remove();
          delete onClickListeners[id];
        }
      }
    };
    module.exports = SimpleEventPlugin;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDefaultPerf", ["npm:react@0.14.0-beta3/lib/DOMProperty", "npm:react@0.14.0-beta3/lib/ReactDefaultPerfAnalysis", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:fbjs@0.1.0-alpha.4/lib/performanceNow"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("npm:react@0.14.0-beta3/lib/DOMProperty");
  var ReactDefaultPerfAnalysis = require("npm:react@0.14.0-beta3/lib/ReactDefaultPerfAnalysis");
  var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
  var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
  var performanceNow = require("npm:fbjs@0.1.0-alpha.4/lib/performanceNow");
  function roundFloat(val) {
    return Math.floor(val * 100) / 100;
  }
  function addValue(obj, key, val) {
    obj[key] = (obj[key] || 0) + val;
  }
  var ReactDefaultPerf = {
    _allMeasurements: [],
    _mountStack: [0],
    _injected: false,
    start: function() {
      if (!ReactDefaultPerf._injected) {
        ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
      }
      ReactDefaultPerf._allMeasurements.length = 0;
      ReactPerf.enableMeasure = true;
    },
    stop: function() {
      ReactPerf.enableMeasure = false;
    },
    getLastMeasurements: function() {
      return ReactDefaultPerf._allMeasurements;
    },
    printExclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Component class name': item.componentName,
          'Total inclusive time (ms)': roundFloat(item.inclusive),
          'Exclusive mount time (ms)': roundFloat(item.exclusive),
          'Exclusive render time (ms)': roundFloat(item.render),
          'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
          'Render time per instance (ms)': roundFloat(item.render / item.count),
          'Instances': item.count
        };
      }));
    },
    printInclusive: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
      console.table(summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Inclusive time (ms)': roundFloat(item.time),
          'Instances': item.count
        };
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    getMeasurementsSummaryMap: function(measurements) {
      var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
      return summary.map(function(item) {
        return {
          'Owner > component': item.componentName,
          'Wasted time (ms)': item.time,
          'Instances': item.count
        };
      });
    },
    printWasted: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    printDOM: function(measurements) {
      measurements = measurements || ReactDefaultPerf._allMeasurements;
      var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
      console.table(summary.map(function(item) {
        var result = {};
        result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
        result.type = item.type;
        result.args = JSON.stringify(item.args);
        return result;
      }));
      console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
    },
    _recordWrite: function(id, fnName, totalTime, args) {
      var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
      writes[id] = writes[id] || [];
      writes[id].push({
        type: fnName,
        time: totalTime,
        args: args
      });
    },
    measure: function(moduleName, fnName, func) {
      return function() {
        for (var _len = arguments.length,
            args = Array(_len),
            _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var totalTime;
        var rv;
        var start;
        if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
          ReactDefaultPerf._allMeasurements.push({
            exclusive: {},
            inclusive: {},
            render: {},
            counts: {},
            writes: {},
            displayNames: {},
            totalTime: 0
          });
          start = performanceNow();
          rv = func.apply(this, args);
          ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
          return rv;
        } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactDOMIDOperations') {
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (fnName === '_mountImageIntoNode') {
            var mountID = ReactMount.getID(args[1]);
            ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
          } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
            args[0].forEach(function(update) {
              var writeArgs = {};
              if (update.fromIndex !== null) {
                writeArgs.fromIndex = update.fromIndex;
              }
              if (update.toIndex !== null) {
                writeArgs.toIndex = update.toIndex;
              }
              if (update.textContent !== null) {
                writeArgs.textContent = update.textContent;
              }
              if (update.markupIndex !== null) {
                writeArgs.markup = args[1][update.markupIndex];
              }
              ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
            });
          } else {
            ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
          }
          return rv;
        } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || fnName === '_renderValidatedComponent')) {
          if (typeof this._currentElement.type === 'string') {
            return func.apply(this, args);
          }
          var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
          var isRender = fnName === '_renderValidatedComponent';
          var isMount = fnName === 'mountComponent';
          var mountStack = ReactDefaultPerf._mountStack;
          var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
          if (isRender) {
            addValue(entry.counts, rootNodeID, 1);
          } else if (isMount) {
            mountStack.push(0);
          }
          start = performanceNow();
          rv = func.apply(this, args);
          totalTime = performanceNow() - start;
          if (isRender) {
            addValue(entry.render, rootNodeID, totalTime);
          } else if (isMount) {
            var subMountTime = mountStack.pop();
            mountStack[mountStack.length - 1] += totalTime;
            addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
            addValue(entry.inclusive, rootNodeID, totalTime);
          } else {
            addValue(entry.inclusive, rootNodeID, totalTime);
          }
          entry.displayNames[rootNodeID] = {
            current: this.getName(),
            owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
          };
          return rv;
        } else {
          return func.apply(this, args);
        }
      };
    }
  };
  module.exports = ReactDefaultPerf;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMServer", ["npm:react@0.14.0-beta3/lib/ReactDefaultInjection", "npm:react@0.14.0-beta3/lib/ReactServerRendering"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactDefaultInjection = require("npm:react@0.14.0-beta3/lib/ReactDefaultInjection");
  var ReactServerRendering = require("npm:react@0.14.0-beta3/lib/ReactServerRendering");
  ReactDefaultInjection.inject();
  var ReactDOMServer = {
    renderToString: ReactServerRendering.renderToString,
    renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup
  };
  module.exports = ReactDOMServer;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactIsomorphic", ["npm:react@0.14.0-beta3/lib/ReactChildren", "npm:react@0.14.0-beta3/lib/ReactComponent", "npm:react@0.14.0-beta3/lib/ReactClass", "npm:react@0.14.0-beta3/lib/ReactDOMFactories", "npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactElementValidator", "npm:react@0.14.0-beta3/lib/ReactPropTypes", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:react@0.14.0-beta3/lib/onlyChild", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactChildren = require("npm:react@0.14.0-beta3/lib/ReactChildren");
    var ReactComponent = require("npm:react@0.14.0-beta3/lib/ReactComponent");
    var ReactClass = require("npm:react@0.14.0-beta3/lib/ReactClass");
    var ReactDOMFactories = require("npm:react@0.14.0-beta3/lib/ReactDOMFactories");
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactElementValidator = require("npm:react@0.14.0-beta3/lib/ReactElementValidator");
    var ReactPropTypes = require("npm:react@0.14.0-beta3/lib/ReactPropTypes");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var onlyChild = require("npm:react@0.14.0-beta3/lib/onlyChild");
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    var cloneElement = ReactElement.cloneElement;
    if (process.env.NODE_ENV !== 'production') {
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
      cloneElement = ReactElementValidator.cloneElement;
    }
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        only: onlyChild
      },
      Component: ReactComponent,
      createElement: createElement,
      cloneElement: cloneElement,
      isValidElement: ReactElement.isValidElement,
      PropTypes: ReactPropTypes,
      createClass: ReactClass.createClass,
      createFactory: createFactory,
      createMixin: function(mixin) {
        return mixin;
      },
      DOM: ReactDOMFactories,
      __spread: assign
    };
    module.exports = React;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/fn/object/get-own-property-descriptor", ["npm:core-js@0.9.18/library/modules/$", "npm:core-js@0.9.18/library/modules/es6.object.statics-accept-primitives"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.18/library/modules/$");
  require("npm:core-js@0.9.18/library/modules/es6.object.statics-accept-primitives");
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/modules/es6.object.set-prototype-of", ["npm:core-js@0.9.18/library/modules/$.def", "npm:core-js@0.9.18/library/modules/$.set-proto"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@0.9.18/library/modules/$.def");
  $def($def.S, 'Object', {setPrototypeOf: require("npm:core-js@0.9.18/library/modules/$.set-proto").set});
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/helpers/create-class", ["npm:babel-runtime@5.8.20/core-js/object/define-property"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$defineProperty = require("npm:babel-runtime@5.8.20/core-js/object/define-property")["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3/index", ["npm:flux@2.0.3/lib/Dispatcher"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports.Dispatcher = require("npm:flux@2.0.3/lib/Dispatcher");
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib/store/AltStore", ["npm:alt@0.17.1/utils/functions", "npm:transmitter@1.0.2"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var _utilsFunctions = require("npm:alt@0.17.1/utils/functions");
  var fn = _interopRequireWildcard(_utilsFunctions);
  var _transmitter = require("npm:transmitter@1.0.2");
  var _transmitter2 = _interopRequireDefault(_transmitter);
  var AltStore = (function() {
    function AltStore(alt, model, state, StoreModel) {
      var _this = this;
      _classCallCheck(this, AltStore);
      var lifecycleEvents = model.lifecycleEvents;
      this.transmitter = (0, _transmitter2['default'])();
      this.lifecycle = function(event, x) {
        if (lifecycleEvents[event])
          lifecycleEvents[event].push(x);
      };
      this.state = state || model;
      this.preventDefault = false;
      this.displayName = model.displayName;
      this.boundListeners = model.boundListeners;
      this.StoreModel = StoreModel;
      var output = model.output || function(x) {
        return x;
      };
      this.emitChange = function() {
        return _this.transmitter.push(output(_this.state));
      };
      var handleDispatch = function handleDispatch(f, payload) {
        try {
          return f();
        } catch (e) {
          if (model.handlesOwnErrors) {
            _this.lifecycle('error', {
              error: e,
              payload: payload,
              state: _this.state
            });
            return false;
          } else {
            throw e;
          }
        }
      };
      fn.assign(this, model.publicMethods);
      this.dispatchToken = alt.dispatcher.register(function(payload) {
        _this.preventDefault = false;
        _this.lifecycle('beforeEach', {
          payload: payload,
          state: _this.state
        });
        var actionHandler = model.actionListeners[payload.action] || model.otherwise;
        if (actionHandler) {
          var result = handleDispatch(function() {
            return actionHandler.call(model, payload.data, payload.action);
          }, payload);
          if (result !== false && !_this.preventDefault)
            _this.emitChange();
        }
        if (model.reduce) {
          handleDispatch(function() {
            model.setState(model.reduce(_this.state, payload));
          }, payload);
          if (!_this.preventDefault)
            _this.emitChange();
        }
        _this.lifecycle('afterEach', {
          payload: payload,
          state: _this.state
        });
      });
      this.lifecycle('init');
    }
    _createClass(AltStore, [{
      key: 'listen',
      value: function listen(cb) {
        var _this2 = this;
        this.transmitter.subscribe(cb);
        return function() {
          return _this2.unlisten(cb);
        };
      }
    }, {
      key: 'unlisten',
      value: function unlisten(cb) {
        this.lifecycle('unlisten');
        this.transmitter.unsubscribe(cb);
      }
    }, {
      key: 'getState',
      value: function getState() {
        return this.StoreModel.config.getState.call(this, this.state);
      }
    }]);
    return AltStore;
  })();
  exports['default'] = AltStore;
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@3.0.0", ["npm:rx@3.0.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:rx@3.0.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:buffer@3.4.1/index", ["npm:base64-js@0.0.8", "npm:ieee754@1.1.6", "npm:is-array@1.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var base64 = require("npm:base64-js@0.0.8");
  var ieee754 = require("npm:ieee754@1.1.6");
  var isArray = require("npm:is-array@1.0.1");
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = (function() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  })();
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    this.length = 0;
    this.parent = undefined;
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  Buffer.prototype.length = undefined;
  Buffer.prototype.parent = undefined;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    var res = '';
    var tmp = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }
    return res + decodeUtf8Char(tmp);
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = value;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = value;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = value;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value;
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = value;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return ;
    if (this.length === 0)
      return ;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    var i = 0;
    for (; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (leadSurrogate) {
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } else {
            codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
            leadSurrogate = null;
          }
        } else {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else {
            leadSurrogate = codePoint;
            continue;
          }
        }
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = null;
      }
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x200000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function decodeUtf8Char(str) {
    try {
      return decodeURIComponent(str);
    } catch (err) {
      return String.fromCharCode(0xFFFD);
    }
  }
  global.define = __define;
  return module.exports;
});

System.register("github:michelle/reliable@master", ["github:michelle/reliable@master/lib/reliable"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:michelle/reliable@master/lib/reliable");
  global.define = __define;
  return module.exports;
});

System.register("npm:md5@2.0.0/md5", ["npm:crypt@0.0.1", "npm:charenc@0.0.1", "npm:is-buffer@1.0.2", "npm:charenc@0.0.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function() {
    var crypt = require("npm:crypt@0.0.1"),
        utf8 = require("npm:charenc@0.0.1").utf8,
        isBuffer = require("npm:is-buffer@1.0.2"),
        bin = require("npm:charenc@0.0.1").bin,
        md5 = function(message, options) {
          if (message.constructor == String)
            if (options && options.encoding === 'binary')
              message = bin.stringToBytes(message);
            else
              message = utf8.stringToBytes(message);
          else if (isBuffer(message))
            message = Array.prototype.slice.call(message, 0);
          else if (!Array.isArray(message))
            message = message.toString();
          var m = crypt.bytesToWords(message),
              l = message.length * 8,
              a = 1732584193,
              b = -271733879,
              c = -1732584194,
              d = 271733878;
          for (var i = 0; i < m.length; i++) {
            m[i] = ((m[i] << 8) | (m[i] >>> 24)) & 0x00FF00FF | ((m[i] << 24) | (m[i] >>> 8)) & 0xFF00FF00;
          }
          m[l >>> 5] |= 0x80 << (l % 32);
          m[(((l + 64) >>> 9) << 4) + 14] = l;
          var FF = md5._ff,
              GG = md5._gg,
              HH = md5._hh,
              II = md5._ii;
          for (var i = 0; i < m.length; i += 16) {
            var aa = a,
                bb = b,
                cc = c,
                dd = d;
            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
            c = FF(c, d, a, b, m[i + 10], 17, -42063);
            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
            a = HH(a, b, c, d, m[i + 5], 4, -378558);
            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
            b = HH(b, c, d, a, m[i + 2], 23, -995338651);
            a = II(a, b, c, d, m[i + 0], 6, -198630844);
            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
            b = II(b, c, d, a, m[i + 5], 21, -57434055);
            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
            c = II(c, d, a, b, m[i + 10], 15, -1051523);
            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
            d = II(d, a, b, c, m[i + 15], 10, -30611744);
            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
            a = II(a, b, c, d, m[i + 4], 6, -145523070);
            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
            c = II(c, d, a, b, m[i + 2], 15, 718787259);
            b = II(b, c, d, a, m[i + 9], 21, -343485551);
            a = (a + aa) >>> 0;
            b = (b + bb) >>> 0;
            c = (c + cc) >>> 0;
            d = (d + dd) >>> 0;
          }
          return crypt.endian([a, b, c, d]);
        };
    md5._ff = function(a, b, c, d, x, s, t) {
      var n = a + (b & c | ~b & d) + (x >>> 0) + t;
      return ((n << s) | (n >>> (32 - s))) + b;
    };
    md5._gg = function(a, b, c, d, x, s, t) {
      var n = a + (b & d | c & ~d) + (x >>> 0) + t;
      return ((n << s) | (n >>> (32 - s))) + b;
    };
    md5._hh = function(a, b, c, d, x, s, t) {
      var n = a + (b ^ c ^ d) + (x >>> 0) + t;
      return ((n << s) | (n >>> (32 - s))) + b;
    };
    md5._ii = function(a, b, c, d, x, s, t) {
      var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
      return ((n << s) | (n >>> (32 - s))) + b;
    };
    md5._blocksize = 16;
    md5._digestsize = 16;
    module.exports = function(message, options) {
      if (typeof message == 'undefined')
        return ;
      var digestbytes = crypt.wordsToBytes(md5(message, options));
      return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
    };
  })();
  global.define = __define;
  return module.exports;
});

System.register("npm:URIjs@1.16.0", ["npm:URIjs@1.16.0/src/URI"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:URIjs@1.16.0/src/URI");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/Danger", ["npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:fbjs@0.1.0-alpha.4/lib/createNodesFromMarkup", "npm:fbjs@0.1.0-alpha.4/lib/emptyFunction", "npm:fbjs@0.1.0-alpha.4/lib/getMarkupWrap", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var createNodesFromMarkup = require("npm:fbjs@0.1.0-alpha.4/lib/createNodesFromMarkup");
    var emptyFunction = require("npm:fbjs@0.1.0-alpha.4/lib/emptyFunction");
    var getMarkupWrap = require("npm:fbjs@0.1.0-alpha.4/lib/getMarkupWrap");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
    var RESULT_INDEX_ATTR = 'data-danger-index';
    function getNodeName(markup) {
      return markup.substring(1, markup.indexOf(' '));
    }
    var Danger = {
      dangerouslyRenderMarkup: function(markupList) {
        !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(false) : undefined;
        var nodeName;
        var markupByNodeName = {};
        for (var i = 0; i < markupList.length; i++) {
          !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
          nodeName = getNodeName(markupList[i]);
          nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
          markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
          markupByNodeName[nodeName][i] = markupList[i];
        }
        var resultList = [];
        var resultListAssignmentCount = 0;
        for (nodeName in markupByNodeName) {
          if (!markupByNodeName.hasOwnProperty(nodeName)) {
            continue;
          }
          var markupListByNodeName = markupByNodeName[nodeName];
          var resultIndex;
          for (resultIndex in markupListByNodeName) {
            if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
            }
          }
          var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction);
          for (var j = 0; j < renderNodes.length; ++j) {
            var renderNode = renderNodes[j];
            if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
              resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
              renderNode.removeAttribute(RESULT_INDEX_ATTR);
              !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
              resultList[resultIndex] = renderNode;
              resultListAssignmentCount += 1;
            } else if (process.env.NODE_ENV !== 'production') {
              console.error('Danger: Discarding unexpected node:', renderNode);
            }
          }
        }
        !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
        !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
        return resultList;
      },
      dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
        !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'React.renderToString for server rendering.') : invariant(false) : undefined;
        !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
        !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See React.renderToString().') : invariant(false) : undefined;
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      }
    };
    module.exports = Danger;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactUpdateQueue", ["npm:react@0.14.0-beta3/lib/ReactCurrentOwner", "npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactInstanceMap", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = require("npm:react@0.14.0-beta3/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactInstanceMap = require("npm:react@0.14.0-beta3/lib/ReactInstanceMap");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    function enqueueUpdate(internalInstance) {
      ReactUpdates.enqueueUpdate(internalInstance);
    }
    function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
      }
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (!internalInstance) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
        }
        return null;
      }
      return internalInstance;
    }
    var ReactUpdateQueue = {
      isMounted: function(publicInstance) {
        if (process.env.NODE_ENV !== 'production') {
          var owner = ReactCurrentOwner.current;
          if (owner !== null) {
            process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
            owner._warnedAboutRefsInRender = true;
          }
        }
        var internalInstance = ReactInstanceMap.get(publicInstance);
        if (internalInstance) {
          return !!internalInstance._renderedComponent;
        } else {
          return false;
        }
      },
      enqueueCallback: function(publicInstance, callback) {
        !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
        if (!internalInstance) {
          return null;
        }
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueCallbackInternal: function(internalInstance, callback) {
        !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueForceUpdate: function(publicInstance) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
        if (!internalInstance) {
          return ;
        }
        internalInstance._pendingForceUpdate = true;
        enqueueUpdate(internalInstance);
      },
      enqueueReplaceState: function(publicInstance, completeState) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
        if (!internalInstance) {
          return ;
        }
        internalInstance._pendingStateQueue = [completeState];
        internalInstance._pendingReplaceState = true;
        enqueueUpdate(internalInstance);
      },
      enqueueSetState: function(publicInstance, partialState) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
        if (!internalInstance) {
          return ;
        }
        var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
        queue.push(partialState);
        enqueueUpdate(internalInstance);
      },
      enqueueSetProps: function(publicInstance, partialProps) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
        if (!internalInstance) {
          return ;
        }
        ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
      },
      enqueueSetPropsInternal: function(internalInstance, partialProps) {
        var topLevelWrapper = internalInstance._topLevelWrapper;
        !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
        var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
        var element = wrapElement.props;
        var props = assign({}, element.props, partialProps);
        topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
        enqueueUpdate(topLevelWrapper);
      },
      enqueueReplaceProps: function(publicInstance, props) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
        if (!internalInstance) {
          return ;
        }
        ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
      },
      enqueueReplacePropsInternal: function(internalInstance, props) {
        var topLevelWrapper = internalInstance._topLevelWrapper;
        !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
        var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
        var element = wrapElement.props;
        topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
        enqueueUpdate(topLevelWrapper);
      },
      enqueueElementInternal: function(internalInstance, newElement) {
        internalInstance._pendingElement = newElement;
        enqueueUpdate(internalInstance);
      }
    };
    module.exports = ReactUpdateQueue;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMInput", ["npm:react@0.14.0-beta3/lib/ReactDOMIDOperations", "npm:react@0.14.0-beta3/lib/LinkedValueUtils", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactDOMIDOperations = require("npm:react@0.14.0-beta3/lib/ReactDOMIDOperations");
    var LinkedValueUtils = require("npm:react@0.14.0-beta3/lib/LinkedValueUtils");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var instancesByReactID = {};
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMInput.updateWrapper(this);
      }
    }
    var ReactDOMInput = {
      getNativeProps: function(inst, props, context) {
        var value = LinkedValueUtils.getValue(props);
        var checked = LinkedValueUtils.getChecked(props);
        var nativeProps = assign({}, props, {
          defaultChecked: undefined,
          defaultValue: undefined,
          value: value != null ? value : inst._wrapperState.initialValue,
          checked: checked != null ? checked : inst._wrapperState.initialChecked,
          onChange: inst._wrapperState.onChange
        });
        return nativeProps;
      },
      mountWrapper: function(inst, props) {
        LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
        var defaultValue = props.defaultValue;
        inst._wrapperState = {
          initialChecked: props.defaultChecked || false,
          initialValue: defaultValue != null ? defaultValue : null,
          onChange: _handleChange.bind(inst)
        };
        instancesByReactID[inst._rootNodeID] = inst;
      },
      unmountWrapper: function(inst) {
        delete instancesByReactID[inst._rootNodeID];
      },
      updateWrapper: function(inst) {
        var props = inst._currentElement.props;
        var checked = props.checked;
        if (checked != null) {
          ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
        }
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      var name = props.name;
      if (props.type === 'radio' && name != null) {
        var rootNode = ReactMount.getNode(this._rootNodeID);
        var queryRoot = rootNode;
        while (queryRoot.parentNode) {
          queryRoot = queryRoot.parentNode;
        }
        var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
        for (var i = 0; i < group.length; i++) {
          var otherNode = group[i];
          if (otherNode === rootNode || otherNode.form !== rootNode.form) {
            continue;
          }
          var otherID = ReactMount.getID(otherNode);
          !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
          var otherInstance = instancesByReactID[otherID];
          !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
          ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
        }
      }
      return returnValue;
    }
    module.exports = ReactDOMInput;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/EnterLeaveEventPlugin", ["npm:react@0.14.0-beta3/lib/EventConstants", "npm:react@0.14.0-beta3/lib/EventPropagators", "npm:react@0.14.0-beta3/lib/SyntheticMouseEvent", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:fbjs@0.1.0-alpha.4/lib/keyOf"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
  var EventPropagators = require("npm:react@0.14.0-beta3/lib/EventPropagators");
  var SyntheticMouseEvent = require("npm:react@0.14.0-beta3/lib/SyntheticMouseEvent");
  var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
  var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
  var topLevelTypes = EventConstants.topLevelTypes;
  var getFirstReactDOM = ReactMount.getFirstReactDOM;
  var eventTypes = {
    mouseEnter: {
      registrationName: keyOf({onMouseEnter: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    },
    mouseLeave: {
      registrationName: keyOf({onMouseLeave: null}),
      dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
    }
  };
  var extractedEvents = [null, null];
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
      if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
        return null;
      }
      var win;
      if (topLevelTarget.window === topLevelTarget) {
        win = topLevelTarget;
      } else {
        var doc = topLevelTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from,
          to;
      if (topLevelType === topLevelTypes.topMouseOut) {
        from = topLevelTarget;
        to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win;
      } else {
        from = win;
        to = topLevelTarget;
      }
      if (from === to) {
        return null;
      }
      var fromID = from ? ReactMount.getID(from) : '';
      var toID = to ? ReactMount.getID(to) : '';
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
      leave.type = 'mouseleave';
      leave.target = from;
      leave.relatedTarget = to;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
      enter.type = 'mouseenter';
      enter.target = to;
      enter.relatedTarget = from;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
      extractedEvents[0] = leave;
      extractedEvents[1] = enter;
      return extractedEvents;
    }
  };
  module.exports = EnterLeaveEventPlugin;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactInjection", ["npm:react@0.14.0-beta3/lib/DOMProperty", "npm:react@0.14.0-beta3/lib/EventPluginHub", "npm:react@0.14.0-beta3/lib/ReactComponentEnvironment", "npm:react@0.14.0-beta3/lib/ReactClass", "npm:react@0.14.0-beta3/lib/ReactEmptyComponent", "npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter", "npm:react@0.14.0-beta3/lib/ReactNativeComponent", "npm:react@0.14.0-beta3/lib/ReactDOMComponent", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:react@0.14.0-beta3/lib/ReactRootIndex", "npm:react@0.14.0-beta3/lib/ReactUpdates"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var DOMProperty = require("npm:react@0.14.0-beta3/lib/DOMProperty");
  var EventPluginHub = require("npm:react@0.14.0-beta3/lib/EventPluginHub");
  var ReactComponentEnvironment = require("npm:react@0.14.0-beta3/lib/ReactComponentEnvironment");
  var ReactClass = require("npm:react@0.14.0-beta3/lib/ReactClass");
  var ReactEmptyComponent = require("npm:react@0.14.0-beta3/lib/ReactEmptyComponent");
  var ReactBrowserEventEmitter = require("npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter");
  var ReactNativeComponent = require("npm:react@0.14.0-beta3/lib/ReactNativeComponent");
  var ReactDOMComponent = require("npm:react@0.14.0-beta3/lib/ReactDOMComponent");
  var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
  var ReactRootIndex = require("npm:react@0.14.0-beta3/lib/ReactRootIndex");
  var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
  var ReactInjection = {
    Component: ReactComponentEnvironment.injection,
    Class: ReactClass.injection,
    DOMComponent: ReactDOMComponent.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    NativeComponent: ReactNativeComponent.injection,
    Perf: ReactPerf.injection,
    RootIndex: ReactRootIndex.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactReconcileTransaction", ["npm:react@0.14.0-beta3/lib/CallbackQueue", "npm:react@0.14.0-beta3/lib/PooledClass", "npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter", "npm:react@0.14.0-beta3/lib/ReactInputSelection", "npm:react@0.14.0-beta3/lib/Transaction", "npm:react@0.14.0-beta3/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var CallbackQueue = require("npm:react@0.14.0-beta3/lib/CallbackQueue");
  var PooledClass = require("npm:react@0.14.0-beta3/lib/PooledClass");
  var ReactBrowserEventEmitter = require("npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter");
  var ReactInputSelection = require("npm:react@0.14.0-beta3/lib/ReactInputSelection");
  var Transaction = require("npm:react@0.14.0-beta3/lib/Transaction");
  var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
  var SELECTION_RESTORATION = {
    initialize: ReactInputSelection.getSelectionInformation,
    close: ReactInputSelection.restoreSelection
  };
  var EVENT_SUPPRESSION = {
    initialize: function() {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },
    close: function(previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };
  var ON_DOM_READY_QUEUEING = {
    initialize: function() {
      this.reactMountReady.reset();
    },
    close: function() {
      this.reactMountReady.notifyAll();
    }
  };
  var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
  function ReactReconcileTransaction() {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
  }
  var Mixin = {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
    getReactMountReady: function() {
      return this.reactMountReady;
    },
    destructor: function() {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
    }
  };
  assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
  PooledClass.addPoolingTo(ReactReconcileTransaction);
  module.exports = ReactReconcileTransaction;
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/core-js/object/get-own-property-descriptor", ["npm:core-js@0.9.18/library/fn/object/get-own-property-descriptor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.18/library/fn/object/get-own-property-descriptor"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.18/library/fn/object/set-prototype-of", ["npm:core-js@0.9.18/library/modules/es6.object.set-prototype-of", "npm:core-js@0.9.18/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.18/library/modules/es6.object.set-prototype-of");
  module.exports = require("npm:core-js@0.9.18/library/modules/$").core.Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

System.register("npm:flux@2.0.3", ["npm:flux@2.0.3/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:flux@2.0.3/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib/store/index", ["npm:alt@0.17.1/lib/utils/AltUtils", "npm:alt@0.17.1/utils/functions", "npm:alt@0.17.1/lib/store/AltStore", "npm:alt@0.17.1/lib/store/StoreMixin"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _bind = Function.prototype.bind;
  var _get = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          continue _function;
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.createStoreConfig = createStoreConfig;
  exports.transformStore = transformStore;
  exports.createStoreFromObject = createStoreFromObject;
  exports.createStoreFromClass = createStoreFromClass;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      subClass.__proto__ = superClass;
  }
  var _utilsAltUtils = require("npm:alt@0.17.1/lib/utils/AltUtils");
  var utils = _interopRequireWildcard(_utilsAltUtils);
  var _utilsFunctions = require("npm:alt@0.17.1/utils/functions");
  var fn = _interopRequireWildcard(_utilsFunctions);
  var _AltStore = require("npm:alt@0.17.1/lib/store/AltStore");
  var _AltStore2 = _interopRequireDefault(_AltStore);
  var _StoreMixin = require("npm:alt@0.17.1/lib/store/StoreMixin");
  var _StoreMixin2 = _interopRequireDefault(_StoreMixin);
  function doSetState(store, storeInstance, state) {
    if (!state) {
      return ;
    }
    var config = storeInstance.StoreModel.config;
    var nextState = fn.isFunction(state) ? state(storeInstance.state) : state;
    storeInstance.state = config.setState.call(store, storeInstance.state, nextState);
    if (!store.alt.dispatcher.isDispatching()) {
      store.emitChange();
    }
  }
  function createPrototype(proto, alt, key, extras) {
    proto.boundListeners = [];
    proto.lifecycleEvents = {};
    proto.actionListeners = {};
    proto.publicMethods = {};
    proto.handlesOwnErrors = false;
    return fn.assign(proto, _StoreMixin2['default'], {
      displayName: key,
      alt: alt,
      dispatcher: alt.dispatcher,
      preventDefault: function preventDefault() {
        this.getInstance().preventDefault = true;
      }
    }, extras);
  }
  function createStoreConfig(globalConfig, StoreModel) {
    StoreModel.config = fn.assign({
      getState: function getState(state) {
        return fn.assign({}, state);
      },
      setState: fn.assign
    }, globalConfig, StoreModel.config);
  }
  function transformStore(transforms, StoreModel) {
    return transforms.reduce(function(Store, transform) {
      return transform(Store);
    }, StoreModel);
  }
  function createStoreFromObject(alt, StoreModel, key) {
    var storeInstance = undefined;
    var StoreProto = createPrototype({}, alt, key, fn.assign({
      getInstance: function getInstance() {
        return storeInstance;
      },
      setState: function setState(nextState) {
        doSetState(this, storeInstance, nextState);
      }
    }, StoreModel));
    if (StoreProto.bindListeners) {
      _StoreMixin2['default'].bindListeners.call(StoreProto, StoreProto.bindListeners);
    }
    if (StoreProto.observe) {
      _StoreMixin2['default'].bindListeners.call(StoreProto, StoreProto.observe(alt));
    }
    if (StoreProto.lifecycle) {
      fn.eachObject(function(eventName, event) {
        _StoreMixin2['default'].on.call(StoreProto, eventName, event);
      }, [StoreProto.lifecycle]);
    }
    storeInstance = fn.assign(new _AltStore2['default'](alt, StoreProto, StoreProto.state || {}, StoreModel), StoreProto.publicMethods, {displayName: key});
    return storeInstance;
  }
  function createStoreFromClass(alt, StoreModel, key) {
    var storeInstance = undefined;
    var config = StoreModel.config;
    var Store = (function(_StoreModel) {
      function Store() {
        _classCallCheck(this, Store);
        for (var _len2 = arguments.length,
            args = Array(_len2),
            _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        _get(Object.getPrototypeOf(Store.prototype), 'constructor', this).apply(this, args);
      }
      _inherits(Store, _StoreModel);
      return Store;
    })(StoreModel);
    createPrototype(Store.prototype, alt, key, {
      getInstance: function getInstance() {
        return storeInstance;
      },
      setState: function setState(nextState) {
        doSetState(this, storeInstance, nextState);
      }
    });
    for (var _len = arguments.length,
        argsForClass = Array(_len > 3 ? _len - 3 : 0),
        _key = 3; _key < _len; _key++) {
      argsForClass[_key - 3] = arguments[_key];
    }
    var store = new (_bind.apply(Store, [null].concat(argsForClass)))();
    if (config.bindListeners)
      store.bindListeners(config.bindListeners);
    if (config.datasource)
      store.registerAsync(config.datasource);
    storeInstance = fn.assign(new _AltStore2['default'](alt, store, typeof store.state === 'object' ? store.state : null, StoreModel), utils.getInternalMethods(StoreModel), config.publicMethods, {displayName: key});
    return storeInstance;
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:buffer@3.4.1", ["npm:buffer@3.4.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:buffer@3.4.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14/lib/dataconnection", ["npm:peerjs@0.3.14/lib/util", "npm:eventemitter3@0.1.6", "npm:peerjs@0.3.14/lib/negotiator", "github:michelle/reliable@master"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var util = require("npm:peerjs@0.3.14/lib/util");
  var EventEmitter = require("npm:eventemitter3@0.1.6");
  var Negotiator = require("npm:peerjs@0.3.14/lib/negotiator");
  var Reliable = require("github:michelle/reliable@master");
  function DataConnection(peer, provider, options) {
    if (!(this instanceof DataConnection))
      return new DataConnection(peer, provider, options);
    EventEmitter.call(this);
    this.options = util.extend({
      serialization: 'binary',
      reliable: false
    }, options);
    this.open = false;
    this.type = 'data';
    this.peer = peer;
    this.provider = provider;
    this.id = this.options.connectionId || DataConnection._idPrefix + util.randomToken();
    this.label = this.options.label || this.id;
    this.metadata = this.options.metadata;
    this.serialization = this.options.serialization;
    this.reliable = this.options.reliable;
    this._buffer = [];
    this._buffering = false;
    this.bufferSize = 0;
    this._chunkedData = {};
    if (this.options._payload) {
      this._peerBrowser = this.options._payload.browser;
    }
    Negotiator.startConnection(this, this.options._payload || {originator: true});
  }
  util.inherits(DataConnection, EventEmitter);
  DataConnection._idPrefix = 'dc_';
  DataConnection.prototype.initialize = function(dc) {
    this._dc = this.dataChannel = dc;
    this._configureDataChannel();
  };
  DataConnection.prototype._configureDataChannel = function() {
    var self = this;
    if (util.supports.sctp) {
      this._dc.binaryType = 'arraybuffer';
    }
    this._dc.onopen = function() {
      util.log('Data channel connection success');
      self.open = true;
      self.emit('open');
    };
    if (!util.supports.sctp && this.reliable) {
      this._reliable = new Reliable(this._dc, util.debug);
    }
    if (this._reliable) {
      this._reliable.onmessage = function(msg) {
        self.emit('data', msg);
      };
    } else {
      this._dc.onmessage = function(e) {
        self._handleDataMessage(e);
      };
    }
    this._dc.onclose = function(e) {
      util.log('DataChannel closed for:', self.peer);
      self.close();
    };
  };
  DataConnection.prototype._handleDataMessage = function(e) {
    var self = this;
    var data = e.data;
    var datatype = data.constructor;
    if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
      if (datatype === Blob) {
        util.blobToArrayBuffer(data, function(ab) {
          data = util.unpack(ab);
          self.emit('data', data);
        });
        return ;
      } else if (datatype === ArrayBuffer) {
        data = util.unpack(data);
      } else if (datatype === String) {
        var ab = util.binaryStringToArrayBuffer(data);
        data = util.unpack(ab);
      }
    } else if (this.serialization === 'json') {
      data = JSON.parse(data);
    }
    if (data.__peerData) {
      var id = data.__peerData;
      var chunkInfo = this._chunkedData[id] || {
        data: [],
        count: 0,
        total: data.total
      };
      chunkInfo.data[data.n] = data.data;
      chunkInfo.count += 1;
      if (chunkInfo.total === chunkInfo.count) {
        delete this._chunkedData[id];
        data = new Blob(chunkInfo.data);
        this._handleDataMessage({data: data});
      }
      this._chunkedData[id] = chunkInfo;
      return ;
    }
    this.emit('data', data);
  };
  DataConnection.prototype.close = function() {
    if (!this.open) {
      return ;
    }
    this.open = false;
    Negotiator.cleanup(this);
    this.emit('close');
  };
  DataConnection.prototype.send = function(data, chunked) {
    if (!this.open) {
      this.emit('error', new Error('Connection is not open. You should listen for the `open` event before sending messages.'));
      return ;
    }
    if (this._reliable) {
      this._reliable.send(data);
      return ;
    }
    var self = this;
    if (this.serialization === 'json') {
      this._bufferedSend(JSON.stringify(data));
    } else if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
      var blob = util.pack(data);
      var needsChunking = util.chunkedBrowsers[this._peerBrowser] || util.chunkedBrowsers[util.browser];
      if (needsChunking && !chunked && blob.size > util.chunkedMTU) {
        this._sendChunks(blob);
        return ;
      }
      if (!util.supports.sctp) {
        util.blobToBinaryString(blob, function(str) {
          self._bufferedSend(str);
        });
      } else if (!util.supports.binaryBlob) {
        util.blobToArrayBuffer(blob, function(ab) {
          self._bufferedSend(ab);
        });
      } else {
        this._bufferedSend(blob);
      }
    } else {
      this._bufferedSend(data);
    }
  };
  DataConnection.prototype._bufferedSend = function(msg) {
    if (this._buffering || !this._trySend(msg)) {
      this._buffer.push(msg);
      this.bufferSize = this._buffer.length;
    }
  };
  DataConnection.prototype._trySend = function(msg) {
    try {
      this._dc.send(msg);
    } catch (e) {
      this._buffering = true;
      var self = this;
      setTimeout(function() {
        self._buffering = false;
        self._tryBuffer();
      }, 100);
      return false;
    }
    return true;
  };
  DataConnection.prototype._tryBuffer = function() {
    if (this._buffer.length === 0) {
      return ;
    }
    var msg = this._buffer[0];
    if (this._trySend(msg)) {
      this._buffer.shift();
      this.bufferSize = this._buffer.length;
      this._tryBuffer();
    }
  };
  DataConnection.prototype._sendChunks = function(blob) {
    var blobs = util.chunk(blob);
    for (var i = 0,
        ii = blobs.length; i < ii; i += 1) {
      var blob = blobs[i];
      this.send(blob, true);
    }
  };
  DataConnection.prototype.handleMessage = function(message) {
    var payload = message.payload;
    switch (message.type) {
      case 'ANSWER':
        this._peerBrowser = payload.browser;
        Negotiator.handleSDP(message.type, this, payload.sdp);
        break;
      case 'CANDIDATE':
        Negotiator.handleCandidate(this, payload.candidate);
        break;
      default:
        util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
        break;
    }
  };
  module.exports = DataConnection;
  global.define = __define;
  return module.exports;
});

System.register("npm:md5@2.0.0", ["npm:md5@2.0.0/md5"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:md5@2.0.0/md5");
  global.define = __define;
  return module.exports;
});

System.register("npm:fbjs@0.1.0-alpha.4/lib/invariant", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (process.env.NODE_ENV !== 'production') {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error('Invariant Violation: ' + format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/DOMChildrenOperations", ["npm:react@0.14.0-beta3/lib/Danger", "npm:react@0.14.0-beta3/lib/ReactMultiChildUpdateTypes", "npm:react@0.14.0-beta3/lib/setInnerHTML", "npm:react@0.14.0-beta3/lib/setTextContent", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var Danger = require("npm:react@0.14.0-beta3/lib/Danger");
    var ReactMultiChildUpdateTypes = require("npm:react@0.14.0-beta3/lib/ReactMultiChildUpdateTypes");
    var setInnerHTML = require("npm:react@0.14.0-beta3/lib/setInnerHTML");
    var setTextContent = require("npm:react@0.14.0-beta3/lib/setTextContent");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    function insertChildAt(parentNode, childNode, index) {
      var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
      parentNode.insertBefore(childNode, beforeChild);
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
      updateTextContent: setTextContent,
      processUpdates: function(updates, markupList) {
        var update;
        var initialChildren = null;
        var updatedChildren = null;
        for (var i = 0; i < updates.length; i++) {
          update = updates[i];
          if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex;
            var updatedChild = update.parentNode.childNodes[updatedIndex];
            var parentID = update.parentID;
            !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
            initialChildren = initialChildren || {};
            initialChildren[parentID] = initialChildren[parentID] || [];
            initialChildren[parentID][updatedIndex] = updatedChild;
            updatedChildren = updatedChildren || [];
            updatedChildren.push(updatedChild);
          }
        }
        var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
        if (updatedChildren) {
          for (var j = 0; j < updatedChildren.length; j++) {
            updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          }
        }
        for (var k = 0; k < updates.length; k++) {
          update = updates[k];
          switch (update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.SET_MARKUP:
              setInnerHTML(update.parentNode, update.content);
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              setTextContent(update.parentNode, update.content);
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactMount", ["npm:react@0.14.0-beta3/lib/DOMProperty", "npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter", "npm:react@0.14.0-beta3/lib/ReactCurrentOwner", "npm:react@0.14.0-beta3/lib/ReactElement", "npm:react@0.14.0-beta3/lib/ReactEmptyComponent", "npm:react@0.14.0-beta3/lib/ReactInstanceHandles", "npm:react@0.14.0-beta3/lib/ReactInstanceMap", "npm:react@0.14.0-beta3/lib/ReactMarkupChecksum", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:react@0.14.0-beta3/lib/ReactReconciler", "npm:react@0.14.0-beta3/lib/ReactUpdateQueue", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:fbjs@0.1.0-alpha.4/lib/emptyObject", "npm:fbjs@0.1.0-alpha.4/lib/containsNode", "npm:react@0.14.0-beta3/lib/instantiateReactComponent", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:react@0.14.0-beta3/lib/setInnerHTML", "npm:react@0.14.0-beta3/lib/shouldUpdateReactComponent", "npm:react@0.14.0-beta3/lib/validateDOMNesting", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMProperty = require("npm:react@0.14.0-beta3/lib/DOMProperty");
    var ReactBrowserEventEmitter = require("npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter");
    var ReactCurrentOwner = require("npm:react@0.14.0-beta3/lib/ReactCurrentOwner");
    var ReactElement = require("npm:react@0.14.0-beta3/lib/ReactElement");
    var ReactEmptyComponent = require("npm:react@0.14.0-beta3/lib/ReactEmptyComponent");
    var ReactInstanceHandles = require("npm:react@0.14.0-beta3/lib/ReactInstanceHandles");
    var ReactInstanceMap = require("npm:react@0.14.0-beta3/lib/ReactInstanceMap");
    var ReactMarkupChecksum = require("npm:react@0.14.0-beta3/lib/ReactMarkupChecksum");
    var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
    var ReactReconciler = require("npm:react@0.14.0-beta3/lib/ReactReconciler");
    var ReactUpdateQueue = require("npm:react@0.14.0-beta3/lib/ReactUpdateQueue");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var emptyObject = require("npm:fbjs@0.1.0-alpha.4/lib/emptyObject");
    var containsNode = require("npm:fbjs@0.1.0-alpha.4/lib/containsNode");
    var instantiateReactComponent = require("npm:react@0.14.0-beta3/lib/instantiateReactComponent");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var setInnerHTML = require("npm:react@0.14.0-beta3/lib/setInnerHTML");
    var shouldUpdateReactComponent = require("npm:react@0.14.0-beta3/lib/shouldUpdateReactComponent");
    var validateDOMNesting = require("npm:react@0.14.0-beta3/lib/validateDOMNesting");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var SEPARATOR = ReactInstanceHandles.SEPARATOR;
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var nodeCache = {};
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var instancesByReactRootID = {};
    var containersByReactRootID = {};
    if (process.env.NODE_ENV !== 'production') {
      var rootElementsByReactRootID = {};
    }
    var findComponentRootReusableArray = [];
    function firstDifferenceIndex(string1, string2) {
      var minLen = Math.min(string1.length, string2.length);
      for (var i = 0; i < minLen; i++) {
        if (string1.charAt(i) !== string2.charAt(i)) {
          return i;
        }
      }
      return string1.length === string2.length ? -1 : minLen;
    }
    function getReactRootElementInContainer(container) {
      if (!container) {
        return null;
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        return container.documentElement;
      } else {
        return container.firstChild;
      }
    }
    function getReactRootID(container) {
      var rootElement = getReactRootElementInContainer(container);
      return rootElement && ReactMount.getID(rootElement);
    }
    function getID(node) {
      var id = internalGetID(node);
      if (id) {
        if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          if (cached !== node) {
            !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
            nodeCache[id] = node;
          }
        } else {
          nodeCache[id] = node;
        }
      }
      return id;
    }
    function internalGetID(node) {
      return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function setID(node, id) {
      var oldID = internalGetID(node);
      if (oldID !== id) {
        delete nodeCache[oldID];
      }
      node.setAttribute(ATTR_NAME, id);
      nodeCache[id] = node;
    }
    function getNode(id) {
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function getNodeFromInstance(instance) {
      var id = ReactInstanceMap.get(instance)._rootNodeID;
      if (ReactEmptyComponent.isNullComponentID(id)) {
        return null;
      }
      if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
        nodeCache[id] = ReactMount.findReactNodeByID(id);
      }
      return nodeCache[id];
    }
    function isValid(node, id) {
      if (node) {
        !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
        var container = ReactMount.findReactContainerForID(id);
        if (container && containsNode(container, node)) {
          return true;
        }
      }
      return false;
    }
    function purgeID(id) {
      delete nodeCache[id];
    }
    var deepestNodeSoFar = null;
    function findDeepestCachedAncestorImpl(ancestorID) {
      var ancestor = nodeCache[ancestorID];
      if (ancestor && isValid(ancestor, ancestorID)) {
        deepestNodeSoFar = ancestor;
      } else {
        return false;
      }
    }
    function findDeepestCachedAncestor(targetID) {
      deepestNodeSoFar = null;
      ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
      var foundNode = deepestNodeSoFar;
      deepestNodeSoFar = null;
      return foundNode;
    }
    function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
      if (process.env.NODE_ENV !== 'production') {
        if (context === emptyObject) {
          context = {};
        }
        var tag = container.nodeName.toLowerCase();
        context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
      }
      var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
      componentInstance._renderedComponent._topLevelWrapper = componentInstance;
      ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);
    }
    function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
      transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    function unmountComponentFromNode(instance, container) {
      ReactReconciler.unmountComponent(instance);
      if (container.nodeType === DOC_NODE_TYPE) {
        container = container.documentElement;
      }
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
    }
    var TopLevelWrapper = function() {};
    TopLevelWrapper.prototype.render = function() {
      return this.props;
    };
    var ReactMount = {
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function(container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function(prevComponent, nextElement, container, callback) {
        ReactMount.scrollMonitor(container, function() {
          ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
          if (callback) {
            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
          }
        });
        if (process.env.NODE_ENV !== 'production') {
          rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
        }
        return prevComponent;
      },
      _registerComponent: function(nextComponent, container) {
        !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var reactRootID = ReactMount.registerContainer(container);
        instancesByReactRootID[reactRootID] = nextComponent;
        return reactRootID;
      },
      _renderNewRootComponent: function(nextElement, container, shouldReuseMarkup, context) {
        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
        var componentInstance = instantiateReactComponent(nextElement, null);
        var reactRootID = ReactMount._registerComponent(componentInstance, container);
        ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
        if (process.env.NODE_ENV !== 'production') {
          rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
        }
        return componentInstance;
      },
      renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
        !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
        return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
      },
      _renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
        !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
        process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
        var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, nextElement);
        var prevComponent = instancesByReactRootID[getReactRootID(container)];
        if (prevComponent) {
          var prevWrappedElement = prevComponent._currentElement;
          var prevElement = prevWrappedElement.props;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            return ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, callback)._renderedComponent.getPublicInstance();
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
        if (process.env.NODE_ENV !== 'production') {
          if (!containerHasReactMarkup || reactRootElement.nextSibling) {
            var rootElementSibling = reactRootElement;
            while (rootElementSibling) {
              if (ReactMount.isRenderedByReact(rootElementSibling)) {
                process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
                break;
              }
              rootElementSibling = rootElementSibling.nextSibling;
            }
          }
        }
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;
        var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
        if (callback) {
          callback.call(component);
        }
        return component;
      },
      render: function(nextElement, container, callback) {
        return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
      },
      registerContainer: function(container) {
        var reactRootID = getReactRootID(container);
        if (reactRootID) {
          reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
        }
        if (!reactRootID) {
          reactRootID = ReactInstanceHandles.createReactRootID();
        }
        containersByReactRootID[reactRootID] = container;
        return reactRootID;
      },
      unmountComponentAtNode: function(container) {
        process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
        !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
        var reactRootID = getReactRootID(container);
        var component = instancesByReactRootID[reactRootID];
        if (!component) {
          return false;
        }
        ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
        delete instancesByReactRootID[reactRootID];
        delete containersByReactRootID[reactRootID];
        if (process.env.NODE_ENV !== 'production') {
          delete rootElementsByReactRootID[reactRootID];
        }
        return true;
      },
      findReactContainerForID: function(id) {
        var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
        var container = containersByReactRootID[reactRootID];
        if (process.env.NODE_ENV !== 'production') {
          var rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            process.env.NODE_ENV !== 'production' ? warning(internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
            var containerChild = container.firstChild;
            if (containerChild && reactRootID === internalGetID(containerChild)) {
              rootElementsByReactRootID[reactRootID] = containerChild;
            } else {
              process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
            }
          }
        }
        return container;
      },
      findReactNodeByID: function(id) {
        var reactRoot = ReactMount.findReactContainerForID(id);
        return ReactMount.findComponentRoot(reactRoot, id);
      },
      isRenderedByReact: function(node) {
        if (node.nodeType !== 1) {
          return false;
        }
        var id = ReactMount.getID(node);
        return id ? id.charAt(0) === SEPARATOR : false;
      },
      getFirstReactDOM: function(node) {
        var current = node;
        while (current && current.parentNode !== current) {
          if (ReactMount.isRenderedByReact(current)) {
            return current;
          }
          current = current.parentNode;
        }
        return null;
      },
      findComponentRoot: function(ancestorNode, targetID) {
        var firstChildren = findComponentRootReusableArray;
        var childIndex = 0;
        var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
        firstChildren[0] = deepestAncestor.firstChild;
        firstChildren.length = 1;
        while (childIndex < firstChildren.length) {
          var child = firstChildren[childIndex++];
          var targetChild;
          while (child) {
            var childID = ReactMount.getID(child);
            if (childID) {
              if (targetID === childID) {
                targetChild = child;
              } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
                firstChildren.length = childIndex = 0;
                firstChildren.push(child.firstChild);
              }
            } else {
              firstChildren.push(child.firstChild);
            }
            child = child.nextSibling;
          }
          if (targetChild) {
            firstChildren.length = 0;
            return targetChild;
          }
        }
        firstChildren.length = 0;
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
      },
      _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {
        !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
        if (shouldReuseMarkup) {
          var rootElement = getReactRootElementInContainer(container);
          if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
            return ;
          } else {
            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            var rootMarkup = rootElement.outerHTML;
            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
            var normalizedMarkup = markup;
            if (process.env.NODE_ENV !== 'production') {
              var normalizer;
              if (container.nodeType === ELEMENT_NODE_TYPE) {
                normalizer = document.createElement('div');
                normalizer.innerHTML = markup;
                normalizedMarkup = normalizer.innerHTML;
              } else {
                normalizer = document.createElement('iframe');
                document.body.appendChild(normalizer);
                normalizer.contentDocument.write(markup);
                normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
                document.body.removeChild(normalizer);
              }
            }
            var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
            var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
            !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
            if (process.env.NODE_ENV !== 'production') {
              process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
            }
          }
        }
        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See React.renderToString() for server rendering.') : invariant(false) : undefined;
        setInnerHTML(container, markup);
      },
      getReactRootID: getReactRootID,
      getID: getID,
      setID: setID,
      getNode: getNode,
      getNodeFromInstance: getNodeFromInstance,
      purgeID: purgeID
    };
    ReactPerf.measureMethods(ReactMount, 'ReactMount', {
      _renderNewRootComponent: '_renderNewRootComponent',
      _mountImageIntoNode: '_mountImageIntoNode'
    });
    module.exports = ReactMount;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMComponent", ["npm:react@0.14.0-beta3/lib/AutoFocusUtils", "npm:react@0.14.0-beta3/lib/CSSPropertyOperations", "npm:react@0.14.0-beta3/lib/DOMProperty", "npm:react@0.14.0-beta3/lib/DOMPropertyOperations", "npm:react@0.14.0-beta3/lib/EventConstants", "npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter", "npm:react@0.14.0-beta3/lib/ReactComponentBrowserEnvironment", "npm:react@0.14.0-beta3/lib/ReactDOMButton", "npm:react@0.14.0-beta3/lib/ReactDOMInput", "npm:react@0.14.0-beta3/lib/ReactDOMOption", "npm:react@0.14.0-beta3/lib/ReactDOMSelect", "npm:react@0.14.0-beta3/lib/ReactDOMTextarea", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactMultiChild", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:react@0.14.0-beta3/lib/ReactUpdateQueue", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "npm:react@0.14.0-beta3/lib/isEventSupported", "npm:fbjs@0.1.0-alpha.4/lib/keyOf", "npm:fbjs@0.1.0-alpha.4/lib/shallowEqual", "npm:react@0.14.0-beta3/lib/validateDOMNesting", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var AutoFocusUtils = require("npm:react@0.14.0-beta3/lib/AutoFocusUtils");
    var CSSPropertyOperations = require("npm:react@0.14.0-beta3/lib/CSSPropertyOperations");
    var DOMProperty = require("npm:react@0.14.0-beta3/lib/DOMProperty");
    var DOMPropertyOperations = require("npm:react@0.14.0-beta3/lib/DOMPropertyOperations");
    var EventConstants = require("npm:react@0.14.0-beta3/lib/EventConstants");
    var ReactBrowserEventEmitter = require("npm:react@0.14.0-beta3/lib/ReactBrowserEventEmitter");
    var ReactComponentBrowserEnvironment = require("npm:react@0.14.0-beta3/lib/ReactComponentBrowserEnvironment");
    var ReactDOMButton = require("npm:react@0.14.0-beta3/lib/ReactDOMButton");
    var ReactDOMInput = require("npm:react@0.14.0-beta3/lib/ReactDOMInput");
    var ReactDOMOption = require("npm:react@0.14.0-beta3/lib/ReactDOMOption");
    var ReactDOMSelect = require("npm:react@0.14.0-beta3/lib/ReactDOMSelect");
    var ReactDOMTextarea = require("npm:react@0.14.0-beta3/lib/ReactDOMTextarea");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactMultiChild = require("npm:react@0.14.0-beta3/lib/ReactMultiChild");
    var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
    var ReactUpdateQueue = require("npm:react@0.14.0-beta3/lib/ReactUpdateQueue");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var escapeTextContentForBrowser = require("npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var isEventSupported = require("npm:react@0.14.0-beta3/lib/isEventSupported");
    var keyOf = require("npm:fbjs@0.1.0-alpha.4/lib/keyOf");
    var shallowEqual = require("npm:fbjs@0.1.0-alpha.4/lib/shallowEqual");
    var validateDOMNesting = require("npm:react@0.14.0-beta3/lib/validateDOMNesting");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var deleteListener = ReactBrowserEventEmitter.deleteListener;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
    var CONTENT_TYPES = {
      'string': true,
      'number': true
    };
    var STYLE = keyOf({style: null});
    var ELEMENT_NODE_TYPE = 1;
    var canDefineProperty = false;
    try {
      Object.defineProperty({}, 'test', {get: function() {}});
      canDefineProperty = true;
    } catch (e) {}
    function getDeclarationErrorAddendum(internalInstance) {
      if (internalInstance) {
        var owner = internalInstance._currentElement._owner || null;
        if (owner) {
          var name = owner.getName();
          if (name) {
            return ' This DOM node was rendered by `' + name + '`.';
          }
        }
      }
      return '';
    }
    var legacyPropsDescriptor;
    if (process.env.NODE_ENV !== 'production') {
      legacyPropsDescriptor = {props: {
          enumerable: false,
          get: function() {
            var component = this._reactInternalComponent;
            process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
            return component._currentElement.props;
          }
        }};
    }
    function legacyGetDOMNode() {
      if (process.env.NODE_ENV !== 'production') {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      return this;
    }
    function legacyIsMounted() {
      var component = this._reactInternalComponent;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      return !!component;
    }
    function legacySetStateEtc() {
      if (process.env.NODE_ENV !== 'production') {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
    }
    function legacySetProps(partialProps, callback) {
      var component = this._reactInternalComponent;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call React.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      if (!component) {
        return ;
      }
      ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(component, callback);
      }
    }
    function legacyReplaceProps(partialProps, callback) {
      var component = this._reactInternalComponent;
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call React.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
      }
      if (!component) {
        return ;
      }
      ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(component, callback);
      }
    }
    var styleMutationWarning = {};
    function checkAndWarnForMutatedStyle(style1, style2, component) {
      if (style1 == null || style2 == null) {
        return ;
      }
      if (shallowEqual(style1, style2)) {
        return ;
      }
      var componentName = component._tag;
      var owner = component._currentElement._owner;
      var ownerName;
      if (owner) {
        ownerName = owner.getName();
      }
      var hash = ownerName + '|' + componentName;
      if (styleMutationWarning.hasOwnProperty(hash)) {
        return ;
      }
      styleMutationWarning[hash] = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', JSON.stringify(style1), JSON.stringify(style2)) : undefined;
    }
    var BackendIDOperations = null;
    function assertValidProps(component, props) {
      if (!props) {
        return ;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (voidElementTags[component._tag]) {
          process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
        }
      }
      if (props.dangerouslySetInnerHTML != null) {
        !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
        !(typeof props.dangerouslySetInnerHTML === 'object' && '__html' in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
      }
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
        process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
      }
      !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.') : invariant(false) : undefined;
    }
    function enqueuePutListener(id, registrationName, listener, transaction) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
      }
      var container = ReactMount.findReactContainerForID(id);
      if (container) {
        var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
        listenTo(registrationName, doc);
      }
      transaction.getReactMountReady().enqueue(putListener, {
        id: id,
        registrationName: registrationName,
        listener: listener
      });
    }
    function putListener() {
      var listenerToPut = this;
      ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
    }
    var mediaEvents = {
      topAbort: 'abort',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topPause: 'pause',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topSeeked: 'seeked',
      topSeeking: 'seeking',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTimeUpdate: 'timeupdate',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting'
    };
    function trapBubbledEventsLocal() {
      var inst = this;
      !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
      var node = ReactMount.getNode(inst._rootNodeID);
      !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
      switch (inst._tag) {
        case 'iframe':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
          break;
        case 'video':
        case 'audio':
          inst._wrapperState.listeners = [];
          for (var event in mediaEvents) {
            if (mediaEvents.hasOwnProperty(event)) {
              inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
            }
          }
          break;
        case 'img':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
          break;
        case 'form':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
          break;
      }
    }
    function postUpdateSelectWrapper() {
      ReactDOMSelect.postUpdateWrapper(this);
    }
    var omittedCloseTags = {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'embed': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true
    };
    var newlineEatingTags = {
      'listing': true,
      'pre': true,
      'textarea': true
    };
    var voidElementTags = assign({'menuitem': true}, omittedCloseTags);
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = ({}).hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
        validatedTagCache[tag] = true;
      }
    }
    function processChildContext(context, inst) {
      if (process.env.NODE_ENV !== 'production') {
        context = assign({}, context);
        var info = context[validateDOMNesting.ancestorInfoContextKey];
        context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
      }
      return context;
    }
    function isCustomComponent(tagName, props) {
      return tagName.indexOf('-') >= 0 || props.is != null;
    }
    function ReactDOMComponent(tag) {
      validateDangerousTag(tag);
      this._tag = tag.toLowerCase();
      this._renderedChildren = null;
      this._previousStyle = null;
      this._previousStyleCopy = null;
      this._rootNodeID = null;
      this._wrapperState = null;
      this._topLevelWrapper = null;
      this._nodeWithLegacyProperties = null;
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      construct: function(element) {
        this._currentElement = element;
      },
      mountComponent: function(rootID, transaction, context) {
        this._rootNodeID = rootID;
        var props = this._currentElement.props;
        switch (this._tag) {
          case 'iframe':
          case 'img':
          case 'form':
          case 'video':
          case 'audio':
            this._wrapperState = {listeners: null};
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'button':
            props = ReactDOMButton.getNativeProps(this, props, context);
            break;
          case 'input':
            ReactDOMInput.mountWrapper(this, props, context);
            props = ReactDOMInput.getNativeProps(this, props, context);
            break;
          case 'option':
            ReactDOMOption.mountWrapper(this, props, context);
            props = ReactDOMOption.getNativeProps(this, props, context);
            break;
          case 'select':
            ReactDOMSelect.mountWrapper(this, props, context);
            props = ReactDOMSelect.getNativeProps(this, props, context);
            context = ReactDOMSelect.processChildContext(this, props, context);
            break;
          case 'textarea':
            ReactDOMTextarea.mountWrapper(this, props, context);
            props = ReactDOMTextarea.getNativeProps(this, props, context);
            break;
        }
        assertValidProps(this, props);
        if (process.env.NODE_ENV !== 'production') {
          if (context[validateDOMNesting.ancestorInfoContextKey]) {
            validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
          }
        }
        var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
        var tagContent = this._createContentMarkup(transaction, props, context);
        switch (this._tag) {
          case 'button':
          case 'input':
          case 'select':
          case 'textarea':
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
        }
        if (!tagContent && omittedCloseTags[this._tag]) {
          return tagOpen + '/>';
        }
        return tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      },
      _createOpenTagMarkupAndPutListeners: function(transaction, props) {
        var ret = '<' + this._currentElement.type;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                if (process.env.NODE_ENV !== 'production') {
                  this._previousStyle = propValue;
                }
                propValue = this._previousStyleCopy = assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
            }
            var markup = null;
            if (this._tag != null && isCustomComponent(this._tag, props)) {
              markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
            } else {
              markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret;
        }
        var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
        return ret + ' ' + markupForID;
      },
      _createContentMarkup: function(transaction, props, context) {
        var ret = '';
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            ret = innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            ret = escapeTextContentForBrowser(contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, processChildContext(context, this));
            ret = mountImages.join('');
          }
        }
        if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
          return '\n' + ret;
        } else {
          return ret;
        }
      },
      receiveComponent: function(nextElement, transaction, context) {
        var prevElement = this._currentElement;
        this._currentElement = nextElement;
        this.updateComponent(transaction, prevElement, nextElement, context);
      },
      updateComponent: function(transaction, prevElement, nextElement, context) {
        var lastProps = prevElement.props;
        var nextProps = this._currentElement.props;
        switch (this._tag) {
          case 'button':
            lastProps = ReactDOMButton.getNativeProps(this, lastProps);
            nextProps = ReactDOMButton.getNativeProps(this, nextProps);
            break;
          case 'input':
            ReactDOMInput.updateWrapper(this);
            lastProps = ReactDOMInput.getNativeProps(this, lastProps);
            nextProps = ReactDOMInput.getNativeProps(this, nextProps);
            break;
          case 'option':
            lastProps = ReactDOMOption.getNativeProps(this, lastProps);
            nextProps = ReactDOMOption.getNativeProps(this, nextProps);
            break;
          case 'select':
            lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
            nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
            break;
          case 'textarea':
            ReactDOMTextarea.updateWrapper(this);
            lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
            nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
            break;
        }
        assertValidProps(this, nextProps);
        this._updateDOMProperties(lastProps, nextProps, transaction);
        this._updateDOMChildren(lastProps, nextProps, transaction, processChildContext(context, this));
        if (!canDefineProperty && this._nodeWithLegacyProperties) {
          this._nodeWithLegacyProperties.props = nextProps;
        }
        if (this._tag === 'select') {
          transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        }
      },
      _updateDOMProperties: function(lastProps, nextProps, transaction) {
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = this._previousStyleCopy;
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
            this._previousStyleCopy = null;
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (lastProps[propKey]) {
              deleteListener(this._rootNodeID, propKey);
            }
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              if (process.env.NODE_ENV !== 'production') {
                checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
                this._previousStyle = nextProp;
              }
              nextProp = this._previousStyleCopy = assign({}, nextProp);
            } else {
              this._previousStyleCopy = null;
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (nextProp) {
              enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
            } else if (lastProp) {
              deleteListener(this._rootNodeID, propKey);
            }
          } else if (isCustomComponent(this._tag, nextProps)) {
            BackendIDOperations.updateAttributeByID(this._rootNodeID, propKey, nextProp);
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp);
          }
        }
        if (styleUpdates) {
          BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates);
        }
      },
      _updateDOMChildren: function(lastProps, nextProps, transaction, context) {
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction, context);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            this.updateMarkup('' + nextHtml);
          }
        } else if (nextChildren != null) {
          this.updateChildren(nextChildren, transaction, context);
        }
      },
      unmountComponent: function() {
        switch (this._tag) {
          case 'iframe':
          case 'img':
          case 'form':
          case 'video':
          case 'audio':
            var listeners = this._wrapperState.listeners;
            if (listeners) {
              for (var i = 0; i < listeners.length; i++) {
                listeners[i].remove();
              }
            }
            break;
          case 'input':
            ReactDOMInput.unmountWrapper(this);
            break;
          case 'html':
          case 'head':
          case 'body':
            !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
            break;
        }
        this.unmountChildren();
        ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
        ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
        this._rootNodeID = null;
        this._wrapperState = null;
        if (this._nodeWithLegacyProperties) {
          var node = this._nodeWithLegacyProperties;
          node._reactInternalComponent = null;
          this._nodeWithLegacyProperties = null;
        }
      },
      getPublicInstance: function() {
        if (!this._nodeWithLegacyProperties) {
          var node = ReactMount.getNode(this._rootNodeID);
          node._reactInternalComponent = this;
          node.getDOMNode = legacyGetDOMNode;
          node.isMounted = legacyIsMounted;
          node.setState = legacySetStateEtc;
          node.replaceState = legacySetStateEtc;
          node.forceUpdate = legacySetStateEtc;
          node.setProps = legacySetProps;
          node.replaceProps = legacyReplaceProps;
          if (process.env.NODE_ENV !== 'production') {
            if (canDefineProperty) {
              Object.defineProperties(node, legacyPropsDescriptor);
            } else {
              node.props = this._currentElement.props;
            }
          } else {
            node.props = this._currentElement.props;
          }
          this._nodeWithLegacyProperties = node;
        }
        return this._nodeWithLegacyProperties;
      }
    };
    ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
      mountComponent: 'mountComponent',
      updateComponent: 'updateComponent'
    });
    assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
    ReactDOMComponent.injection = {injectIDOperations: function(IDOperations) {
        ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations;
      }};
    module.exports = ReactDOMComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDefaultInjection", ["npm:react@0.14.0-beta3/lib/BeforeInputEventPlugin", "npm:react@0.14.0-beta3/lib/ChangeEventPlugin", "npm:react@0.14.0-beta3/lib/ClientReactRootIndex", "npm:react@0.14.0-beta3/lib/DefaultEventPluginOrder", "npm:react@0.14.0-beta3/lib/EnterLeaveEventPlugin", "npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "npm:react@0.14.0-beta3/lib/HTMLDOMPropertyConfig", "npm:react@0.14.0-beta3/lib/ReactBrowserComponentMixin", "npm:react@0.14.0-beta3/lib/ReactComponentBrowserEnvironment", "npm:react@0.14.0-beta3/lib/ReactDefaultBatchingStrategy", "npm:react@0.14.0-beta3/lib/ReactDOMComponent", "npm:react@0.14.0-beta3/lib/ReactDOMIDOperations", "npm:react@0.14.0-beta3/lib/ReactDOMTextComponent", "npm:react@0.14.0-beta3/lib/ReactEventListener", "npm:react@0.14.0-beta3/lib/ReactInjection", "npm:react@0.14.0-beta3/lib/ReactInstanceHandles", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactReconcileTransaction", "npm:react@0.14.0-beta3/lib/SelectEventPlugin", "npm:react@0.14.0-beta3/lib/ServerReactRootIndex", "npm:react@0.14.0-beta3/lib/SimpleEventPlugin", "npm:react@0.14.0-beta3/lib/SVGDOMPropertyConfig", "npm:react@0.14.0-beta3/lib/ReactDefaultPerf", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var BeforeInputEventPlugin = require("npm:react@0.14.0-beta3/lib/BeforeInputEventPlugin");
    var ChangeEventPlugin = require("npm:react@0.14.0-beta3/lib/ChangeEventPlugin");
    var ClientReactRootIndex = require("npm:react@0.14.0-beta3/lib/ClientReactRootIndex");
    var DefaultEventPluginOrder = require("npm:react@0.14.0-beta3/lib/DefaultEventPluginOrder");
    var EnterLeaveEventPlugin = require("npm:react@0.14.0-beta3/lib/EnterLeaveEventPlugin");
    var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
    var HTMLDOMPropertyConfig = require("npm:react@0.14.0-beta3/lib/HTMLDOMPropertyConfig");
    var ReactBrowserComponentMixin = require("npm:react@0.14.0-beta3/lib/ReactBrowserComponentMixin");
    var ReactComponentBrowserEnvironment = require("npm:react@0.14.0-beta3/lib/ReactComponentBrowserEnvironment");
    var ReactDefaultBatchingStrategy = require("npm:react@0.14.0-beta3/lib/ReactDefaultBatchingStrategy");
    var ReactDOMComponent = require("npm:react@0.14.0-beta3/lib/ReactDOMComponent");
    var ReactDOMIDOperations = require("npm:react@0.14.0-beta3/lib/ReactDOMIDOperations");
    var ReactDOMTextComponent = require("npm:react@0.14.0-beta3/lib/ReactDOMTextComponent");
    var ReactEventListener = require("npm:react@0.14.0-beta3/lib/ReactEventListener");
    var ReactInjection = require("npm:react@0.14.0-beta3/lib/ReactInjection");
    var ReactInstanceHandles = require("npm:react@0.14.0-beta3/lib/ReactInstanceHandles");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactReconcileTransaction = require("npm:react@0.14.0-beta3/lib/ReactReconcileTransaction");
    var SelectEventPlugin = require("npm:react@0.14.0-beta3/lib/SelectEventPlugin");
    var ServerReactRootIndex = require("npm:react@0.14.0-beta3/lib/ServerReactRootIndex");
    var SimpleEventPlugin = require("npm:react@0.14.0-beta3/lib/SimpleEventPlugin");
    var SVGDOMPropertyConfig = require("npm:react@0.14.0-beta3/lib/SVGDOMPropertyConfig");
    var alreadyInjected = false;
    function inject() {
      if (alreadyInjected) {
        return ;
      }
      alreadyInjected = true;
      ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
      ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
      ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
      ReactInjection.EventPluginHub.injectMount(ReactMount);
      ReactInjection.EventPluginHub.injectEventPluginsByName({
        SimpleEventPlugin: SimpleEventPlugin,
        EnterLeaveEventPlugin: EnterLeaveEventPlugin,
        ChangeEventPlugin: ChangeEventPlugin,
        SelectEventPlugin: SelectEventPlugin,
        BeforeInputEventPlugin: BeforeInputEventPlugin
      });
      ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
      ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
      ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
      ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
      ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
      ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
      ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
      ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
      ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
      ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);
      if (process.env.NODE_ENV !== 'production') {
        var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
        if (/[?&]react_perf\b/.test(url)) {
          var ReactDefaultPerf = require("npm:react@0.14.0-beta3/lib/ReactDefaultPerf");
          ReactDefaultPerf.start();
        }
      }
    }
    module.exports = {inject: inject};
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/helpers/get", ["npm:babel-runtime@5.8.20/core-js/object/get-own-property-descriptor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$getOwnPropertyDescriptor = require("npm:babel-runtime@5.8.20/core-js/object/get-own-property-descriptor")["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/core-js/object/set-prototype-of", ["npm:core-js@0.9.18/library/fn/object/set-prototype-of"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.18/library/fn/object/set-prototype-of"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib/index", ["npm:flux@2.0.3", "npm:alt@0.17.1/lib/utils/StateFunctions", "npm:alt@0.17.1/utils/functions", "npm:alt@0.17.1/lib/store/index", "npm:alt@0.17.1/lib/utils/AltUtils", "npm:alt@0.17.1/lib/actions/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, '__esModule', {value: true});
  var _bind = Function.prototype.bind;
  var _get = function get(_x3, _x4, _x5) {
    var _again = true;
    _function: while (_again) {
      var object = _x3,
          property = _x4,
          receiver = _x5;
      desc = parent = getter = undefined;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x3 = parent;
          _x4 = property;
          _x5 = receiver;
          _again = true;
          continue _function;
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {'default': obj};
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj['default'] = obj;
      return newObj;
    }
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++)
        arr2[i] = arr[i];
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var _flux = require("npm:flux@2.0.3");
  var _utilsStateFunctions = require("npm:alt@0.17.1/lib/utils/StateFunctions");
  var StateFunctions = _interopRequireWildcard(_utilsStateFunctions);
  var _utilsFunctions = require("npm:alt@0.17.1/utils/functions");
  var fn = _interopRequireWildcard(_utilsFunctions);
  var _store = require("npm:alt@0.17.1/lib/store/index");
  var store = _interopRequireWildcard(_store);
  var _utilsAltUtils = require("npm:alt@0.17.1/lib/utils/AltUtils");
  var utils = _interopRequireWildcard(_utilsAltUtils);
  var _actions = require("npm:alt@0.17.1/lib/actions/index");
  var _actions2 = _interopRequireDefault(_actions);
  var Alt = (function() {
    function Alt() {
      var config = arguments[0] === undefined ? {} : arguments[0];
      _classCallCheck(this, Alt);
      this.config = config;
      this.serialize = config.serialize || JSON.stringify;
      this.deserialize = config.deserialize || JSON.parse;
      this.dispatcher = config.dispatcher || new _flux.Dispatcher();
      this.batchingFunction = config.batchingFunction || function(callback) {
        return callback();
      };
      this.actions = {global: {}};
      this.stores = {};
      this.storeTransforms = config.storeTransforms || [];
      this.trapAsync = false;
      this._actionsRegistry = {};
      this._initSnapshot = {};
      this._lastSnapshot = {};
    }
    _createClass(Alt, [{
      key: 'dispatch',
      value: function dispatch(action, data, details) {
        var _this = this;
        this.batchingFunction(function() {
          var id = Math.random().toString(18).substr(2, 16);
          return _this.dispatcher.dispatch({
            id: id,
            action: action,
            data: data,
            details: details
          });
        });
      }
    }, {
      key: 'createUnsavedStore',
      value: function createUnsavedStore(StoreModel) {
        var key = StoreModel.displayName || '';
        store.createStoreConfig(this.config, StoreModel);
        var Store = store.transformStore(this.storeTransforms, StoreModel);
        for (var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return fn.isFunction(Store) ? store.createStoreFromClass.apply(store, [this, Store, key].concat(args)) : store.createStoreFromObject(this, Store, key);
      }
    }, {
      key: 'createStore',
      value: function createStore(StoreModel, iden) {
        var key = iden || StoreModel.displayName || StoreModel.name || '';
        store.createStoreConfig(this.config, StoreModel);
        var Store = store.transformStore(this.storeTransforms, StoreModel);
        if (this.stores[key] || !key) {
          if (this.stores[key]) {
            utils.warn('A store named ' + key + ' already exists, double check your store ' + 'names or pass in your own custom identifier for each store');
          } else {
            utils.warn('Store name was not specified');
          }
          key = utils.uid(this.stores, key);
        }
        for (var _len2 = arguments.length,
            args = Array(_len2 > 2 ? _len2 - 2 : 0),
            _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }
        var storeInstance = fn.isFunction(Store) ? store.createStoreFromClass.apply(store, [this, Store, key].concat(args)) : store.createStoreFromObject(this, Store, key);
        this.stores[key] = storeInstance;
        StateFunctions.saveInitialSnapshot(this, key);
        return storeInstance;
      }
    }, {
      key: 'generateActions',
      value: function generateActions() {
        var actions = {name: 'global'};
        for (var _len3 = arguments.length,
            actionNames = Array(_len3),
            _key3 = 0; _key3 < _len3; _key3++) {
          actionNames[_key3] = arguments[_key3];
        }
        return this.createActions(actionNames.reduce(function(obj, action) {
          obj[action] = utils.dispatchIdentity;
          return obj;
        }, actions));
      }
    }, {
      key: 'createAction',
      value: function createAction(name, implementation, obj) {
        return (0, _actions2['default'])(this, 'global', name, implementation, obj);
      }
    }, {
      key: 'createActions',
      value: function createActions(ActionsClass) {
        var _arguments2 = arguments,
            _this2 = this;
        var exportObj = arguments[1] === undefined ? {} : arguments[1];
        var actions = {};
        var key = utils.uid(this._actionsRegistry, ActionsClass.displayName || ActionsClass.name || 'Unknown');
        if (fn.isFunction(ActionsClass)) {
          var _len4,
              argsForConstructor,
              _key4;
          (function() {
            fn.assign(actions, utils.getInternalMethods(ActionsClass, true));
            var ActionsGenerator = (function(_ActionsClass) {
              function ActionsGenerator() {
                _classCallCheck(this, ActionsGenerator);
                for (var _len5 = arguments.length,
                    args = Array(_len5),
                    _key5 = 0; _key5 < _len5; _key5++) {
                  args[_key5] = arguments[_key5];
                }
                _get(Object.getPrototypeOf(ActionsGenerator.prototype), 'constructor', this).apply(this, args);
              }
              _inherits(ActionsGenerator, _ActionsClass);
              _createClass(ActionsGenerator, [{
                key: 'generateActions',
                value: function generateActions() {
                  for (var _len6 = arguments.length,
                      actionNames = Array(_len6),
                      _key6 = 0; _key6 < _len6; _key6++) {
                    actionNames[_key6] = arguments[_key6];
                  }
                  actionNames.forEach(function(actionName) {
                    actions[actionName] = utils.dispatchIdentity;
                  });
                }
              }]);
              return ActionsGenerator;
            })(ActionsClass);
            for (_len4 = _arguments2.length, argsForConstructor = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
              argsForConstructor[_key4 - 2] = _arguments2[_key4];
            }
            fn.assign(actions, new (_bind.apply(ActionsGenerator, [null].concat(_toConsumableArray(argsForConstructor))))());
          })();
        } else {
          fn.assign(actions, ActionsClass);
        }
        this.actions[key] = this.actions[key] || {};
        fn.eachObject(function(actionName, action) {
          if (!fn.isFunction(action)) {
            return ;
          }
          exportObj[actionName] = (0, _actions2['default'])(_this2, key, actionName, action, exportObj);
          var constant = utils.formatAsConstant(actionName);
          exportObj[constant] = exportObj[actionName].id;
        }, [actions]);
        return exportObj;
      }
    }, {
      key: 'takeSnapshot',
      value: function takeSnapshot() {
        for (var _len7 = arguments.length,
            storeNames = Array(_len7),
            _key7 = 0; _key7 < _len7; _key7++) {
          storeNames[_key7] = arguments[_key7];
        }
        var state = StateFunctions.snapshot(this, storeNames);
        fn.assign(this._lastSnapshot, state);
        return this.serialize(state);
      }
    }, {
      key: 'rollback',
      value: function rollback() {
        StateFunctions.setAppState(this, this.serialize(this._lastSnapshot), function(storeInst) {
          storeInst.lifecycle('rollback');
          storeInst.emitChange();
        });
      }
    }, {
      key: 'recycle',
      value: function recycle() {
        for (var _len8 = arguments.length,
            storeNames = Array(_len8),
            _key8 = 0; _key8 < _len8; _key8++) {
          storeNames[_key8] = arguments[_key8];
        }
        var initialSnapshot = storeNames.length ? StateFunctions.filterSnapshots(this, this._initSnapshot, storeNames) : this._initSnapshot;
        StateFunctions.setAppState(this, this.serialize(initialSnapshot), function(storeInst) {
          storeInst.lifecycle('init');
          storeInst.emitChange();
        });
      }
    }, {
      key: 'flush',
      value: function flush() {
        var state = this.serialize(StateFunctions.snapshot(this));
        this.recycle();
        return state;
      }
    }, {
      key: 'bootstrap',
      value: function bootstrap(data) {
        StateFunctions.setAppState(this, data, function(storeInst) {
          storeInst.lifecycle('bootstrap');
          storeInst.emitChange();
        });
      }
    }, {
      key: 'prepare',
      value: function prepare(storeInst, payload) {
        var data = {};
        if (!storeInst.displayName) {
          throw new ReferenceError('Store provided does not have a name');
        }
        data[storeInst.displayName] = payload;
        return this.serialize(data);
      }
    }, {
      key: 'addActions',
      value: function addActions(name, ActionsClass) {
        for (var _len9 = arguments.length,
            args = Array(_len9 > 2 ? _len9 - 2 : 0),
            _key9 = 2; _key9 < _len9; _key9++) {
          args[_key9 - 2] = arguments[_key9];
        }
        this.actions[name] = Array.isArray(ActionsClass) ? this.generateActions.apply(this, ActionsClass) : this.createActions.apply(this, [ActionsClass].concat(args));
      }
    }, {
      key: 'addStore',
      value: function addStore(name, StoreModel) {
        for (var _len10 = arguments.length,
            args = Array(_len10 > 2 ? _len10 - 2 : 0),
            _key10 = 2; _key10 < _len10; _key10++) {
          args[_key10 - 2] = arguments[_key10];
        }
        this.createStore.apply(this, [StoreModel, name].concat(args));
      }
    }, {
      key: 'getActions',
      value: function getActions(name) {
        return this.actions[name];
      }
    }, {
      key: 'getStore',
      value: function getStore(name) {
        return this.stores[name];
      }
    }], [{
      key: 'debug',
      value: function debug(name, alt) {
        var key = 'alt.js.org';
        if (typeof window !== 'undefined') {
          window[key] = window[key] || [];
          window[key].push({
            name: name,
            alt: alt
          });
        }
        return alt;
      }
    }]);
    return Alt;
  })();
  exports['default'] = Alt;
  module.exports = exports['default'];
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-buffer@0.1.0/index", ["npm:buffer@3.4.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : require("npm:buffer@3.4.1");
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/DOMProperty", ["npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_ATTRIBUTE: 0x1,
      MUST_USE_PROPERTY: 0x2,
      HAS_SIDE_EFFECTS: 0x4,
      HAS_BOOLEAN_VALUE: 0x8,
      HAS_NUMERIC_VALUE: 0x10,
      HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
      injectDOMPropertyConfig: function(domPropertyConfig) {
        var Injection = DOMPropertyInjection;
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
          var lowerCased = propName.toLowerCase();
          var propConfig = Properties[propName];
          var propertyInfo = {
            attributeName: lowerCased,
            attributeNamespace: null,
            propertyName: propName,
            mutationMethod: null,
            mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
            hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
            hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
            hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
          };
          !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
          !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
          !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
          if (process.env.NODE_ENV !== 'production') {
            DOMProperty.getPossibleStandardName[lowerCased] = propName;
          }
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            propertyInfo.attributeName = attributeName;
            if (process.env.NODE_ENV !== 'production') {
              DOMProperty.getPossibleStandardName[attributeName] = propName;
            }
          }
          if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
          }
          if (DOMPropertyNames.hasOwnProperty(propName)) {
            propertyInfo.propertyName = DOMPropertyNames[propName];
          }
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            propertyInfo.mutationMethod = DOMMutationMethods[propName];
          }
          DOMProperty.properties[propName] = propertyInfo;
        }
      }
    };
    var defaultValueCache = {};
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      properties: {},
      getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function(attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      getDefaultValueForProperty: function(nodeName, prop) {
        var nodeDefaults = defaultValueCache[nodeName];
        var testElement;
        if (!nodeDefaults) {
          defaultValueCache[nodeName] = nodeDefaults = {};
        }
        if (!(prop in nodeDefaults)) {
          testElement = document.createElement(nodeName);
          nodeDefaults[prop] = testElement[prop];
        }
        return nodeDefaults[prop];
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMIDOperations", ["npm:react@0.14.0-beta3/lib/CSSPropertyOperations", "npm:react@0.14.0-beta3/lib/DOMChildrenOperations", "npm:react@0.14.0-beta3/lib/DOMPropertyOperations", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:fbjs@0.1.0-alpha.4/lib/invariant", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var CSSPropertyOperations = require("npm:react@0.14.0-beta3/lib/CSSPropertyOperations");
    var DOMChildrenOperations = require("npm:react@0.14.0-beta3/lib/DOMChildrenOperations");
    var DOMPropertyOperations = require("npm:react@0.14.0-beta3/lib/DOMPropertyOperations");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
    var invariant = require("npm:fbjs@0.1.0-alpha.4/lib/invariant");
    var INVALID_PROPERTY_ERRORS = {
      dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
      style: '`style` must be set using `updateStylesByID()`.'
    };
    var ReactDOMIDOperations = {
      updatePropertyByID: function(id, name, value) {
        var node = ReactMount.getNode(id);
        !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
        if (value != null) {
          DOMPropertyOperations.setValueForProperty(node, name, value);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, name);
        }
      },
      updateAttributeByID: function(id, name, value) {
        var node = ReactMount.getNode(id);
        !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
        DOMPropertyOperations.setValueForAttribute(node, name, value);
      },
      deletePropertyByID: function(id, name, value) {
        var node = ReactMount.getNode(id);
        !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
        DOMPropertyOperations.deleteValueForProperty(node, name, value);
      },
      updateStylesByID: function(id, styles) {
        var node = ReactMount.getNode(id);
        CSSPropertyOperations.setValueForStyles(node, styles);
      },
      updateTextContentByID: function(id, content) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.updateTextContent(node, content);
      },
      dangerouslyReplaceNodeWithMarkupByID: function(id, markup) {
        var node = ReactMount.getNode(id);
        DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
      },
      dangerouslyProcessChildrenUpdates: function(updates, markup) {
        for (var i = 0; i < updates.length; i++) {
          updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
        }
        DOMChildrenOperations.processUpdates(updates, markup);
      }
    };
    ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
      updatePropertyByID: 'updatePropertyByID',
      deletePropertyByID: 'deletePropertyByID',
      updateStylesByID: 'updateStylesByID',
      updateTextContentByID: 'updateTextContentByID',
      dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
      dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
    });
    module.exports = ReactDOMIDOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.8.20/helpers/inherits", ["npm:babel-runtime@5.8.20/core-js/object/create", "npm:babel-runtime@5.8.20/core-js/object/set-prototype-of"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$create = require("npm:babel-runtime@5.8.20/core-js/object/create")["default"];
  var _Object$setPrototypeOf = require("npm:babel-runtime@5.8.20/core-js/object/set-prototype-of")["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1/lib", ["npm:alt@0.17.1/lib/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:alt@0.17.1/lib/index");
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-buffer@0.1.0", ["github:jspm/nodelibs-buffer@0.1.0/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-buffer@0.1.0/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/DOMPropertyOperations", ["npm:react@0.14.0-beta3/lib/DOMProperty", "npm:react@0.14.0-beta3/lib/quoteAttributeValueForBrowser", "npm:fbjs@0.1.0-alpha.4/lib/warning", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMProperty = require("npm:react@0.14.0-beta3/lib/DOMProperty");
    var quoteAttributeValueForBrowser = require("npm:react@0.14.0-beta3/lib/quoteAttributeValueForBrowser");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][a-zA-Z_\.\-\d]*$/;
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
        return true;
      }
      if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
        return false;
      }
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
        validatedAttributeNameCache[attributeName] = true;
        return true;
      }
      illegalAttributeNameCache[attributeName] = true;
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
      return false;
    }
    function shouldIgnoreValue(propertyInfo, value) {
      return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
    }
    if (process.env.NODE_ENV !== 'production') {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true
      };
      var warnedProperties = {};
      var warnUnknownProperty = function(name) {
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return ;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
        process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
      };
    }
    var DOMPropertyOperations = {
      createMarkupForID: function(id) {
        return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
      },
      createMarkupForProperty: function(name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          if (shouldIgnoreValue(propertyInfo, value)) {
            return '';
          }
          var attributeName = propertyInfo.attributeName;
          if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
            return attributeName + '=""';
          }
          return attributeName + '=' + quoteAttributeValueForBrowser(value);
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return name + '=' + quoteAttributeValueForBrowser(value);
        } else if (process.env.NODE_ENV !== 'production') {
          warnUnknownProperty(name);
        }
        return null;
      },
      createMarkupForCustomAttribute: function(name, value) {
        if (!isAttributeNameSafe(name) || value == null) {
          return '';
        }
        return name + '=' + quoteAttributeValueForBrowser(value);
      },
      setValueForProperty: function(node, name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(propertyInfo, value)) {
            this.deleteValueForProperty(node, name);
          } else if (propertyInfo.mustUseAttribute) {
            var attributeName = propertyInfo.attributeName;
            var namespace = propertyInfo.attributeNamespace;
            if (namespace) {
              node.setAttributeNS(namespace, attributeName, '' + value);
            } else {
              node.setAttribute(attributeName, '' + value);
            }
          } else {
            var propName = propertyInfo.propertyName;
            if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
              node[propName] = value;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          DOMPropertyOperations.setValueForAttribute(node, name, value);
        } else if (process.env.NODE_ENV !== 'production') {
          warnUnknownProperty(name);
        }
      },
      setValueForAttribute: function(node, name, value) {
        if (!isAttributeNameSafe(name)) {
          return ;
        }
        if (value == null) {
          node.removeAttribute(name);
        } else {
          node.setAttribute(name, '' + value);
        }
      },
      deleteValueForProperty: function(node, name) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (propertyInfo.mustUseAttribute) {
            node.removeAttribute(propertyInfo.attributeName);
          } else {
            var propName = propertyInfo.propertyName;
            var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
            if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
              node[propName] = defaultValue;
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        } else if (process.env.NODE_ENV !== 'production') {
          warnUnknownProperty(name);
        }
      }
    };
    module.exports = DOMPropertyOperations;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactComponentBrowserEnvironment", ["npm:react@0.14.0-beta3/lib/ReactDOMIDOperations", "npm:react@0.14.0-beta3/lib/ReactMount", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactDOMIDOperations = require("npm:react@0.14.0-beta3/lib/ReactDOMIDOperations");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactComponentBrowserEnvironment = {
      processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
      replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
      unmountIDFromEnvironment: function(rootNodeID) {
        ReactMount.purgeID(rootNodeID);
      }
    };
    module.exports = ReactComponentBrowserEnvironment;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:alt@0.17.1", ["npm:alt@0.17.1/lib"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:alt@0.17.1/lib");
  global.define = __define;
  return module.exports;
});

System.register("npm:js-binarypack@0.0.9/lib/bufferbuilder", ["github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var binaryFeatures = {};
    binaryFeatures.useBlobBuilder = (function() {
      try {
        new Blob([]);
        return false;
      } catch (e) {
        return true;
      }
    })();
    binaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && (function() {
      try {
        return (new Blob([new Uint8Array([])])).size === 0;
      } catch (e) {
        return true;
      }
    })();
    module.exports.binaryFeatures = binaryFeatures;
    var BlobBuilder = module.exports.BlobBuilder;
    if (typeof window != 'undefined') {
      BlobBuilder = module.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;
    }
    function BufferBuilder() {
      this._pieces = [];
      this._parts = [];
    }
    BufferBuilder.prototype.append = function(data) {
      if (typeof data === 'number') {
        this._pieces.push(data);
      } else {
        this.flush();
        this._parts.push(data);
      }
    };
    BufferBuilder.prototype.flush = function() {
      if (this._pieces.length > 0) {
        var buf = new Uint8Array(this._pieces);
        if (!binaryFeatures.useArrayBufferView) {
          buf = buf.buffer;
        }
        this._parts.push(buf);
        this._pieces = [];
      }
    };
    BufferBuilder.prototype.getBuffer = function() {
      this.flush();
      if (binaryFeatures.useBlobBuilder) {
        var builder = new BlobBuilder();
        for (var i = 0,
            ii = this._parts.length; i < ii; i++) {
          builder.append(this._parts[i]);
        }
        return builder.getBlob();
      } else {
        return new Blob(this._parts);
      }
    };
    module.exports.BufferBuilder = BufferBuilder;
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOMTextComponent", ["npm:react@0.14.0-beta3/lib/DOMPropertyOperations", "npm:react@0.14.0-beta3/lib/ReactComponentBrowserEnvironment", "npm:react@0.14.0-beta3/lib/ReactDOMComponent", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser", "npm:react@0.14.0-beta3/lib/validateDOMNesting", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var DOMPropertyOperations = require("npm:react@0.14.0-beta3/lib/DOMPropertyOperations");
    var ReactComponentBrowserEnvironment = require("npm:react@0.14.0-beta3/lib/ReactComponentBrowserEnvironment");
    var ReactDOMComponent = require("npm:react@0.14.0-beta3/lib/ReactDOMComponent");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var escapeTextContentForBrowser = require("npm:react@0.14.0-beta3/lib/escapeTextContentForBrowser");
    var validateDOMNesting = require("npm:react@0.14.0-beta3/lib/validateDOMNesting");
    var ReactDOMTextComponent = function(props) {};
    assign(ReactDOMTextComponent.prototype, {
      construct: function(text) {
        this._currentElement = text;
        this._stringText = '' + text;
        this._rootNodeID = null;
        this._mountIndex = 0;
      },
      mountComponent: function(rootID, transaction, context) {
        if (process.env.NODE_ENV !== 'production') {
          if (context[validateDOMNesting.ancestorInfoContextKey]) {
            validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
          }
        }
        this._rootNodeID = rootID;
        var escapedText = escapeTextContentForBrowser(this._stringText);
        if (transaction.renderToStaticMarkup) {
          return escapedText;
        }
        return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
      },
      receiveComponent: function(nextText, transaction) {
        if (nextText !== this._currentElement) {
          this._currentElement = nextText;
          var nextStringText = '' + nextText;
          if (nextStringText !== this._stringText) {
            this._stringText = nextStringText;
            ReactDOMComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextStringText);
          }
        }
      },
      unmountComponent: function() {
        ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
      }
    });
    module.exports = ReactDOMTextComponent;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:js-binarypack@0.0.9/lib/binarypack", ["npm:js-binarypack@0.0.9/lib/bufferbuilder", "npm:js-binarypack@0.0.9/lib/bufferbuilder", "github:jspm/nodelibs-buffer@0.1.0"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    var BufferBuilder = require("npm:js-binarypack@0.0.9/lib/bufferbuilder").BufferBuilder;
    var binaryFeatures = require("npm:js-binarypack@0.0.9/lib/bufferbuilder").binaryFeatures;
    var BinaryPack = {
      unpack: function(data) {
        var unpacker = new Unpacker(data);
        return unpacker.unpack();
      },
      pack: function(data) {
        var packer = new Packer();
        packer.pack(data);
        var buffer = packer.getBuffer();
        return buffer;
      }
    };
    module.exports = BinaryPack;
    function Unpacker(data) {
      this.index = 0;
      this.dataBuffer = data;
      this.dataView = new Uint8Array(this.dataBuffer);
      this.length = this.dataBuffer.byteLength;
    }
    Unpacker.prototype.unpack = function() {
      var type = this.unpack_uint8();
      if (type < 0x80) {
        var positive_fixnum = type;
        return positive_fixnum;
      } else if ((type ^ 0xe0) < 0x20) {
        var negative_fixnum = (type ^ 0xe0) - 0x20;
        return negative_fixnum;
      }
      var size;
      if ((size = type ^ 0xa0) <= 0x0f) {
        return this.unpack_raw(size);
      } else if ((size = type ^ 0xb0) <= 0x0f) {
        return this.unpack_string(size);
      } else if ((size = type ^ 0x90) <= 0x0f) {
        return this.unpack_array(size);
      } else if ((size = type ^ 0x80) <= 0x0f) {
        return this.unpack_map(size);
      }
      switch (type) {
        case 0xc0:
          return null;
        case 0xc1:
          return undefined;
        case 0xc2:
          return false;
        case 0xc3:
          return true;
        case 0xca:
          return this.unpack_float();
        case 0xcb:
          return this.unpack_double();
        case 0xcc:
          return this.unpack_uint8();
        case 0xcd:
          return this.unpack_uint16();
        case 0xce:
          return this.unpack_uint32();
        case 0xcf:
          return this.unpack_uint64();
        case 0xd0:
          return this.unpack_int8();
        case 0xd1:
          return this.unpack_int16();
        case 0xd2:
          return this.unpack_int32();
        case 0xd3:
          return this.unpack_int64();
        case 0xd4:
          return undefined;
        case 0xd5:
          return undefined;
        case 0xd6:
          return undefined;
        case 0xd7:
          return undefined;
        case 0xd8:
          size = this.unpack_uint16();
          return this.unpack_string(size);
        case 0xd9:
          size = this.unpack_uint32();
          return this.unpack_string(size);
        case 0xda:
          size = this.unpack_uint16();
          return this.unpack_raw(size);
        case 0xdb:
          size = this.unpack_uint32();
          return this.unpack_raw(size);
        case 0xdc:
          size = this.unpack_uint16();
          return this.unpack_array(size);
        case 0xdd:
          size = this.unpack_uint32();
          return this.unpack_array(size);
        case 0xde:
          size = this.unpack_uint16();
          return this.unpack_map(size);
        case 0xdf:
          size = this.unpack_uint32();
          return this.unpack_map(size);
      }
    };
    Unpacker.prototype.unpack_uint8 = function() {
      var byte = this.dataView[this.index] & 0xff;
      this.index++;
      return byte;
    };
    Unpacker.prototype.unpack_uint16 = function() {
      var bytes = this.read(2);
      var uint16 = ((bytes[0] & 0xff) * 256) + (bytes[1] & 0xff);
      this.index += 2;
      return uint16;
    };
    Unpacker.prototype.unpack_uint32 = function() {
      var bytes = this.read(4);
      var uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];
      this.index += 4;
      return uint32;
    };
    Unpacker.prototype.unpack_uint64 = function() {
      var bytes = this.read(8);
      var uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];
      this.index += 8;
      return uint64;
    };
    Unpacker.prototype.unpack_int8 = function() {
      var uint8 = this.unpack_uint8();
      return (uint8 < 0x80) ? uint8 : uint8 - (1 << 8);
    };
    Unpacker.prototype.unpack_int16 = function() {
      var uint16 = this.unpack_uint16();
      return (uint16 < 0x8000) ? uint16 : uint16 - (1 << 16);
    };
    Unpacker.prototype.unpack_int32 = function() {
      var uint32 = this.unpack_uint32();
      return (uint32 < Math.pow(2, 31)) ? uint32 : uint32 - Math.pow(2, 32);
    };
    Unpacker.prototype.unpack_int64 = function() {
      var uint64 = this.unpack_uint64();
      return (uint64 < Math.pow(2, 63)) ? uint64 : uint64 - Math.pow(2, 64);
    };
    Unpacker.prototype.unpack_raw = function(size) {
      if (this.length < this.index + size) {
        throw new Error('BinaryPackFailure: index is out of range' + ' ' + this.index + ' ' + size + ' ' + this.length);
      }
      var buf = this.dataBuffer.slice(this.index, this.index + size);
      this.index += size;
      return buf;
    };
    Unpacker.prototype.unpack_string = function(size) {
      var bytes = this.read(size);
      var i = 0,
          str = '',
          c,
          code;
      while (i < size) {
        c = bytes[i];
        if (c < 128) {
          str += String.fromCharCode(c);
          i++;
        } else if ((c ^ 0xc0) < 32) {
          code = ((c ^ 0xc0) << 6) | (bytes[i + 1] & 63);
          str += String.fromCharCode(code);
          i += 2;
        } else {
          code = ((c & 15) << 12) | ((bytes[i + 1] & 63) << 6) | (bytes[i + 2] & 63);
          str += String.fromCharCode(code);
          i += 3;
        }
      }
      this.index += size;
      return str;
    };
    Unpacker.prototype.unpack_array = function(size) {
      var objects = new Array(size);
      for (var i = 0; i < size; i++) {
        objects[i] = this.unpack();
      }
      return objects;
    };
    Unpacker.prototype.unpack_map = function(size) {
      var map = {};
      for (var i = 0; i < size; i++) {
        var key = this.unpack();
        var value = this.unpack();
        map[key] = value;
      }
      return map;
    };
    Unpacker.prototype.unpack_float = function() {
      var uint32 = this.unpack_uint32();
      var sign = uint32 >> 31;
      var exp = ((uint32 >> 23) & 0xff) - 127;
      var fraction = (uint32 & 0x7fffff) | 0x800000;
      return (sign == 0 ? 1 : -1) * fraction * Math.pow(2, exp - 23);
    };
    Unpacker.prototype.unpack_double = function() {
      var h32 = this.unpack_uint32();
      var l32 = this.unpack_uint32();
      var sign = h32 >> 31;
      var exp = ((h32 >> 20) & 0x7ff) - 1023;
      var hfrac = (h32 & 0xfffff) | 0x100000;
      var frac = hfrac * Math.pow(2, exp - 20) + l32 * Math.pow(2, exp - 52);
      return (sign == 0 ? 1 : -1) * frac;
    };
    Unpacker.prototype.read = function(length) {
      var j = this.index;
      if (j + length <= this.length) {
        return this.dataView.subarray(j, j + length);
      } else {
        throw new Error('BinaryPackFailure: read index out of range');
      }
    };
    function Packer() {
      this.bufferBuilder = new BufferBuilder();
    }
    Packer.prototype.getBuffer = function() {
      return this.bufferBuilder.getBuffer();
    };
    Packer.prototype.pack = function(value) {
      var type = typeof(value);
      if (type == 'string') {
        this.pack_string(value);
      } else if (type == 'number') {
        if (Math.floor(value) === value) {
          this.pack_integer(value);
        } else {
          this.pack_double(value);
        }
      } else if (type == 'boolean') {
        if (value === true) {
          this.bufferBuilder.append(0xc3);
        } else if (value === false) {
          this.bufferBuilder.append(0xc2);
        }
      } else if (type == 'undefined') {
        this.bufferBuilder.append(0xc0);
      } else if (type == 'object') {
        if (value === null) {
          this.bufferBuilder.append(0xc0);
        } else {
          var constructor = value.constructor;
          if (constructor == Array) {
            this.pack_array(value);
          } else if (constructor == Blob || constructor == File) {
            this.pack_bin(value);
          } else if (constructor == ArrayBuffer) {
            if (binaryFeatures.useArrayBufferView) {
              this.pack_bin(new Uint8Array(value));
            } else {
              this.pack_bin(value);
            }
          } else if ('BYTES_PER_ELEMENT' in value) {
            if (binaryFeatures.useArrayBufferView) {
              this.pack_bin(new Uint8Array(value.buffer));
            } else {
              this.pack_bin(value.buffer);
            }
          } else if (constructor == Object) {
            this.pack_object(value);
          } else if (constructor == Date) {
            this.pack_string(value.toString());
          } else if (typeof value.toBinaryPack == 'function') {
            this.bufferBuilder.append(value.toBinaryPack());
          } else {
            throw new Error('Type "' + constructor.toString() + '" not yet supported');
          }
        }
      } else {
        throw new Error('Type "' + type + '" not yet supported');
      }
      this.bufferBuilder.flush();
    };
    Packer.prototype.pack_bin = function(blob) {
      var length = blob.length || blob.byteLength || blob.size;
      if (length <= 0x0f) {
        this.pack_uint8(0xa0 + length);
      } else if (length <= 0xffff) {
        this.bufferBuilder.append(0xda);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this.bufferBuilder.append(0xdb);
        this.pack_uint32(length);
      } else {
        throw new Error('Invalid length');
      }
      this.bufferBuilder.append(blob);
    };
    Packer.prototype.pack_string = function(str) {
      var length = utf8Length(str);
      if (length <= 0x0f) {
        this.pack_uint8(0xb0 + length);
      } else if (length <= 0xffff) {
        this.bufferBuilder.append(0xd8);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this.bufferBuilder.append(0xd9);
        this.pack_uint32(length);
      } else {
        throw new Error('Invalid length');
      }
      this.bufferBuilder.append(str);
    };
    Packer.prototype.pack_array = function(ary) {
      var length = ary.length;
      if (length <= 0x0f) {
        this.pack_uint8(0x90 + length);
      } else if (length <= 0xffff) {
        this.bufferBuilder.append(0xdc);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this.bufferBuilder.append(0xdd);
        this.pack_uint32(length);
      } else {
        throw new Error('Invalid length');
      }
      for (var i = 0; i < length; i++) {
        this.pack(ary[i]);
      }
    };
    Packer.prototype.pack_integer = function(num) {
      if (-0x20 <= num && num <= 0x7f) {
        this.bufferBuilder.append(num & 0xff);
      } else if (0x00 <= num && num <= 0xff) {
        this.bufferBuilder.append(0xcc);
        this.pack_uint8(num);
      } else if (-0x80 <= num && num <= 0x7f) {
        this.bufferBuilder.append(0xd0);
        this.pack_int8(num);
      } else if (0x0000 <= num && num <= 0xffff) {
        this.bufferBuilder.append(0xcd);
        this.pack_uint16(num);
      } else if (-0x8000 <= num && num <= 0x7fff) {
        this.bufferBuilder.append(0xd1);
        this.pack_int16(num);
      } else if (0x00000000 <= num && num <= 0xffffffff) {
        this.bufferBuilder.append(0xce);
        this.pack_uint32(num);
      } else if (-0x80000000 <= num && num <= 0x7fffffff) {
        this.bufferBuilder.append(0xd2);
        this.pack_int32(num);
      } else if (-0x8000000000000000 <= num && num <= 0x7FFFFFFFFFFFFFFF) {
        this.bufferBuilder.append(0xd3);
        this.pack_int64(num);
      } else if (0x0000000000000000 <= num && num <= 0xFFFFFFFFFFFFFFFF) {
        this.bufferBuilder.append(0xcf);
        this.pack_uint64(num);
      } else {
        throw new Error('Invalid integer');
      }
    };
    Packer.prototype.pack_double = function(num) {
      var sign = 0;
      if (num < 0) {
        sign = 1;
        num = -num;
      }
      var exp = Math.floor(Math.log(num) / Math.LN2);
      var frac0 = num / Math.pow(2, exp) - 1;
      var frac1 = Math.floor(frac0 * Math.pow(2, 52));
      var b32 = Math.pow(2, 32);
      var h32 = (sign << 31) | ((exp + 1023) << 20) | (frac1 / b32) & 0x0fffff;
      var l32 = frac1 % b32;
      this.bufferBuilder.append(0xcb);
      this.pack_int32(h32);
      this.pack_int32(l32);
    };
    Packer.prototype.pack_object = function(obj) {
      var keys = Object.keys(obj);
      var length = keys.length;
      if (length <= 0x0f) {
        this.pack_uint8(0x80 + length);
      } else if (length <= 0xffff) {
        this.bufferBuilder.append(0xde);
        this.pack_uint16(length);
      } else if (length <= 0xffffffff) {
        this.bufferBuilder.append(0xdf);
        this.pack_uint32(length);
      } else {
        throw new Error('Invalid length');
      }
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          this.pack(prop);
          this.pack(obj[prop]);
        }
      }
    };
    Packer.prototype.pack_uint8 = function(num) {
      this.bufferBuilder.append(num);
    };
    Packer.prototype.pack_uint16 = function(num) {
      this.bufferBuilder.append(num >> 8);
      this.bufferBuilder.append(num & 0xff);
    };
    Packer.prototype.pack_uint32 = function(num) {
      var n = num & 0xffffffff;
      this.bufferBuilder.append((n & 0xff000000) >>> 24);
      this.bufferBuilder.append((n & 0x00ff0000) >>> 16);
      this.bufferBuilder.append((n & 0x0000ff00) >>> 8);
      this.bufferBuilder.append((n & 0x000000ff));
    };
    Packer.prototype.pack_uint64 = function(num) {
      var high = num / Math.pow(2, 32);
      var low = num % Math.pow(2, 32);
      this.bufferBuilder.append((high & 0xff000000) >>> 24);
      this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
      this.bufferBuilder.append((high & 0x0000ff00) >>> 8);
      this.bufferBuilder.append((high & 0x000000ff));
      this.bufferBuilder.append((low & 0xff000000) >>> 24);
      this.bufferBuilder.append((low & 0x00ff0000) >>> 16);
      this.bufferBuilder.append((low & 0x0000ff00) >>> 8);
      this.bufferBuilder.append((low & 0x000000ff));
    };
    Packer.prototype.pack_int8 = function(num) {
      this.bufferBuilder.append(num & 0xff);
    };
    Packer.prototype.pack_int16 = function(num) {
      this.bufferBuilder.append((num & 0xff00) >> 8);
      this.bufferBuilder.append(num & 0xff);
    };
    Packer.prototype.pack_int32 = function(num) {
      this.bufferBuilder.append((num >>> 24) & 0xff);
      this.bufferBuilder.append((num & 0x00ff0000) >>> 16);
      this.bufferBuilder.append((num & 0x0000ff00) >>> 8);
      this.bufferBuilder.append((num & 0x000000ff));
    };
    Packer.prototype.pack_int64 = function(num) {
      var high = Math.floor(num / Math.pow(2, 32));
      var low = num % Math.pow(2, 32);
      this.bufferBuilder.append((high & 0xff000000) >>> 24);
      this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
      this.bufferBuilder.append((high & 0x0000ff00) >>> 8);
      this.bufferBuilder.append((high & 0x000000ff));
      this.bufferBuilder.append((low & 0xff000000) >>> 24);
      this.bufferBuilder.append((low & 0x00ff0000) >>> 16);
      this.bufferBuilder.append((low & 0x0000ff00) >>> 8);
      this.bufferBuilder.append((low & 0x000000ff));
    };
    function _utf8Replace(m) {
      var code = m.charCodeAt(0);
      if (code <= 0x7ff)
        return '00';
      if (code <= 0xffff)
        return '000';
      if (code <= 0x1fffff)
        return '0000';
      if (code <= 0x3ffffff)
        return '00000';
      return '000000';
    }
    function utf8Length(str) {
      if (str.length > 600) {
        return (new Blob([str])).size;
      } else {
        return str.replace(/[^\u0000-\u007F]/g, _utf8Replace).length;
      }
    }
  })(require("github:jspm/nodelibs-buffer@0.1.0").Buffer);
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/ReactDOM", ["npm:react@0.14.0-beta3/lib/ReactCurrentOwner", "npm:react@0.14.0-beta3/lib/ReactDOMTextComponent", "npm:react@0.14.0-beta3/lib/ReactDefaultInjection", "npm:react@0.14.0-beta3/lib/ReactInstanceHandles", "npm:react@0.14.0-beta3/lib/ReactMount", "npm:react@0.14.0-beta3/lib/ReactPerf", "npm:react@0.14.0-beta3/lib/ReactReconciler", "npm:react@0.14.0-beta3/lib/ReactUpdates", "npm:react@0.14.0-beta3/lib/findDOMNode", "npm:react@0.14.0-beta3/lib/renderSubtreeIntoContainer", "npm:fbjs@0.1.0-alpha.4/lib/warning", "npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var ReactCurrentOwner = require("npm:react@0.14.0-beta3/lib/ReactCurrentOwner");
    var ReactDOMTextComponent = require("npm:react@0.14.0-beta3/lib/ReactDOMTextComponent");
    var ReactDefaultInjection = require("npm:react@0.14.0-beta3/lib/ReactDefaultInjection");
    var ReactInstanceHandles = require("npm:react@0.14.0-beta3/lib/ReactInstanceHandles");
    var ReactMount = require("npm:react@0.14.0-beta3/lib/ReactMount");
    var ReactPerf = require("npm:react@0.14.0-beta3/lib/ReactPerf");
    var ReactReconciler = require("npm:react@0.14.0-beta3/lib/ReactReconciler");
    var ReactUpdates = require("npm:react@0.14.0-beta3/lib/ReactUpdates");
    var findDOMNode = require("npm:react@0.14.0-beta3/lib/findDOMNode");
    var renderSubtreeIntoContainer = require("npm:react@0.14.0-beta3/lib/renderSubtreeIntoContainer");
    var warning = require("npm:fbjs@0.1.0-alpha.4/lib/warning");
    ReactDefaultInjection.inject();
    var render = ReactPerf.measure('React', 'render', ReactMount.render);
    var React = {
      findDOMNode: findDOMNode,
      render: render,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      unstable_batchedUpdates: ReactUpdates.batchedUpdates,
      unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        CurrentOwner: ReactCurrentOwner,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        Reconciler: ReactReconciler,
        TextComponent: ReactDOMTextComponent
      });
    }
    if (process.env.NODE_ENV !== 'production') {
      var ExecutionEnvironment = require("npm:fbjs@0.1.0-alpha.4/lib/ExecutionEnvironment");
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (navigator.userAgent.indexOf('Chrome') > -1) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
            console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
          }
        }
        var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
        process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
            break;
          }
        }
      }
    }
    module.exports = React;
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:js-binarypack@0.0.9", ["npm:js-binarypack@0.0.9/lib/binarypack"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:js-binarypack@0.0.9/lib/binarypack");
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/lib/React", ["npm:react@0.14.0-beta3/lib/ReactDOM", "npm:react@0.14.0-beta3/lib/ReactDOMServer", "npm:react@0.14.0-beta3/lib/ReactIsomorphic", "npm:react@0.14.0-beta3/lib/Object.assign"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ReactDOM = require("npm:react@0.14.0-beta3/lib/ReactDOM");
  var ReactDOMServer = require("npm:react@0.14.0-beta3/lib/ReactDOMServer");
  var ReactIsomorphic = require("npm:react@0.14.0-beta3/lib/ReactIsomorphic");
  var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
  var React = {};
  assign(React, ReactIsomorphic);
  assign(React, ReactDOM);
  assign(React, ReactDOMServer);
  React.version = '0.14.0-beta3';
  module.exports = React;
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14/lib/util", ["npm:js-binarypack@0.0.9", "npm:peerjs@0.3.14/lib/adapter"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var defaultConfig = {'iceServers': [{'url': 'stun:stun.l.google.com:19302'}]};
  var dataCount = 1;
  var BinaryPack = require("npm:js-binarypack@0.0.9");
  var RTCPeerConnection = require("npm:peerjs@0.3.14/lib/adapter").RTCPeerConnection;
  var util = {
    noop: function() {},
    CLOUD_HOST: '0.peerjs.com',
    CLOUD_PORT: 9000,
    chunkedBrowsers: {'Chrome': 1},
    chunkedMTU: 16300,
    logLevel: 0,
    setLogLevel: function(level) {
      var debugLevel = parseInt(level, 10);
      if (!isNaN(parseInt(level, 10))) {
        util.logLevel = debugLevel;
      } else {
        util.logLevel = level ? 3 : 0;
      }
      util.log = util.warn = util.error = util.noop;
      if (util.logLevel > 0) {
        util.error = util._printWith('ERROR');
      }
      if (util.logLevel > 1) {
        util.warn = util._printWith('WARNING');
      }
      if (util.logLevel > 2) {
        util.log = util._print;
      }
    },
    setLogFunction: function(fn) {
      if (fn.constructor !== Function) {
        util.warn('The log function you passed in is not a function. Defaulting to regular logs.');
      } else {
        util._print = fn;
      }
    },
    _printWith: function(prefix) {
      return function() {
        var copy = Array.prototype.slice.call(arguments);
        copy.unshift(prefix);
        util._print.apply(util, copy);
      };
    },
    _print: function() {
      var err = false;
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift('PeerJS: ');
      for (var i = 0,
          l = copy.length; i < l; i++) {
        if (copy[i] instanceof Error) {
          copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
          err = true;
        }
      }
      err ? console.error.apply(console, copy) : console.log.apply(console, copy);
    },
    defaultConfig: defaultConfig,
    browser: (function() {
      if (window.mozRTCPeerConnection) {
        return 'Firefox';
      } else if (window.webkitRTCPeerConnection) {
        return 'Chrome';
      } else if (window.RTCPeerConnection) {
        return 'Supported';
      } else {
        return 'Unsupported';
      }
    })(),
    supports: (function() {
      if (typeof RTCPeerConnection === 'undefined') {
        return {};
      }
      var data = true;
      var audioVideo = true;
      var binaryBlob = false;
      var sctp = false;
      var onnegotiationneeded = !!window.webkitRTCPeerConnection;
      var pc,
          dc;
      try {
        pc = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
      } catch (e) {
        data = false;
        audioVideo = false;
      }
      if (data) {
        try {
          dc = pc.createDataChannel('_PEERJSTEST');
        } catch (e) {
          data = false;
        }
      }
      if (data) {
        try {
          dc.binaryType = 'blob';
          binaryBlob = true;
        } catch (e) {}
        var reliablePC = new RTCPeerConnection(defaultConfig, {});
        try {
          var reliableDC = reliablePC.createDataChannel('_PEERJSRELIABLETEST', {});
          sctp = reliableDC.reliable;
        } catch (e) {}
        reliablePC.close();
      }
      if (audioVideo) {
        audioVideo = !!pc.addStream;
      }
      if (!onnegotiationneeded && data) {
        var negotiationPC = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
        negotiationPC.onnegotiationneeded = function() {
          onnegotiationneeded = true;
          if (util && util.supports) {
            util.supports.onnegotiationneeded = true;
          }
        };
        negotiationPC.createDataChannel('_PEERJSNEGOTIATIONTEST');
        setTimeout(function() {
          negotiationPC.close();
        }, 1000);
      }
      if (pc) {
        pc.close();
      }
      return {
        audioVideo: audioVideo,
        data: data,
        binaryBlob: binaryBlob,
        binary: sctp,
        reliable: sctp,
        sctp: sctp,
        onnegotiationneeded: onnegotiationneeded
      };
    }()),
    validateId: function(id) {
      return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);
    },
    validateKey: function(key) {
      return !key || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);
    },
    debug: false,
    inherits: function(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    },
    extend: function(dest, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          dest[key] = source[key];
        }
      }
      return dest;
    },
    pack: BinaryPack.pack,
    unpack: BinaryPack.unpack,
    log: function() {
      if (util.debug) {
        var err = false;
        var copy = Array.prototype.slice.call(arguments);
        copy.unshift('PeerJS: ');
        for (var i = 0,
            l = copy.length; i < l; i++) {
          if (copy[i] instanceof Error) {
            copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
            err = true;
          }
        }
        err ? console.error.apply(console, copy) : console.log.apply(console, copy);
      }
    },
    setZeroTimeout: (function(global) {
      var timeouts = [];
      var messageName = 'zero-timeout-message';
      function setZeroTimeoutPostMessage(fn) {
        timeouts.push(fn);
        global.postMessage(messageName, '*');
      }
      function handleMessage(event) {
        if (event.source == global && event.data == messageName) {
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (timeouts.length) {
            timeouts.shift()();
          }
        }
      }
      if (global.addEventListener) {
        global.addEventListener('message', handleMessage, true);
      } else if (global.attachEvent) {
        global.attachEvent('onmessage', handleMessage);
      }
      return setZeroTimeoutPostMessage;
    }(window)),
    chunk: function(bl) {
      var chunks = [];
      var size = bl.size;
      var start = index = 0;
      var total = Math.ceil(size / util.chunkedMTU);
      while (start < size) {
        var end = Math.min(size, start + util.chunkedMTU);
        var b = bl.slice(start, end);
        var chunk = {
          __peerData: dataCount,
          n: index,
          data: b,
          total: total
        };
        chunks.push(chunk);
        start = end;
        index += 1;
      }
      dataCount += 1;
      return chunks;
    },
    blobToArrayBuffer: function(blob, cb) {
      var fr = new FileReader();
      fr.onload = function(evt) {
        cb(evt.target.result);
      };
      fr.readAsArrayBuffer(blob);
    },
    blobToBinaryString: function(blob, cb) {
      var fr = new FileReader();
      fr.onload = function(evt) {
        cb(evt.target.result);
      };
      fr.readAsBinaryString(blob);
    },
    binaryStringToArrayBuffer: function(binary) {
      var byteArray = new Uint8Array(binary.length);
      for (var i = 0; i < binary.length; i++) {
        byteArray[i] = binary.charCodeAt(i) & 0xff;
      }
      return byteArray.buffer;
    },
    randomToken: function() {
      return Math.random().toString(36).substr(2);
    },
    isSecure: function() {
      return location.protocol === 'https:';
    }
  };
  module.exports = util;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3/react", ["npm:react@0.14.0-beta3/lib/React", "npm:react@0.14.0-beta3/lib/Object.assign", "npm:react@0.14.0-beta3/lib/deprecated", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var React = require("npm:react@0.14.0-beta3/lib/React");
    var assign = require("npm:react@0.14.0-beta3/lib/Object.assign");
    var deprecated = require("npm:react@0.14.0-beta3/lib/deprecated");
    if (process.env.NODE_ENV !== 'production') {
      var deprecations = {
        findDOMNode: deprecated('findDOMNode', 'react-dom', React, React.findDOMNode),
        render: deprecated('render', 'react-dom', React, React.render),
        unmountComponentAtNode: deprecated('unmountComponentAtNode', 'react-dom', React, React.unmountComponentAtNode),
        renderToString: deprecated('renderToString', 'react-dom/server', React, React.renderToString),
        renderToStaticMarkup: deprecated('renderToStaticMarkup', 'react-dom/server', React, React.renderToStaticMarkup)
      };
      module.exports = assign({}, React, deprecations);
    } else {
      module.exports = React;
    }
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14/lib/peer", ["npm:peerjs@0.3.14/lib/util", "npm:eventemitter3@0.1.6", "npm:peerjs@0.3.14/lib/socket", "npm:peerjs@0.3.14/lib/mediaconnection", "npm:peerjs@0.3.14/lib/dataconnection"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var util = require("npm:peerjs@0.3.14/lib/util");
  var EventEmitter = require("npm:eventemitter3@0.1.6");
  var Socket = require("npm:peerjs@0.3.14/lib/socket");
  var MediaConnection = require("npm:peerjs@0.3.14/lib/mediaconnection");
  var DataConnection = require("npm:peerjs@0.3.14/lib/dataconnection");
  function Peer(id, options) {
    if (!(this instanceof Peer))
      return new Peer(id, options);
    EventEmitter.call(this);
    if (id && id.constructor == Object) {
      options = id;
      id = undefined;
    } else if (id) {
      id = id.toString();
    }
    options = util.extend({
      debug: 0,
      host: util.CLOUD_HOST,
      port: util.CLOUD_PORT,
      key: 'peerjs',
      path: '/',
      token: util.randomToken(),
      config: util.defaultConfig
    }, options);
    this.options = options;
    if (options.host === '/') {
      options.host = window.location.hostname;
    }
    if (options.path[0] !== '/') {
      options.path = '/' + options.path;
    }
    if (options.path[options.path.length - 1] !== '/') {
      options.path += '/';
    }
    if (options.secure === undefined && options.host !== util.CLOUD_HOST) {
      options.secure = util.isSecure();
    }
    if (options.logFunction) {
      util.setLogFunction(options.logFunction);
    }
    util.setLogLevel(options.debug);
    if (!util.supports.audioVideo && !util.supports.data) {
      this._delayedAbort('browser-incompatible', 'The current browser does not support WebRTC');
      return ;
    }
    if (!util.validateId(id)) {
      this._delayedAbort('invalid-id', 'ID "' + id + '" is invalid');
      return ;
    }
    if (!util.validateKey(options.key)) {
      this._delayedAbort('invalid-key', 'API KEY "' + options.key + '" is invalid');
      return ;
    }
    if (options.secure && options.host === '0.peerjs.com') {
      this._delayedAbort('ssl-unavailable', 'The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS.');
      return ;
    }
    this.destroyed = false;
    this.disconnected = false;
    this.open = false;
    this.connections = {};
    this._lostMessages = {};
    this._initializeServerConnection();
    if (id) {
      this._initialize(id);
    } else {
      this._retrieveId();
    }
  }
  util.inherits(Peer, EventEmitter);
  Peer.prototype._initializeServerConnection = function() {
    var self = this;
    this.socket = new Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key);
    this.socket.on('message', function(data) {
      self._handleMessage(data);
    });
    this.socket.on('error', function(error) {
      self._abort('socket-error', error);
    });
    this.socket.on('disconnected', function() {
      if (!self.disconnected) {
        self.emitError('network', 'Lost connection to server.');
        self.disconnect();
      }
    });
    this.socket.on('close', function() {
      if (!self.disconnected) {
        self._abort('socket-closed', 'Underlying socket is already closed.');
      }
    });
  };
  Peer.prototype._retrieveId = function(cb) {
    var self = this;
    var http = new XMLHttpRequest();
    var protocol = this.options.secure ? 'https://' : 'http://';
    var url = protocol + this.options.host + ':' + this.options.port + this.options.path + this.options.key + '/id';
    var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
    url += queryString;
    http.open('get', url, true);
    http.onerror = function(e) {
      util.error('Error retrieving ID', e);
      var pathError = '';
      if (self.options.path === '/' && self.options.host !== util.CLOUD_HOST) {
        pathError = ' If you passed in a `path` to your self-hosted PeerServer, ' + 'you\'ll also need to pass in that same path when creating a new ' + 'Peer.';
      }
      self._abort('server-error', 'Could not get an ID from the server.' + pathError);
    };
    http.onreadystatechange = function() {
      if (http.readyState !== 4) {
        return ;
      }
      if (http.status !== 200) {
        http.onerror();
        return ;
      }
      self._initialize(http.responseText);
    };
    http.send(null);
  };
  Peer.prototype._initialize = function(id) {
    this.id = id;
    this.socket.start(this.id, this.options.token);
  };
  Peer.prototype._handleMessage = function(message) {
    var type = message.type;
    var payload = message.payload;
    var peer = message.src;
    var connection;
    switch (type) {
      case 'OPEN':
        this.emit('open', this.id);
        this.open = true;
        break;
      case 'ERROR':
        this._abort('server-error', payload.msg);
        break;
      case 'ID-TAKEN':
        this._abort('unavailable-id', 'ID `' + this.id + '` is taken');
        break;
      case 'INVALID-KEY':
        this._abort('invalid-key', 'API KEY "' + this.options.key + '" is invalid');
        break;
      case 'LEAVE':
        util.log('Received leave message from', peer);
        this._cleanupPeer(peer);
        break;
      case 'EXPIRE':
        this.emitError('peer-unavailable', 'Could not connect to peer ' + peer);
        break;
      case 'OFFER':
        var connectionId = payload.connectionId;
        connection = this.getConnection(peer, connectionId);
        if (connection) {
          util.warn('Offer received for existing Connection ID:', connectionId);
        } else {
          if (payload.type === 'media') {
            connection = new MediaConnection(peer, this, {
              connectionId: connectionId,
              _payload: payload,
              metadata: payload.metadata
            });
            this._addConnection(peer, connection);
            this.emit('call', connection);
          } else if (payload.type === 'data') {
            connection = new DataConnection(peer, this, {
              connectionId: connectionId,
              _payload: payload,
              metadata: payload.metadata,
              label: payload.label,
              serialization: payload.serialization,
              reliable: payload.reliable
            });
            this._addConnection(peer, connection);
            this.emit('connection', connection);
          } else {
            util.warn('Received malformed connection type:', payload.type);
            return ;
          }
          var messages = this._getMessages(connectionId);
          for (var i = 0,
              ii = messages.length; i < ii; i += 1) {
            connection.handleMessage(messages[i]);
          }
        }
        break;
      default:
        if (!payload) {
          util.warn('You received a malformed message from ' + peer + ' of type ' + type);
          return ;
        }
        var id = payload.connectionId;
        connection = this.getConnection(peer, id);
        if (connection && connection.pc) {
          connection.handleMessage(message);
        } else if (id) {
          this._storeMessage(id, message);
        } else {
          util.warn('You received an unrecognized message:', message);
        }
        break;
    }
  };
  Peer.prototype._storeMessage = function(connectionId, message) {
    if (!this._lostMessages[connectionId]) {
      this._lostMessages[connectionId] = [];
    }
    this._lostMessages[connectionId].push(message);
  };
  Peer.prototype._getMessages = function(connectionId) {
    var messages = this._lostMessages[connectionId];
    if (messages) {
      delete this._lostMessages[connectionId];
      return messages;
    } else {
      return [];
    }
  };
  Peer.prototype.connect = function(peer, options) {
    if (this.disconnected) {
      util.warn('You cannot connect to a new Peer because you called ' + '.disconnect() on this Peer and ended your connection with the ' + 'server. You can create a new Peer to reconnect, or call reconnect ' + 'on this peer if you believe its ID to still be available.');
      this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');
      return ;
    }
    var connection = new DataConnection(peer, this, options);
    this._addConnection(peer, connection);
    return connection;
  };
  Peer.prototype.call = function(peer, stream, options) {
    if (this.disconnected) {
      util.warn('You cannot connect to a new Peer because you called ' + '.disconnect() on this Peer and ended your connection with the ' + 'server. You can create a new Peer to reconnect.');
      this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');
      return ;
    }
    if (!stream) {
      util.error('To call a peer, you must provide a stream from your browser\'s `getUserMedia`.');
      return ;
    }
    options = options || {};
    options._stream = stream;
    var call = new MediaConnection(peer, this, options);
    this._addConnection(peer, call);
    return call;
  };
  Peer.prototype._addConnection = function(peer, connection) {
    if (!this.connections[peer]) {
      this.connections[peer] = [];
    }
    this.connections[peer].push(connection);
  };
  Peer.prototype.getConnection = function(peer, id) {
    var connections = this.connections[peer];
    if (!connections) {
      return null;
    }
    for (var i = 0,
        ii = connections.length; i < ii; i++) {
      if (connections[i].id === id) {
        return connections[i];
      }
    }
    return null;
  };
  Peer.prototype._delayedAbort = function(type, message) {
    var self = this;
    util.setZeroTimeout(function() {
      self._abort(type, message);
    });
  };
  Peer.prototype._abort = function(type, message) {
    util.error('Aborting!');
    if (!this._lastServerId) {
      this.destroy();
    } else {
      this.disconnect();
    }
    this.emitError(type, message);
  };
  Peer.prototype.emitError = function(type, err) {
    util.error('Error:', err);
    if (typeof err === 'string') {
      err = new Error(err);
    }
    err.type = type;
    this.emit('error', err);
  };
  Peer.prototype.destroy = function() {
    if (!this.destroyed) {
      this._cleanup();
      this.disconnect();
      this.destroyed = true;
    }
  };
  Peer.prototype._cleanup = function() {
    if (this.connections) {
      var peers = Object.keys(this.connections);
      for (var i = 0,
          ii = peers.length; i < ii; i++) {
        this._cleanupPeer(peers[i]);
      }
    }
    this.emit('close');
  };
  Peer.prototype._cleanupPeer = function(peer) {
    var connections = this.connections[peer];
    for (var j = 0,
        jj = connections.length; j < jj; j += 1) {
      connections[j].close();
    }
  };
  Peer.prototype.disconnect = function() {
    var self = this;
    util.setZeroTimeout(function() {
      if (!self.disconnected) {
        self.disconnected = true;
        self.open = false;
        if (self.socket) {
          self.socket.close();
        }
        self.emit('disconnected', self.id);
        self._lastServerId = self.id;
        self.id = null;
      }
    });
  };
  Peer.prototype.reconnect = function() {
    if (this.disconnected && !this.destroyed) {
      util.log('Attempting reconnection to server with ID ' + this._lastServerId);
      this.disconnected = false;
      this._initializeServerConnection();
      this._initialize(this._lastServerId);
    } else if (this.destroyed) {
      throw new Error('This peer cannot reconnect to the server. It has already been destroyed.');
    } else if (!this.disconnected && !this.open) {
      util.error('In a hurry? We\'re still trying to make the initial connection!');
    } else {
      throw new Error('Peer ' + this.id + ' cannot reconnect because it is not disconnected from the server!');
    }
  };
  Peer.prototype.listAllPeers = function(cb) {
    cb = cb || function() {};
    var self = this;
    var http = new XMLHttpRequest();
    var protocol = this.options.secure ? 'https://' : 'http://';
    var url = protocol + this.options.host + ':' + this.options.port + this.options.path + this.options.key + '/peers';
    var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
    url += queryString;
    http.open('get', url, true);
    http.onerror = function(e) {
      self._abort('server-error', 'Could not get peers from the server.');
      cb([]);
    };
    http.onreadystatechange = function() {
      if (http.readyState !== 4) {
        return ;
      }
      if (http.status === 401) {
        var helpfulError = '';
        if (self.options.host !== util.CLOUD_HOST) {
          helpfulError = 'It looks like you\'re using the cloud server. You can email ' + 'team@peerjs.com to enable peer listing for your API key.';
        } else {
          helpfulError = 'You need to enable `allow_discovery` on your self-hosted ' + 'PeerServer to use this feature.';
        }
        cb([]);
        throw new Error('It doesn\'t look like you have permission to list peers IDs. ' + helpfulError);
      } else if (http.status !== 200) {
        cb([]);
      } else {
        cb(JSON.parse(http.responseText));
      }
    };
    http.send(null);
  };
  module.exports = Peer;
  global.define = __define;
  return module.exports;
});

System.register("npm:react@0.14.0-beta3", ["npm:react@0.14.0-beta3/react"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:react@0.14.0-beta3/react");
  global.define = __define;
  return module.exports;
});

System.register("npm:peerjs@0.3.14", ["npm:peerjs@0.3.14/lib/peer"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:peerjs@0.3.14/lib/peer");
  global.define = __define;
  return module.exports;
});

System.register("js/linkstate", [], function (_export) {
    "use strict";

    _export("default", linkState);

    function linkState(target) {
        target.prototype.linkState = function (key) {
            var _this = this;

            return {
                value: this.state[key],
                requestChange: function requestChange(newValue) {
                    var state = _this.state;
                    state[key] = newValue;
                    _this.setState(state);
                }
            };
        };
    }

    return {
        setters: [],
        execute: function () {}
    };
});
System.register('js/newsticky', ['npm:babel-runtime@5.8.20/helpers/get', 'npm:babel-runtime@5.8.20/helpers/inherits', 'npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'npm:react@0.14.0-beta3', 'js/stickyactions', 'js/linkstate'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, React, StickyActions, linkState, NewSticky;

    return {
        setters: [function (_npmBabelRuntime5820HelpersGet) {
            _get = _npmBabelRuntime5820HelpersGet['default'];
        }, function (_npmBabelRuntime5820HelpersInherits) {
            _inherits = _npmBabelRuntime5820HelpersInherits['default'];
        }, function (_npmBabelRuntime5820HelpersCreateClass) {
            _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
        }, function (_npmReact0140Beta3) {
            React = _npmReact0140Beta3['default'];
        }, function (_jsStickyactions) {
            StickyActions = _jsStickyactions['default'];
        }, function (_jsLinkstate) {
            linkState = _jsLinkstate['default'];
        }],
        execute: function () {
            'use strict';

            NewSticky = (function (_React$Component) {
                _inherits(NewSticky, _React$Component);

                function NewSticky(props) {
                    _classCallCheck(this, _NewSticky);

                    _get(Object.getPrototypeOf(_NewSticky.prototype), 'constructor', this).call(this, props);
                    this.state = { sticky_text: "" };
                }

                _createClass(NewSticky, [{
                    key: 'create',
                    value: function create() {
                        var s = {};
                        s.text = this.state.sticky_text;
                        StickyActions.create(s);
                    }
                }, {
                    key: 'render',
                    value: function render() {
                        var _this = this;

                        return React.createElement(
                            'div',
                            { className: 'row' },
                            React.createElement(
                                'label',
                                { 'for': 'new_sticky' },
                                'New Sticky:'
                            ),
                            React.createElement('input', { type: 'text', className: 'form-control', id: 'new_sticky', valueLink: this.linkState('sticky_text') }),
                            React.createElement(
                                'button',
                                { className: 'btn', onClick: function () {
                                        return _this.create();
                                    } },
                                'Create'
                            )
                        );
                    }
                }]);

                var _NewSticky = NewSticky;
                NewSticky = linkState(NewSticky) || NewSticky;
                return NewSticky;
            })(React.Component);

            _export('default', NewSticky);
        }
    };
});
System.register('js/remotewebrtc', ['npm:babel-runtime@5.8.20/helpers/get', 'npm:babel-runtime@5.8.20/helpers/inherits', 'npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'npm:react@0.14.0-beta3', 'js/stickyactions', 'npm:adapterjs@0.11.1', 'npm:alt@0.17.1/utils/connectToStores', 'js/linkstate', 'npm:URIjs@1.16.0'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, React, StickyActions, connectToStores, linkState, URI, RemoteWebRtc;

    return {
        setters: [function (_npmBabelRuntime5820HelpersGet) {
            _get = _npmBabelRuntime5820HelpersGet['default'];
        }, function (_npmBabelRuntime5820HelpersInherits) {
            _inherits = _npmBabelRuntime5820HelpersInherits['default'];
        }, function (_npmBabelRuntime5820HelpersCreateClass) {
            _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
        }, function (_npmReact0140Beta3) {
            React = _npmReact0140Beta3['default'];
        }, function (_jsStickyactions) {
            StickyActions = _jsStickyactions['default'];
        }, function (_npmAdapterjs0111) {}, function (_npmAlt0171UtilsConnectToStores) {
            connectToStores = _npmAlt0171UtilsConnectToStores['default'];
        }, function (_jsLinkstate) {
            linkState = _jsLinkstate['default'];
        }, function (_npmURIjs1160) {
            URI = _npmURIjs1160['default'];
        }],
        execute: function () {
            'use strict';

            RemoteWebRtc = (function (_React$Component) {
                _inherits(RemoteWebRtc, _React$Component);

                function RemoteWebRtc(props) {
                    _classCallCheck(this, _RemoteWebRtc);

                    _get(Object.getPrototypeOf(_RemoteWebRtc.prototype), 'constructor', this).call(this, props);
                    this.state = { remote_id: "" };
                    var uri = new URI(window.location.href).query(true);

                    if (uri.remote) {
                        this.state = { remote_id: uri.remote };
                        StickyActions.createRemoteConnection(uri.remote);
                    }
                }

                _createClass(RemoteWebRtc, [{
                    key: 'connect',
                    value: function connect() {
                        StickyActions.createRemoteConnection(this.state.remote_id);
                    }
                }, {
                    key: 'render',
                    value: function render() {
                        var _this = this;

                        var status = this.props.status;
                        var connected = status == "connected";
                        var uri = new URI(window.location.href);
                        return React.createElement(
                            'div',
                            null,
                            React.createElement(
                                'div',
                                { className: 'row' },
                                React.createElement(
                                    'label',
                                    { 'for': 'remote_id' },
                                    'Remote Id:'
                                ),
                                React.createElement('input', { type: 'text', className: '', id: 'remote_id', valueLink: this.linkState('remote_id'), disabled: connected }),
                                React.createElement(
                                    'button',
                                    { className: 'btn', onClick: function () {
                                            return _this.connect();
                                        } },
                                    'Connect'
                                ),
                                React.createElement(
                                    'span',
                                    null,
                                    this.props.status
                                )
                            ),
                            React.createElement(
                                'div',
                                { className: 'peer_id' },
                                React.createElement(
                                    'span',
                                    null,
                                    uri.search("") + "?remote=" + this.props.peer_id
                                )
                            ),
                            React.createElement('div', null)
                        );
                    }
                }]);

                var _RemoteWebRtc = RemoteWebRtc;
                RemoteWebRtc = linkState(RemoteWebRtc) || RemoteWebRtc;
                return RemoteWebRtc;
            })(React.Component);

            _export('default', RemoteWebRtc);
        }
    };
});
System.register('js/controlpanel', ['npm:babel-runtime@5.8.20/helpers/get', 'npm:babel-runtime@5.8.20/helpers/inherits', 'npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'npm:react@0.14.0-beta3', 'js/remotewebrtc', 'js/newsticky'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, React, RemoteWebRtc, NewSticky, ControlPanel;

    return {
        setters: [function (_npmBabelRuntime5820HelpersGet) {
            _get = _npmBabelRuntime5820HelpersGet['default'];
        }, function (_npmBabelRuntime5820HelpersInherits) {
            _inherits = _npmBabelRuntime5820HelpersInherits['default'];
        }, function (_npmBabelRuntime5820HelpersCreateClass) {
            _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
        }, function (_npmReact0140Beta3) {
            React = _npmReact0140Beta3['default'];
        }, function (_jsRemotewebrtc) {
            RemoteWebRtc = _jsRemotewebrtc['default'];
        }, function (_jsNewsticky) {
            NewSticky = _jsNewsticky['default'];
        }],
        execute: function () {
            'use strict';

            ControlPanel = (function (_React$Component) {
                _inherits(ControlPanel, _React$Component);

                function ControlPanel() {
                    _classCallCheck(this, ControlPanel);

                    _get(Object.getPrototypeOf(ControlPanel.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControlPanel, [{
                    key: 'render',
                    value: function render() {
                        return React.createElement(
                            'div',
                            { className: 'sky-form' },
                            React.createElement(RemoteWebRtc, { status: this.props.peerjs.status, peer_id: this.props.peerjs.id }),
                            React.createElement(NewSticky, null)
                        );
                    }
                }]);

                return ControlPanel;
            })(React.Component);

            _export('default', ControlPanel);
        }
    };
});
System.register('js/alt', ['npm:alt@0.17.1'], function (_export) {
  'use strict';

  var Alt, alt;
  return {
    setters: [function (_npmAlt0171) {
      Alt = _npmAlt0171['default'];
    }],
    execute: function () {
      alt = new Alt();

      _export('default', alt);
    }
  };
});
System.register('js/stickyactions', ['js/alt'], function (_export) {
                        'use strict';

                        var alt;
                        return {
                                                setters: [function (_jsAlt) {
                                                                        alt = _jsAlt['default'];
                                                }],
                                                execute: function () {
                                                                        _export('default', alt.generateActions('create', 'update', 'delete', 'createRemoteConnection', 'receiveData', 'setPeerState', 'stickyToTop'));
                                                }
                        };
});
System.register('js/sticky', ['npm:babel-runtime@5.8.20/helpers/get', 'npm:babel-runtime@5.8.20/helpers/inherits', 'npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'npm:react@0.14.0-beta3', 'js/stickyactions', 'npm:rx@3.0.0'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, React, StickyActions, Rx, Sticky;

    return {
        setters: [function (_npmBabelRuntime5820HelpersGet) {
            _get = _npmBabelRuntime5820HelpersGet['default'];
        }, function (_npmBabelRuntime5820HelpersInherits) {
            _inherits = _npmBabelRuntime5820HelpersInherits['default'];
        }, function (_npmBabelRuntime5820HelpersCreateClass) {
            _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
        }, function (_npmReact0140Beta3) {
            React = _npmReact0140Beta3['default'];
        }, function (_jsStickyactions) {
            StickyActions = _jsStickyactions['default'];
        }, function (_npmRx300) {
            Rx = _npmRx300['default'];
        }],
        execute: function () {
            'use strict';

            Sticky = (function (_React$Component) {
                _inherits(Sticky, _React$Component);

                function Sticky(props) {
                    _classCallCheck(this, Sticky);

                    _get(Object.getPrototypeOf(Sticky.prototype), 'constructor', this).call(this, props);
                }

                _createClass(Sticky, [{
                    key: 'dragSticky',
                    value: function dragSticky(mousePosition) {
                        var _this = this;

                        StickyActions.stickyToTop(this.props.data);

                        var startX = this.props.data.x;
                        var startY = this.props.data.y;

                        var mouseMove = Rx.Observable.merge(Rx.Observable.fromEvent(document, 'mousemove'), Rx.Observable.fromEvent(document, 'touchmove').map(function (event) {
                            event.preventDefault();
                            var touch = event.touches[0];
                            return {
                                clientX: touch.clientX,
                                clientY: touch.clientY
                            };
                        }));

                        var mouseUp = Rx.Observable.merge(Rx.Observable.fromEvent(document, 'mouseup'), Rx.Observable.fromEvent(document, 'touchend'));

                        mouseMove.map(function (moveEvent) {
                            //moveEvent.preventDefault();
                            return {
                                x: moveEvent.clientX - (mousePosition.x - startX),
                                y: moveEvent.clientY - (mousePosition.y - startY)
                            };
                        }).takeUntil(mouseUp).forEach(function (newPos) {
                            //console.log(newPos)
                            var data = _this.props.data;
                            data.x = newPos.x;
                            data.y = newPos.y;
                            StickyActions.update(data);
                        });
                    }
                }, {
                    key: 'onMouseDown',
                    value: function onMouseDown(event) {
                        this.dragSticky({ x: event.clientX, y: event.clientY });
                    }
                }, {
                    key: 'onTouchStart',
                    value: function onTouchStart(event) {
                        var touch = event.touches[0];
                        this.dragSticky({ x: touch.clientX, y: touch.clientY });
                    }
                }, {
                    key: 'onDelete',
                    value: function onDelete() {
                        StickyActions['delete'](this.props.data);
                    }
                }, {
                    key: 'render',
                    value: function render() {
                        var _this2 = this;

                        var data = this.props.data;
                        return React.createElement(
                            'div',
                            { onTouchStart: function (e) {
                                    return _this2.onTouchStart(e);
                                }, onMouseDown: function (e) {
                                    return _this2.onMouseDown(e);
                                }, className: 'sticky', style: { zIndex: data.z, left: data.x, top: data.y } },
                            React.createElement('div', { className: 'close_icon', onClick: function () {
                                    return _this2.onDelete();
                                } }),
                            React.createElement(
                                'div',
                                { className: 'note noselect' },
                                React.createElement(
                                    'div',
                                    { className: 'note noselect' },
                                    data.text
                                )
                            )
                        );
                    }
                }]);

                return Sticky;
            })(React.Component);

            _export('default', Sticky);
        }
    };
});
System.register('js/webrtcmanager', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'npm:peerjs@0.3.14', 'npm:react@0.14.0-beta3', 'js/stickystore', 'js/stickyactions', 'npm:adapterjs@0.11.1'], function (_export) {
    var _createClass, _classCallCheck, Peer, React, StickyStore, StickyActions, WebRtcManager;

    return {
        setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
            _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
        }, function (_npmPeerjs0314) {
            Peer = _npmPeerjs0314['default'];
        }, function (_npmReact0140Beta3) {
            React = _npmReact0140Beta3['default'];
        }, function (_jsStickystore) {
            StickyStore = _jsStickystore['default'];
        }, function (_jsStickyactions) {
            StickyActions = _jsStickyactions['default'];
        }, function (_npmAdapterjs0111) {}],
        execute: function () {
            'use strict';

            WebRtcManager = (function () {
                function WebRtcManager() {
                    _classCallCheck(this, WebRtcManager);

                    this.remoteConnections = [];
                    this.setupPeer();
                }

                _createClass(WebRtcManager, [{
                    key: 'setupPeer',
                    value: function setupPeer() {
                        var _this = this;

                        this.peer = new Peer({ key: 'lwjd5qra8257b9' });
                        this.peer.on('open', function (peer_id) {
                            _this.peer_id = peer_id;
                            StickyActions.setPeerState({ id: _this.peer_id, status: "" });
                        });

                        this.peer.on('connection', function (remoteConnection) {
                            console.log("remote connection from " + remoteConnection.peer);
                            _this.remoteConnections.push(remoteConnection);

                            remoteConnection.on('open', function () {
                                StickyStore.getState().stickies.forEach(function (sticky) {
                                    _this.broadcast(sticky);
                                });
                                remoteConnection.on('data', function (data) {
                                    _this.receive(data);
                                });
                            });
                        });
                    }
                }, {
                    key: 'connectTo',
                    value: function connectTo(remoteId) {
                        var _this2 = this;

                        var conn = this.peer.connect(remoteId);
                        this.peer.on('error', function (err) {
                            return StickyActions.setPeerState({ id: _this2.peer_id, status: "failed" });
                        });
                        conn.on('open', function () {
                            StickyActions.setPeerState({ id: _this2.peer_id, status: "connected" });
                            _this2.remoteConnections.push(conn);
                            conn.on('data', function (data) {
                                _this2.receive(data);
                            });
                        });
                    }
                }, {
                    key: 'receive',
                    value: function receive(data) {
                        console.log(data);
                        if (data.seen_by_peers.indexOf(this.peer_id) == -1) {

                            if (data.action == "delete") {
                                StickyActions['delete'](data);
                            } else {
                                StickyActions.update(data);
                            }
                        }
                    }
                }, {
                    key: 'broadcast',
                    value: function broadcast(data) {
                        data.seen_by_peers = data.seen_by_peers || [];

                        if (data.seen_by_peers.indexOf(this.peer_id) == -1) {
                            data.seen_by_peers.push(this.peer_id);
                        }

                        this.remoteConnections.forEach(function (conn) {
                            if (data.seen_by_peers.indexOf(conn.peer) == -1) {
                                conn.send(data);
                            }
                        });
                    }
                }]);

                return WebRtcManager;
            })();

            _export('default', WebRtcManager);
        }
    };
});
System.register('js/stickystore', ['npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'js/alt', 'js/stickyactions', 'js/webrtcmanager', 'npm:md5@2.0.0'], function (_export) {
    var _createClass, _classCallCheck, alt, StickyActions, WebRtcManager, md5, zindex, StickyStore;

    return {
        setters: [function (_npmBabelRuntime5820HelpersCreateClass) {
            _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
        }, function (_jsAlt) {
            alt = _jsAlt['default'];
        }, function (_jsStickyactions) {
            StickyActions = _jsStickyactions['default'];
        }, function (_jsWebrtcmanager) {
            WebRtcManager = _jsWebrtcmanager['default'];
        }, function (_npmMd5200) {
            md5 = _npmMd5200['default'];
        }],
        execute: function () {
            'use strict';

            zindex = 1;

            StickyStore = (function () {
                function StickyStore() {
                    _classCallCheck(this, StickyStore);

                    this.bindActions(StickyActions);
                    this.state = { stickies: [], peerjs: { id: "", status: "" } };
                    this.state.stickies.push(StickyStore.createStickyData("Retroboard"));
                    this.webRtcManager = new WebRtcManager();
                }

                _createClass(StickyStore, [{
                    key: 'update',
                    value: function update(sticky) {
                        var stickies = this.state.stickies;
                        var s = this.getSticky(sticky.id);
                        if (!s) {
                            s = { id: sticky.id };
                            stickies.push(s);
                        }
                        s.x = sticky.x;
                        s.y = sticky.y;
                        s.z = sticky.z;
                        if (sticky.z > zindex) {
                            zindex = sticky.z;
                        }
                        s.text = sticky.text;
                        this.setState({ stickies: stickies });
                        this.webRtcManager.broadcast(sticky);
                    }
                }, {
                    key: 'create',
                    value: function create(sticky) {
                        var stickies = this.state.stickies;
                        var s = StickyStore.createStickyData(sticky.text);
                        console.log(s.id);
                        stickies.push(s);
                        this.setState({ stickies: stickies });
                        this.webRtcManager.broadcast(s);
                    }
                }, {
                    key: 'delete',
                    value: function _delete(sticky) {
                        var stickies = this.state.stickies;
                        var index = stickies.map(function (s) {
                            return s.id;
                        }).indexOf(sticky.id);
                        stickies.splice(index, 1);
                        this.setState({ stickies: stickies });
                        sticky.action = "delete";
                        this.webRtcManager.broadcast(sticky);
                    }
                }, {
                    key: 'stickyToTop',
                    value: function stickyToTop(sticky) {
                        var stickies = this.state.stickies;
                        var s = this.getSticky(sticky.id);
                        s.z = zindex++;
                        this.setState({ stickies: stickies });
                        this.webRtcManager.broadcast(s);
                    }
                }, {
                    key: 'getSticky',
                    value: function getSticky(id) {
                        return this.state.stickies.filter(function (sticky) {
                            return sticky.id === id;
                        })[0];
                    }
                }, {
                    key: 'createRemoteConnection',
                    value: function createRemoteConnection(remote_id) {
                        this.setState({ peerjs: { id: "", status: "connecting" } });
                        this.webRtcManager.connectTo(remote_id);
                    }
                }, {
                    key: 'setPeerState',
                    value: function setPeerState(peerjs) {
                        this.setState({ peerjs: peerjs });
                    }
                }], [{
                    key: 'createStickyData',
                    value: function createStickyData(text) {
                        var s = {};
                        s.text = text;
                        s.id = md5(text);
                        s.x = 23;
                        s.y = 23;
                        s.z = zindex++;
                        return s;
                    }
                }]);

                return StickyStore;
            })();

            _export('default', alt.createStore(StickyStore));
        }
    };
});
System.register('js/retroboard', ['npm:babel-runtime@5.8.20/helpers/get', 'npm:babel-runtime@5.8.20/helpers/inherits', 'npm:babel-runtime@5.8.20/helpers/create-class', 'npm:babel-runtime@5.8.20/helpers/class-call-check', 'js/sticky', 'js/stickystore', 'js/controlpanel', 'npm:react@0.14.0-beta3', 'npm:alt@0.17.1/utils/connectToStores'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Sticky, StickyStore, ControlPanel, React, connectToStores, Retroboard;

    return {
        setters: [function (_npmBabelRuntime5820HelpersGet) {
            _get = _npmBabelRuntime5820HelpersGet['default'];
        }, function (_npmBabelRuntime5820HelpersInherits) {
            _inherits = _npmBabelRuntime5820HelpersInherits['default'];
        }, function (_npmBabelRuntime5820HelpersCreateClass) {
            _createClass = _npmBabelRuntime5820HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5820HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5820HelpersClassCallCheck['default'];
        }, function (_jsSticky) {
            Sticky = _jsSticky['default'];
        }, function (_jsStickystore) {
            StickyStore = _jsStickystore['default'];
        }, function (_jsControlpanel) {
            ControlPanel = _jsControlpanel['default'];
        }, function (_npmReact0140Beta3) {
            React = _npmReact0140Beta3['default'];
        }, function (_npmAlt0171UtilsConnectToStores) {
            connectToStores = _npmAlt0171UtilsConnectToStores['default'];
        }],
        execute: function () {
            'use strict';

            Retroboard = (function (_React$Component) {
                _inherits(Retroboard, _React$Component);

                _createClass(Retroboard, null, [{
                    key: 'getStores',
                    value: function getStores() {
                        return [StickyStore];
                    }
                }, {
                    key: 'getPropsFromStores',
                    value: function getPropsFromStores() {
                        return StickyStore.getState();
                    }
                }]);

                function Retroboard(props) {
                    _classCallCheck(this, _Retroboard);

                    _get(Object.getPrototypeOf(_Retroboard.prototype), 'constructor', this).call(this, props);
                }

                _createClass(Retroboard, [{
                    key: 'render',
                    value: function render() {
                        return React.createElement(
                            'h1',
                            null,
                            'Hello world'
                        );
                    }
                }, {
                    key: 'render',
                    value: function render() {
                        var stickies = this.props.stickies.map(function (sticky) {
                            return React.createElement(Sticky, { data: sticky });
                        });

                        return React.createElement(
                            'div',
                            { className: 'retroboard' },
                            React.createElement('div', { className: 'retro_ba' }),
                            React.createElement('img', { width: '100%', height: '100%', src: 'img/got_1920x810.jpg' }),
                            React.createElement(ControlPanel, { peerjs: this.props.peerjs }),
                            stickies
                        );
                    }
                }]);

                var _Retroboard = Retroboard;
                Retroboard = connectToStores(Retroboard) || Retroboard;
                return Retroboard;
            })(React.Component);

            _export('default', Retroboard);
        }
    };
});
System.register('js/main', ['npm:react@0.14.0-beta3', 'js/retroboard', 'npm:whatwg-fetch@0.9.0'], function (_export) {
        'use strict';

        var React, Retroboard;
        return {
                setters: [function (_npmReact0140Beta3) {
                        React = _npmReact0140Beta3['default'];
                }, function (_jsRetroboard) {
                        Retroboard = _jsRetroboard['default'];
                }, function (_npmWhatwgFetch090) {}],
                execute: function () {

                        (function (i, s, o, g, r, a, m) {
                                i['GoogleAnalyticsObject'] = r;i[r] = i[r] || function () {
                                        (i[r].q = i[r].q || []).push(arguments);
                                }, i[r].l = 1 * new Date();a = s.createElement(o), m = s.getElementsByTagName(o)[0];a.async = 1;a.src = g;m.parentNode.insertBefore(a, m);
                        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
                        ga('create', 'UA-66210147-1', 'auto');
                        ga('send', 'pageview');

                        React.render(React.createElement(Retroboard, null), document.body);
                }
        };
});
});
//# sourceMappingURL=app.js.map